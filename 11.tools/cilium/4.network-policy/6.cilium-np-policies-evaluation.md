# â­ **Multi-Policy Evaluation in Cilium (FULLY UPDATED With Allow + Deny Rules)**

ğŸ”¥ _"This is the REAL decision logic Cilium uses today â€” including deny rules, precedence, combination, enforcement, and debugging."_

This is a complete, modern, deeply detailed rewrite of Topic 6, incorporating **ingressDeny** and **egressDeny**, as supported in modern Cilium versions.

Prepare to understand Cilium like a kernel developer.

---

## â­ **Cilium Evaluates DENY â†’ Then ALLOW â†’ Then Implicit DENY**

This is the actual logic used in modern Cilium:

```ini
1. Explicit DENY rules (ingressDeny/egressDeny)
2. Explicit ALLOW rules (ingress/egress)
3. Implicit deny (default deny if enforcement enabled)
```

This makes Cilium a 3-layer firewall engine.

Letâ€™s visualize it:

```ini
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚        DENY RULES        â”‚
                â”‚ (Highest Priority Match) â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚       ALLOW RULES        â”‚
                â”‚ (Union of all allows)    â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚      IMPLICIT DENY       â”‚
                â”‚ (if no allow matched)    â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This is the model weâ€™ll explore.

---

## ğŸš¦ What Turns Policy Enforcement ON?

Enforcement becomes active per-pod, per direction:

- If ANY policy with `ingress:` exists â†’ ingress enforcement ON
- If ANY policy with `egress:` exists â†’ egress enforcement ON
- If ANY policy with `ingressDeny:` exists â†’ **deny enforcement** ON for ingress
- If ANY policy with `egressDeny:` exists â†’ **deny enforcement** ON for egress

Run:

```bash
cilium endpoint list
```

You will see columns:

- **Ingress Enforcement**
- **Ingress-Deny Enforcement**
- **Egress Enforcement**
- **Egress-Deny Enforcement**

This is how Cilium toggles each mode.

---

## ğŸ¯ The Rules of Combination (Modern Cilium)

### âœ”ï¸ Rule 1 â€” **Deny rules override allow rules (always)**

If a deny rule matches:

- Source identity
- Destination identity
- Ports (if specified)
- L7 (if specified)

â†’ the flow is **dropped**, even if 100 other policies allow it.

---

### âœ”ï¸ Rule 2 â€” Allow rules combine via UNION

If multiple policies apply to a pod:

- All allowed sources combine
- All allowed ports combine
- All L7 allows combine

There is no â€œpriorityâ€ among allow rules.

---

### âœ”ï¸ Rule 3 â€” Implicit deny happens last

If:

- A pod is in enforced mode AND
- No allow rule matched AND
- No deny rule matched

â†’ traffic is denied with â€œpolicy deniedâ€ (the familiar behavior).

---

## ğŸ§© A Multi-Policy Example (Allow + Deny Combined)

## Pods:

- frontend
- backend
- db

## Policy A (Allow frontend â†’ backend):

```yaml
endpointSelector:
  matchLabels:
    app: backend
ingress:
  - fromEndpoints:
      - matchLabels:
          app: frontend
```

## Policy B (Deny ALL DELETE requests):

```yaml
endpointSelector:
  matchLabels:
    app: backend

ingressDeny:
  - fromEndpoints:
      - matchLabels:
          app: frontend
    toPorts:
      - ports:
          - port: "8080"
        rules:
          http:
            - method: DELETE
              path: "/api/*"
```

### Final behavior:

| Traffic                   | Result                            |
| ------------------------- | --------------------------------- |
| GET frontend â†’ backend    | âœ”ï¸ Allowed                        |
| POST frontend â†’ backend   | âœ”ï¸ Allowed                        |
| DELETE frontend â†’ backend | âŒ Denied (deny takes precedence) |
| Any other pod â†’ backend   | âŒ Denied (implicit deny)         |

Perfectly enforced microsegmentation.

---

## ğŸ›ï¸ How Cilium Actually Evaluates Multi-Policy Rules (Deep Internal Logic)

Every packet undergoes this pipeline:

```ini
âŠ Match against ingressDeny rules
   - If match â†’ DROP

â‹ Match against ingress allow rules
   - If ANY allow matches â†’ ALLOW

âŒ If enforcement enabled â†’ DROP (implicit deny)
```

For egress:

```ini
âŠ Match against egressDeny rules
   - If match â†’ DROP

â‹ Match against egress allow rules
   - If ANY allow matches â†’ ALLOW

âŒ If enforcement enabled â†’ DROP
```

This means:

- Deny rules are a **hard override**
- Allow rules are **union**
- Implicit deny is a safety net

---

## ğŸ§  Combining Clusterwide + Namespaced Policies

CiliumNetworkPolicy (namespaced) +
CiliumClusterwideNetworkPolicy (cluster-wide)

â†’ Combine via:

- allow rules UNION
- deny rules UNION

### Deny still wins across scopes.

---

## ğŸ”¥ Example: Clusterwide Deny + Namespace Allow

## Clusterwide deny:

```yaml
apiVersion: cilium.io/v2
kind: CiliumClusterwideNetworkPolicy
spec:
  endpointSelector:
    matchLabels:
      app: backend

  ingressDeny:
    - fromEntities:
        - cluster
```

Meaning: deny all cluster traffic â†’ backend.

## Namespace allow:

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  namespace: prod
spec:
  endpointSelector:
    matchLabels:
      app: backend

  ingress:
    - fromEndpoints:
        - matchLabels:
            app: frontend
```

### Final behavior:

âŒ ALL pods are denied
Even frontend â†’ backend is blocked
because deny rules override allow rules.

---

## ğŸŒ Example: Multiple Allow Policies + One Deny

### Policy A (Allow namespace prod â†’ db):

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          k8s:io.kubernetes.pod.namespace: prod
```

### Policy B (Allow payment â†’ db):

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          role: payment
```

### Policy C (Deny qa namespace):

```yaml
ingressDeny:
  - fromEndpoints:
      - matchLabels:
          k8s:io.kubernetes.pod.namespace: qa
```

### Final result:

| Source         | Decision   | Why                 |
| -------------- | ---------- | ------------------- |
| prod namespace | âœ”ï¸ Allowed | Allowed by Policy A |
| payment pod    | âœ”ï¸ Allowed | Allowed by Policy B |
| qa namespace   | âŒ Denied  | Denied by Policy C  |
| other pods     | âŒ Denied  | Implicit deny       |

---

## âš ï¸ Common Gotchas With Deny Rules

### â— Gotcha 1 â€” Deny rules DO NOT require specifying direction

- If deny rules exist for ingress â†’ ingress deny enforcement ON.

### â— Gotcha 2 â€” Deny rules apply even if no allow rules exist

- Deny rules are always evaluated when enforcement is on.

### â— Gotcha 3 â€” Deny rules must match identity

- If your deny rule does NOT match identity â†’ it will not block anything.

### â— Gotcha 4 â€” Namespace matching requires correct label

- Use:

  ```yaml
  k8s:io.kubernetes.pod.namespace: <ns>
  ```

### â— Gotcha 5 â€” Deny rules can be L7

- You can deny:

  - specific HTTP methods
  - paths
  - Kafka topics
  - DNS names
  - ports

- Extremely powerful but dangerous if misused.

---

## ğŸ”¬ Debugging Multi-Policy Issues (REAL TOOLS)

### 1. List all active policies

```bash
cilium policy get
```

### 2. See which policies enforce deny/allow:

```bash
cilium endpoint list
```

Check:

- Ingress enforcement
- Ingress deny enforcement
- Egress enforcement
- Egress deny enforcement

### 3. Trace specific flows (the BEST tool)

```bash
cilium policy trace \
  --src-identity <ID1> \
  --dst-identity <ID2> \
  --dport 8080
```

This shows:

- Allow rules matched
- Deny rules matched
- Where decision was made

### 4. Observe live eBPF decisions:

Allowed:

```bash
hubble observe --verdict forwarded
```

Denied (all deny types):

```bash
hubble observe --verdict drop
```

You will see the reason:

- `PolicyDeny`
- `DenyEntityRule`
- `DenyL7`
- `DenyCIDR`

---

## ğŸ“ End-of-Topic Summary

You now understand:

### âœ”ï¸ How Cilium merges policies

### âœ”ï¸ How deny rules override everything

### âœ”ï¸ How allow rules combine via UNION

### âœ”ï¸ How implicit deny works

### âœ”ï¸ How clusterwide + namespaced policies interact

### âœ”ï¸ How to debug multi-policy scenarios

### âœ”ï¸ How to reason about ANY flow outcome

This is the exact knowledge required to operate Cilium safely in production.
