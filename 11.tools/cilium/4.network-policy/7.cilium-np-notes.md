# â­ **Real-World Cilium Policy Design Patterns & Best Practices**

ğŸ”¥ _â€œThis is the chapter that turns you from â€˜someone who writes policiesâ€™ into a real production-grade Cilium architect.â€_

This topic is long, practical, and deeply real-world.
It covers the **true ways** companies design, structure, and deploy Cilium Network Policies in production clusters.

Letâ€™s begin.

---

## ğŸ§­ The 6 Most Important Real-World Design Patterns

These are the patterns used by fintechs, SaaS companies, e-commerce platforms, and k8s security teams worldwide.

### **Pattern 1 â€” Zero-Trust Microservice Segmentation**

Goal:
Each microservice can only communicate with the services itâ€™s supposed to.

Example:

- frontend â†’ backend
- backend â†’ db
- logging-agent â†’ elastic
- metrics-agent â†’ prometheus
- deny everything else

This stops:

- pivot attacks
- accidental cross-service calls
- production traffic escaping into dev environments

This is the **#1 reason companies adopt Cilium**.

---

### **Pattern 2 â€” Namespace-Level Boundaries (Multi-tenant / Multi-team clusters)**

Goal:
Pod in namespace A should never talk to namespace B unless explicitly allowed.

Implementation:

- Use namespace as a label:
  `k8s:io.kubernetes.pod.namespace`
- Add deny rules to isolate namespaces.
- Add selective allow rules for shared services (DNS, logging, metrics).

---

### **Pattern 3 â€” Egress Control to the Internet**

Goal:
Pods should only talk to approved external hosts.

Typical rules:

- Allow HTTPS only
- Allow DNS only to kube-dns
- Allow specific FQDNs (api.stripe.com, github.com, etc.)
- Block all other egress

This is critical for:

- preventing data exfiltration
- managing compliance (ISO, PCI)
- stopping unexpected calls to random IPs

---

### **Pattern 4 â€” Secure External-to-Internal Access (Ingress/LB gateways)**

Goal:
Only approved load balancers / ingresses / external IPs can access your workloads.

Design:

- fromEntities: world
- fromCIDR: ingress-lb CIDRs
- fromEndpoints: ingress-controller pods

This defines a clean, secure boundary between:

- the Internet
- internal services

---

### **Pattern 5 â€” Enforcing L7 Protocol Contracts**

Goal:
Prevent misbehaving or compromised services from calling APIs they shouldnâ€™t.

Examples:

- frontend may only GET `/api/products`
- backend may only POST `/v1/payments`
- deny DELETE on all services
- allow only Kafka topics "orders", "payments"

This is world-class microsegmentation.

---

### **Pattern 6 â€” Shared Infrastructure Allowed to All (But Minimal!)**

Examples:

- kube-dns
- kube-apiserver
- prometheus
- node-exporter
- logging/sidecar agents

Common approach:

- clusterwide egress allow for DNS
- allow apiserver access from agents
- allow metrics traffic to Prometheus
- deny everything else

---

## ğŸ§  Namespace Segmentation (The MOST Common Production Pattern)

Letâ€™s design a real example.

Namespaces:

- `frontend`
- `backend`
- `db`
- `observability`
- `dev`
- `qa`

### ğŸ”¥ Goal:

- frontend can only call backend
- backend can only call db
- dev/qa are isolated
- observability agents can scrape ALL namespaces
- kube-dns allowed to all

---

### âœ”ï¸ Step 1: Global Namespace Isolation (deny)

**Clusterwide deny** to block cross-namespace traffic:

```yaml
apiVersion: cilium.io/v2
kind: CiliumClusterwideNetworkPolicy
metadata:
  name: deny-cross-namespace
spec:
  endpointSelector: {}
  ingressDeny:
    - fromEndpoints:
        - matchExpressions:
            - key: k8s:io.kubernetes.pod.namespace
              operator: NotIn
              values:
                - ${k8s:io.kubernetes.pod.namespace}
```

This pattern says:

> A pod can receive traffic ONLY from the same namespace
> (unless another allow rule says otherwise).

This is the foundation.

---

### âœ”ï¸ Step 2: Allow DNS clusterwide

```yaml
apiVersion: cilium.io/v2
kind: CiliumClusterwideNetworkPolicy
metadata:
  name: allow-dns
spec:
  endpointSelector: {}
  egress:
    - toEndpoints:
        - matchLabels:
            k8s-app: kube-dns
      toPorts:
        - ports:
            - port: "53"
              protocol: UDP
        rules:
          dns:
            - matchPattern: "*"
```

---

### âœ”ï¸ Step 3: Allow frontend â†’ backend

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-frontend-backend
  namespace: backend
spec:
  endpointSelector:
    matchLabels:
      app: backend
  ingress:
    - fromEndpoints:
        - matchLabels:
            app: frontend
            k8s:io.kubernetes.pod.namespace: frontend
```

---

### âœ”ï¸ Step 4: Allow backend â†’ db (only needed port)

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: backend-db
  namespace: db
spec:
  endpointSelector:
    matchLabels:
      app: db
  ingress:
    - fromEndpoints:
        - matchLabels:
            app: backend
            k8s:io.kubernetes.pod.namespace: backend
      toPorts:
        - ports:
            - port: "5432"
              protocol: TCP
```

---

### âœ”ï¸ Step 5: Allow observability namespace to scrape all services

```yaml
apiVersion: cilium.io/v2
kind: CiliumClusterwideNetworkPolicy
metadata:
  name: observability-allow
spec:
  endpointSelector: {}
  ingress:
    - fromEndpoints:
        - matchLabels:
            k8s:io.kubernetes.pod.namespace: observability
```

This allows traffic _from_ observability pods to ALL namespaces.

---

## ğŸ§µ Real-World L7 Policy Patterns

### 1. Allow Only Specific API Routes

```yaml
http:
  - method: GET
    path: "/api/products"
  - method: POST
    path: "/api/cart"
```

---

### 2. Deny Dangerous HTTP Methods Globally

```yaml
ingressDeny:
  - toPorts:
      - rules:
          http:
            - method: DELETE
```

---

### 3. Allow Only HTTPS to Outside World

```yaml
egress:
  - toEntities: [world]
    toPorts:
      - ports: [{ port: "443", protocol: TCP }]
```

---

### 4. Allow Only Certain Domains (SNI-based)

```yaml
rules:
  http:
    - host: "api.stripe.com"
```

---

### 5. Kafka Topic Restrictions

```yaml
rules:
  kafka:
    - topic: "orders"
      apiKey: produce
```

---

## ğŸ”¥ Egress Best Practices (Used by Big Companies)

### âœ”ï¸ Always allow DNS

If ANY egress rule exists â†’ DNS breaks unless explicitly allowed.

### âœ”ï¸ Deny Internet by default

Only allow `world` or `toCIDR` when needed.

### âœ”ï¸ For external APIs â†’ use domain / HTTP host matching

This restricts workloads from contacting unexpected hosts.

### âœ”ï¸ Restrict ports

Allow only 443 unless you have a real reason.

### âœ”ï¸ NEVER allow world:80

Plain HTTP to the Internet is a major security hole.

### âœ”ï¸ Segment access per namespace

Example:

- `backend` can call `db`
- `frontend` cannot
- `dev` cannot reach prod external APIs
- `qa` cannot reach external payment services

This is extremely common.

---

## ğŸ§¨ Deny Rules Best Practices

### âœ”ï¸ Deny Common Attack Vectors

```yaml
ingressDeny:
  - toPorts:
      - rules:
          http:
            - method: DELETE
```

### âœ”ï¸ Deny certain namespaces from accessing sensitive workloads

```yaml
ingressDeny:
  - fromEndpoints:
      - matchLabels:
          k8s:io.kubernetes.pod.namespace: qa
```

### âœ”ï¸ Deny traffic from all pods except for a whitelist

```yaml
ingressDeny:
  - fromEndpoints:
      - matchLabels:
          k8s:io.kubernetes.pod.namespace: "*"
```

Then add specific allow rules.

---

## ğŸ” Observability Best Practices

### âœ”ï¸ Enable Hubble always

Use:

- Flow visibility
- L7 event inspection
- Drop reason analysis
- Identity auditing

### âœ”ï¸ Use `cilium policy trace` to debug rules

Example:

```bash
cilium policy trace --src-identity 43657 --dst-identity 23019 --dport 8080
```

### âœ”ï¸ Use `hubble observe --verdict drop` frequently

It immediately shows:

- which deny rule
- which allow rule missing
- identity of source/destination

---

## ğŸ›¡ï¸ Recommended Real-World Policy Structure

Large companies follow this structure:

### **1. Global policies â†’ apply to entire cluster**

- DNS allow
- kube-apiserver allow
- namespace isolation
- global deny methods
- external egress restrictions

### **2. Namespace-level policies**

- Microservice segmentation (frontend â†’ backend â†’ db)
- Logging/metrics allows
- App-specific ingress/egress

### **3. Workload-specific policies**

- L7 filtering
- Kafka topic protection
- API path restrictions

This creates a layered, maintainable security model.

---

## ğŸ“ END OF TOPIC

You now understand **how real companies design Cilium policies**, including:

- âœ”ï¸ Zero-trust segmentation patterns
- âœ”ï¸ Cross-namespace isolation
- âœ”ï¸ Internal service communication design
- âœ”ï¸ Internet egress control
- âœ”ï¸ L7 advanced traffic filtering
- âœ”ï¸ Global vs namespace vs workload policies
- âœ”ï¸ Deny/allow layering patterns
- âœ”ï¸ Debugging and operational best practices

With this, you are effectively at **Cilium power-user / architect level**.
