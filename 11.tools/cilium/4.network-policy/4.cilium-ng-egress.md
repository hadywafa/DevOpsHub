# ‚≠ê **Egress Rules in Cilium (Deep, Modern, Complete Mastery)**

üî• _‚ÄúIngress protects what comes **IN**, egress protects what goes **OUT** ‚Äî most engineers overlook egress. You won‚Äôt.‚Äù_

This **topic** is long, deep, practical, and 100% aligned with latest Cilium versions.

---

## üöÄ **What Is Egress in Cilium?**

Egress rules control **which external destinations a pod is allowed to communicate with**.

Example:

```yaml
endpointSelector:
  matchLabels:
    app: backend
```

If ANY egress rule exists under this selector ‚Üí backend pods enter:

### **Egress Enforcement Mode**

Meaning:

```ini
DEFAULT: deny all outbound traffic unless explicitly allowed.
```

This is a major difference from Kubernetes NetworkPolicy (which is allow-all by default).

---

## üéØ The Egress Fields You Must Master

Egress supports these selectors:

| Field           | Meaning                                                           |
| --------------- | ----------------------------------------------------------------- |
| **toEndpoints** | Allow egress to specific pods (identity-based)                    |
| **toEntities**  | Allow egress to built-in groups (world, cluster, host, apiserver) |
| **toServices**  | Allow access to a Kubernetes service (FQDN aware)                 |
| **toCIDR**      | Allow egress to external IP ranges                                |
| **toCIDRSet**   | CIDR + exceptions                                                 |
| **toPorts**     | Restrict to ports/protocols (L4)                                  |
| **rules (L7)**  | Application-aware egress (HTTP, DNS, Kafka, etc.)                 |

Egress is more complex than ingress because:

- Pods usually need DNS
- Pods may need Internet
- Pods talk to external databases
- Pods talk to host or cluster APIs

Egress is where real production complexity appears.

Let‚Äôs break everything down.

---

## üß© `toEndpoints`: Allow Pod ‚Üí Pod Egress

This is identity-based and the most common internal egress rule.

Example:

```yaml
egress:
  - toEndpoints:
      - matchLabels:
          role: cache
```

Meaning:

> The selected pod can talk ONLY to pods with `role=cache`.

Everything else is blocked.

### Namespace-aware version:

```yaml
egress:
  - toEndpoints:
      - matchLabels:
          role: cache
          k8s:io.kubernetes.pod.namespace: prod
```

This prevents accidental cross-namespace leaks.

---

## üåç `toEntities`: Built-in Cilium Identities (Extremely Powerful)

Cilium includes predefined groups:

| Entity             | Meaning                             |
| ------------------ | ----------------------------------- |
| **world**          | Anything outside cluster (Internet) |
| **cluster**        | Any pod inside cluster              |
| **host**           | Node‚Äôs network namespace            |
| **remote-node**    | Other Kubernetes nodes              |
| **kube-apiserver** | Kubernetes API server               |
| **health**         | Cilium health endpoint              |

### Example: Allow backend to access the entire Internet

```yaml
egress:
  - toEntities:
      - world
```

### Example: Allow access only to cluster-internal services

```yaml
egress:
  - toEntities:
      - cluster
```

### Example: Allow access to kube-apiserver (needed for certain agents)

```yaml
egress:
  - toEntities:
      - kube-apiserver
```

---

## üåê `toServices`: Service-Aware Egress (FQDN Matching)

This is Cilium‚Äôs ‚Äúsmart DNS-aware‚Äù egress rule.

Example:

```yaml
egress:
  - toServices:
      - k8sService:
          serviceName: external-api
          namespace: prod
```

Cilium resolves the service ‚Üí clusterIP ‚Üí endpoints ‚Üí identities.
Traffic is allowed based on the actual destination Pods.

---

## üåç `toCIDR`: Allow External IP Ranges

Example: allow access to AWS RDS database:

```yaml
egress:
  - toCIDR:
      - 172.31.0.0/16
```

### Example: allow RDS + block S3:

Use `toCIDRSet`:

```yaml
egress:
  - toCIDRSet:
      - cidr: 172.31.0.0/16
        except:
          - 172.31.20.0/24
```

Cilium uses eBPF instead of iptables ‚Üí very fast CIDR matching.

---

## üîê `toPorts`: Restrict Allowed Ports/Protocols

If you specify:

```yaml
toPorts:
  - ports:
      - port: "3306"
        protocol: TCP
```

Then only port 3306 is allowed to that destination.

Ports can be combined with:

- `toEndpoints`
- `toEntities`
- `toCIDR`

Example:

```yaml
egress:
  - toEntities:
      - world
    toPorts:
      - ports:
          - port: "443"
            protocol: TCP
```

Meaning ‚Üí allow HTTPS to the world, block everything else.

---

## üé≠ L7 Egress Rules (HTTP, DNS, Kafka, etc.)

### HTTP Example: Allow only GET to external API

```yaml
egress:
  - toEntities:
      - world
    toPorts:
      - ports:
          - port: "443"
            protocol: TCP
        rules:
          http:
            - method: GET
              path: "/v1/*"
```

### Kafka Example: Allow egress only to `payments` topic

```yaml
egress:
  - toEndpoints:
      - matchLabels:
          app: kafka
    toPorts:
      - rules:
          kafka:
            - topic: "payments"
              apiKey: produce
```

### DNS Example (very common!)

When egress is enforced, DNS must be allowed:

```yaml
egress:
  - toEndpoints:
      - matchLabels:
          k8s-app: kube-dns
    toPorts:
      - ports:
          - port: "53"
            protocol: UDP
      - rules:
          dns:
            - matchPattern: "*"
```

Without this ‚Üí pods break because they cannot resolve DNS.

---

## üß™ Real Production Example: Secure Outbound Access

Scenario:

- Backend pod should:

  - talk to DB in prod namespace
  - talk to Redis in prod namespace
  - call external payment API using HTTPS only
  - resolve DNS
  - cannot access Internet except payment API

Full Cilium egress policy:

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: backend-egress
  namespace: prod
spec:
  endpointSelector:
    matchLabels:
      app: backend

  egress:
    # 1. Allow DNS
    - toEndpoints:
        - matchLabels:
            k8s-app: kube-dns
      toPorts:
        - ports:
            - port: "53"
              protocol: UDP
          rules:
            dns:
              - matchPattern: "*"

    # 2. Allow DB
    - toEndpoints:
        - matchLabels:
            app: db
            k8s:io.kubernetes.pod.namespace: prod
      toPorts:
        - ports:
            - port: "5432"
              protocol: TCP

    # 3. Allow Redis
    - toEndpoints:
        - matchLabels:
            app: redis
            k8s:io.kubernetes.pod.namespace: prod
      toPorts:
        - ports:
            - port: "6379"
              protocol: TCP

    # 4. Allow HTTPS to external payment API
    - toEntities:
        - world
      toPorts:
        - ports:
            - port: "443"
              protocol: TCP
          rules:
            http:
              - host: "api.stripe.com"
                method: "POST"
                path: "/v1/payments"
```

This is **production-grade microservice egress security**.

---

## üõë Common Egress Pitfalls (You MUST Know These)

### ‚ùó Pitfall 1: Not allowing DNS

- If you define ANY egress rules, DNS is blocked unless explicitly allowed.

### ‚ùó Pitfall 2: `world` means the entire Internet

- Very risky. Prefer controlling via:

  - `toCIDR`
  - L7 rules
  - FQDN rules

### ‚ùó Pitfall 3: Forgetting namespace in identity

- `toEndpoints` matches labels across all namespaces unless you add:

  ```yaml
  k8s:io.kubernetes.pod.namespace: prod
  ```

### ‚ùó Pitfall 4: Mixing pod-to-pod egress and Internet egress

- Always separate policies logically to debug easily.

---

## üî¨ Debugging Egress

### Check policies applied:

```bash
cilium policy get
```

### View blocked outbound:

```bash
hubble observe --verdict drop --direction egress
```

### View successful outbound:

```bash
hubble observe --verdict forwarded --direction egress
```

### Test DNS:

```bash
kubectl exec backend -- nslookup google.com
```

If DNS fails ‚Üí your egress policy is missing DNS rules.

---

## üéì END OF TOPIC

After this, you should feel confident with:

- ‚úîÔ∏è How Cilium enforces egress deny-by-default
- ‚úîÔ∏è How to allow outbound to pods, external IPs, or the Internet
- ‚úîÔ∏è How to use toEndpoints, toEntities, toCIDR, toServices
- ‚úîÔ∏è How to restrict outbound ports
- ‚úîÔ∏è How to apply L7 HTTP, DNS, and Kafka rules
- ‚úîÔ∏è How to enforce namespace-aware outbound
- ‚úîÔ∏è How to debug denied outbound traffic

This puts you ahead of 90% of Kubernetes engineers in real-world networking.
