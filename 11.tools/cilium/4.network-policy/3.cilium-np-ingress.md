# â­ **Ingress Rules in Cilium**

ğŸ”¥ _â€œIngress is where 90% of real Cilium security decisions happen â€” letâ€™s master it fully.â€_

This chapter is long, rich, visual, and fully aligned with the latest Cilium versions.

---

## ğŸš€ What Is â€œIngressâ€ in Cilium?

**Ingress** = Rules controlling **who can send traffic INTO** the pods selected by `endpointSelector`.

Example:

```yaml
endpointSelector:
  matchLabels:
    app: db
```

â†’ This selects all DB pods.

If ANY ingress rule existsâ†’ DB pods enter **ingress enforcement** mode:

```ini
DEFAULT: deny all ingress unless explicitly allowed.
```

This is the core logic.

---

## ğŸ¯ Ingress Rule Structure

Cilium supports these components inside an ingress rule:

```yaml
ingress:
  - fromEndpoints:
      - matchLabels: { ... }

    toPorts:
      - ports: [...]
        rules: { ... }

  - fromEntities: [...]

  - fromCIDR: [...]

  - toPorts: [...]
```

The major fields you must master:

| Ingress Field     | Meaning                                                            |
| ----------------- | ------------------------------------------------------------------ |
| **fromEndpoints** | Allow pods (by label) to access                                    |
| **fromEntities**  | Allow built-in groups like `world`, `host`, `kube-apiserver`, etc. |
| **fromCIDR**      | Allow specific external IP ranges                                  |
| **fromCIDRSet**   | Same as above but with exceptions                                  |
| **toPorts**       | Restrict allowed ports + protocols                                 |
| **L7 rules**      | HTTP, gRPC, Kafka, DNS filtering                                   |

We will break each one down.

---

## ğŸ§© fromEndpoints (MOST IMPORTANT SELECTOR)

This is the main way to allow pod-to-pod traffic.

Example:

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          app: backend
```

Meaning:

> Only pods with label `app=backend` may access the `endpointSelector` pods.

### Namespace-aware version:

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          app: frontend
          k8s:io.kubernetes.pod.namespace: web
```

This is **accurate Cilium usage** (namespace is a label).

### âœ”ï¸ Matching rules:

- Label match uses **subset logic**
- Pod must match _all_ labels inside the selector
- Pod identity includes namespace â†’ cross-namespace filtering works

---

## ğŸŒ fromEntities (Predefined Identities)

Cilium gives you built-in identities to allow system traffic.

| Entity             | Meaning                                  |
| ------------------ | ---------------------------------------- |
| **cluster**        | Traffic from anywhere inside the cluster |
| **world**          | Anything outside the cluster (Internet)  |
| **host**           | Node itself (host network)               |
| **remote-node**    | Other Kubernetes nodes                   |
| **kube-apiserver** | Kubernetes API server                    |
| **health**         | Cilium health endpoint                   |

Example: allow host â†’ pod traffic

```yaml
ingress:
  - fromEntities:
      - host
```

Example: allow API server to access your webhook

```yaml
ingress:
  - fromEntities:
      - kube-apiserver
```

Example: allow ALL cluster pods:

```yaml
ingress:
  - fromEntities:
      - cluster
```

This is equivalent to "allow all pods in all namespaces."

---

## ğŸ›°ï¸ fromCIDR / fromCIDRSet (External IP Ranges)

Used to allow external IPs via NodePort, Ingress, L4 LB, etc.

### Example: allow only AWS ALB (public IP range)

```yaml
ingress:
  - fromCIDR:
      - 35.180.0.0/16
```

### Example: allow office IPs except guest Wi-Fi

```yaml
ingress:
  - fromCIDRSet:
      - cidr: 192.168.0.0/16
        except:
          - 192.168.50.0/24
```

CIDR rules are extremely useful for hybrid deployments or transitions from legacy firewalls.

---

## ğŸ”Œ toPorts (L4 Restriction Inside Ingress)

By default, if you define only:

```yaml
fromEndpoints:
```

â†’ All ports are allowed.

To restrict ports:

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          app: backend
    toPorts:
      - ports:
          - port: "5432"
            protocol: TCP
```

Now backend can only reach DB on port 5432 (PostgreSQL).

Anything else â†’ denied.

---

## ğŸ­ L7 Policies Inside Ingress (HTTP, gRPC, Kafka, DNS)

Cilium supports application-aware rules via Envoy/eBPF.

### Example: allow only POST /login and GET /profile

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          app: frontend
    toPorts:
      - ports:
          - port: "80"
            protocol: TCP
        rules:
          http:
            - method: "POST"
              path: "/login"
            - method: "GET"
              path: "/profile"
```

This is extremely powerful.

### Example: Kafka topic restriction

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          role: producer
    toPorts:
      - rules:
          kafka:
            - topic: "payments"
              apiKey: produce
```

### Example: DNS restriction (common in egress, but ingress also possible)

```yaml
rules:
  dns:
    - matchPattern: "*.internal.local"
```

---

## ğŸ§ª Complete Ingress Example

Scenario:

- Namespace `prod`
- Pods:

  - `frontend` (role=frontend)
  - `backend` (role=backend)
  - `db` (role=db)

- Goal:

  - frontend â†’ backend (HTTP GET/POST only)
  - backend â†’ db (only port 3306)
  - block everything else

### Policy 1 â€” backend ingress (only from frontend, limited API paths)

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: backend-ingress
  namespace: prod
spec:
  endpointSelector:
    matchLabels:
      role: backend

  ingress:
    - fromEndpoints:
        - matchLabels:
            role: frontend
            k8s:io.kubernetes.pod.namespace: prod
      toPorts:
        - ports:
            - port: "8080"
              protocol: TCP
          rules:
            http:
              - method: GET
                path: "/api/*"
              - method: POST
                path: "/api/*"
```

### Policy 2 â€” db ingress (only backend â†’ db:3306)

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: db-ingress
  namespace: prod
spec:
  endpointSelector:
    matchLabels:
      role: db

  ingress:
    - fromEndpoints:
        - matchLabels:
            role: backend
      toPorts:
        - ports:
            - port: "3306"
              protocol: TCP
```

Result:

- ğŸŸ¢ frontend â†’ backend â†’ db
- âŒ frontend â†’ db (blocked)
- âŒ anything â†’ db except backend:3306
- âŒ anything â†’ backend except frontend on HTTP paths
- âœ”ï¸ clean microservice segmentation

---

## ğŸ§  Important Ingress Pitfalls

### â— **Pitfall 1: Policy lives in the namespace of the protected pods**

Cilium policies are namespaced.

If you want to protect db pods in namespace `prod`:

```yaml
metadata:
  namespace: prod
```

If you put it in another namespace â†’ it does nothing.

---

### â— Pitfall 2: You must match namespace explicitly when needed

Example wrong:

```yaml
fromEndpoints:
  - matchLabels:
      role: backend
```

This matches backend in ANY namespace.

If you want only namespace=prod:

```yaml
matchLabels:
  role: backend
  k8s:io.kubernetes.pod.namespace: prod
```

---

### â— Pitfall 3: If any ingress rule exists â†’ ingress becomes default-deny

No matter how simple the rule is.

---

### â— Pitfall 4: Using `world` incorrectly

`fromEntities: [ world ]` means:

> Allow ANY traffic from outside cluster
> (NodePort / LoadBalancer / Ingress LB)

This is open-to-world.

Use carefully.

---

## ğŸ”¬ Debugging Ingress Behavior

### Check policies applied:

```bash
cilium policy get
```

### See endpoint enforcement & identity:

```bash
cilium endpoint list
```

### Watch dropped traffic:

```bash
hubble observe --verdict drop
```

### Trace HTTP paths:

```bash
hubble observe --protocol http
```

### View L7 decisions:

```bash
hubble observe --verdict denied --protocol http
```

---

## ğŸ“ END OF TOPIC

- âœ”ï¸ Ingress = â€œwho is allowed to reach my pod?â€
- âœ”ï¸ `fromEndpoints` = pod identity selector
- âœ”ï¸ Namespace matching = via `k8s:io.kubernetes.pod.namespace`
- âœ”ï¸ Entities = allow host/world/APIServer/etc
- âœ”ï¸ CIDR filtering = external IPs
- âœ”ï¸ L4/L7 filtering = ports, HTTP, Kafka, DNS, gRPC
- âœ”ï¸ Ingress rules automatically turn on ingress deny-mode
- âœ”ï¸ You can confidently design microservice segmentation
