# â­ **EndpointSelectors, Identity & Namespace-Aware Matching in Cilium**

Everything in Cilium policy enforcement comes down to **two things**:

1. **Security Identity**
2. **Label Selectors**

Once these two click, writing ANY Cilium policy becomes easy.

Letâ€™s master them.

---

## ğŸ§  Cilium Security Identity (The Brain Behind Every Decision)

Cilium does NOT enforce traffic rules based on IPs. IPs change constantly.

Instead, Cilium assigns each pod an **identity** created from the podâ€™s labels.

### âœ”ï¸ Identity = Hash of a podâ€™s Kubernetes labels (plus namespace label)

Example pod:

```yaml
labels:
  app: backend
  role: api
  env: prod
```

Cilium computes â†’ Identity ID (e.g., `4342`), used for all decisions.

### Why this matters:

- â˜‘ï¸ Pod can restart â†’ same identity
- â˜‘ï¸ Pod IP changes â†’ still the same identity
- â˜‘ï¸ Scaling up/down â†’ consistent identity
- â˜‘ï¸ eBPF policy lookup uses identity, not IP â†’ extremely fast

Everything you do in a Cilium policy is ultimately matching identities.

---

## ğŸ¯ The Three Core Selectors (Modern Cilium)

Cilium policies revolve around **three selectors**:

| Selector             | Where It Applies      | What It Does                                                 |
| -------------------- | --------------------- | ------------------------------------------------------------ |
| **endpointSelector** | Target pods           | Selects the pods this policy is enforced on                  |
| **fromEndpoints**    | Ingress (sources)     | Selects which pods are allowed to send traffic _into_ target |
| **toEndpoints**      | Egress (destinations) | Selects which pods the target pods can talk to               |

All of these operate on **labels**, not namespaces by default â€” weâ€™ll cover namespace selection soon.

### ğŸ‘‰ The important idea:

> **endpointSelector chooses the protected workload.  
> fromEndpoints/toEndpoints choose who can talk to it.**

---

## ğŸ§© `endpointSelector`: Selecting the Pod(s) Under Protection

This is the most important field in Cilium.

Example:

```yaml
endpointSelector:
  matchLabels:
    role: db
```

Meaning:

- â€œThis policy applies to all pods that have `role=db`.â€

Once a pod is selected:

### ğŸ” That pod enters **policy-enforced mode** for the directions defined in the spec.

- If ingress rules exist â†’ ingress becomes default-deny
- If egress rules exist â†’ egress becomes default-deny

**Even one rule is enough** to turn on deny mode.

This is foundational.

---

## ğŸŒ Namespace-Aware Pod Selection (The Modern Way)

This is where many people get confused.
Cilium does **NOT** use `namespaceSelector` like Kubernetes NetworkPolicy.

It uses something much more powerful.

### âœ”ï¸ Cilium injects a namespace label into every podâ€™s identity:

```ini
k8s:io.kubernetes.pod.namespace: <namespace-name>
```

This means:

### **Namespace is just another label**

â†’ So you can select namespace simply by matching that label.

### Example: match pods in namespace `prod`

```yaml
matchLabels:
  k8s:io.kubernetes.pod.namespace: prod
```

This selector works in:

- `endpointSelector`
- `fromEndpoints`
- `toEndpoints`

### âœ”ï¸ This is fully supported, stable, and recommended.

---

## ğŸ§ª Real Example: Cross-Namespace Access Policy

Scenario:
Allow frontend (namespace `web`) â†’ backend (namespace `prod`).

Policy (in namespace `prod`):

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-web-to-backend
  namespace: prod
spec:
  endpointSelector:
    matchLabels:
      app: backend

  ingress:
    - fromEndpoints:
        - matchLabels:
            app: frontend
            k8s:io.kubernetes.pod.namespace: web
```

Meaning:

- This policy **protects backend pods** in `prod`.
- Only pods that match:

  ```ini
  app: frontend
  k8s:io.kubernetes.pod.namespace: web
  ```

  can access backend.

All other namespaces (even if they have a pod named `frontend`) â†’ **DENIED**.

This is how cross-namespace control works in modern Cilium.

---

## ğŸ” `fromEndpoints`: Selecting Allowed _Sources_ (Ingress)

This selector controls **who is allowed to send traffic INTO the endpointSelector pods**.

Example:

```yaml
ingress:
  - fromEndpoints:
      - matchLabels:
          role: backend
```

Meaning:

- Only pods whose identity includes `role=backend` may access.

### Key behavior:

- **If frontend does not match `role=backend` â†’ it will be blocked.**
- This happens even if frontend is in the same namespace.
- Identity matching is exact: `role=backend` â‰  `role=frontend`.

---

## ğŸ”„ `toEndpoints`: Selecting Allowed _Destinations_ (Egress)

This selector defines which pods the selected workload **may access**.

Example:

```yaml
egress:
  - toEndpoints:
      - matchLabels:
          role: cache
```

Meaning:

- The protected pod can only talk to pods with `role=cache`.

Everything else â†’ **default-deny**.

---

## âš ï¸ Deprecated Selectors: `fromRequires` and `toRequires`

Older Cilium versions included:

- `fromRequires`
- `toRequires`

These are now:

- âŒ Deprecated
- âŒ Removed
- âŒ Should NOT be used

Modern policies rely only on:

### âœ”ï¸ `endpointSelector`

### âœ”ï¸ `fromEndpoints`

### âœ”ï¸ `toEndpoints`

### âœ”ï¸ Entities (covered later)

This keeps policies cleaner and simpler.

---

## ğŸ“˜ Node, Host, External Sources

Cilium includes built-in source and destination identifiers:

- `cluster`
- `world`
- `host`
- `kube-apiserver`
- `health`

Example:

```yaml
ingress:
  - fromEntities:
      - kube-apiserver
```

This allows cluster control-plane traffic to your pod.

> We dive deep into entities in later topics.

---

## ğŸ§  Identity Matching Rules (Very Important!)

### âœ”ï¸ Label matching is **subset-based**, not exact match.

Policy:

```yaml
matchLabels:
  role: backend
```

Matches pod:

```ini
role: backend
env: prod
team: payments
```

Because all required labels exist.

### âŒ These do NOT match:

- Different label value (`role: frontend`)
- Missing label (`role` not present)
- Wrong namespace label

### Namespace matching example:

```yaml
matchLabels:
  k8s:io.kubernetes.pod.namespace: prod
```

Matches pods in namespace prod **only**.

---

## ğŸ§© Putting It Together: Complete Traffic Decision Logic

When a request comes into a pod, Cilium:

### **STEP 1 â€” Does destination pod match endpointSelector?**

No â†’ policy ignored
Yes â†’ policy enforced

### **STEP 2 â€” For ingress: does source identity match any fromEndpoints?**

Yes â†’ allow
No â†’ drop

### **STEP 3 â€” For egress: does destination identity match any toEndpoints?**

Yes â†’ allow
No â†’ drop

### **Namespace matching participates naturally** because namespace is inside identity labels.

---

## ğŸ”¬ Debugging Selectors in Real Clusters

Useful commands:

### Show pod identities

```bash
cilium identity list
```

### Show full identity of a pod (labels included)

```bash
cilium endpoint list
```

### Check how Cilium rendered the policy

```bash
cilium policy get
```

### Observe real drops

```bash
hubble observe --verdict drop
```

### Observe allowed traffic

```bash
hubble observe --verdict forwarded
```

With these, you can _always_ see why a policy is (or isnâ€™t) matching.

---

## ğŸ“ END OF TOPIC

After this chapter you should confidently understand:

### âœ”ï¸ Identity-based policy enforcement

### âœ”ï¸ How `endpointSelector` defines what pod is protected

### âœ”ï¸ How `fromEndpoints` & `toEndpoints` match source/destination

### âœ”ï¸ How **namespace** becomes a normal label in identity

### âœ”ï¸ Why deprecated fields must be avoided

### âœ”ï¸ How Cilium makes decisions at ingress/egress

### âœ”ï¸ How to debug label/namespace matching in real clusters

Understanding this makes you ready for **Topic 3 â€” Ingress Policy Masterclass**, which covers:

- fromEndpoints
- fromEntities
- fromCIDR
- L4/L7 ingress filtering
- example architectures
- real cluster patterns
