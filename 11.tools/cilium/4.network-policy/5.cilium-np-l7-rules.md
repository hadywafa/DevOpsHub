# ‚≠ê **L7 Policies in Cilium (HTTP, gRPC, Kafka, DNS, TLS)**

üî• _‚ÄúThis is where Cilium becomes more than a firewall ‚Äî it becomes an application-aware security enforcer.‚Äù_

This is a long, rich, practical topic.
By the end of this chapter, you will understand **EVERY** L7 feature Cilium supports and how traffic is actually processed under the hood.

---

## üöÄ What Are L7 Policies in Cilium?

Cilium is not just L3/L4 (IP + port).
It can inspect **application-layer traffic**:

- HTTP
- gRPC
- Kafka
- DNS
- Generic L7 filters
- TLS-aware features via SNI + Host matching

This happens via:

- eBPF ‚Üí for redirection
- Envoy proxy ‚Üí for deep L7 parsing
- or eBPF-based L7 inspection (newer versions)

### L7 Policies allow you to:

‚úîÔ∏è Restrict specific HTTP paths
‚úîÔ∏è Restrict HTTP methods
‚úîÔ∏è Allow only Kafka topics
‚úîÔ∏è Restrict DNS queries
‚úîÔ∏è Allow only specific external hosts
‚úîÔ∏è Create strict API boundaries

---

## üß† How Cilium Processes L7 Traffic Internally

### Step-by-step flow:

1. Packet arrives at pod
2. Cilium eBPF logic checks:

   - Source identity
   - Destination identity
   - L3/L4 rules

3. If L7 rules exist ‚Üí traffic is redirected to **Envoy proxy**
4. Envoy inspects:

   - HTTP method
   - HTTP path
   - HTTP host
   - Kafka topic
   - DNS domain

5. Decision:

   - Allow
   - Deny
   - Log (via Hubble)

This is **NOT** iptables ‚Üí it is extremely fast and accurate.

---

## üé≠ L7 HTTP Policy (The Most Common & Powerful)

### Syntax:

```yaml
rules:
  http:
    - method: GET
      path: /api/users
```

### Full Example

Restrict incoming traffic to only:

- GET `/api/*`
- POST `/login`

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: backend-http-l7
  namespace: prod
spec:
  endpointSelector:
    matchLabels:
      app: backend

  ingress:
    - fromEndpoints:
        - matchLabels:
            app: frontend
      toPorts:
        - ports:
            - port: "8080"
              protocol: TCP
          rules:
            http:
              - method: GET
                path: "/api/*"
              - method: POST
                path: "/login"
```

### This means:

- Frontend ‚Üí backend only on 8080
- Only specific HTTP methods allowed
- Only specific paths allowed
- Backend cannot be abused by random HTTP traffic

### L7 HTTP supports matching:

| Field     | Description                                   |
| --------- | --------------------------------------------- |
| `method`  | GET, POST, DELETE, PUT, PATCH                 |
| `path`    | Exact (`/login`) or wildcard (`/api/*`)       |
| `host`    | Match Host header (domain-based restrictions) |
| `headers` | Advanced header-based filtering               |

### Example: Allow only internal domain calls

```yaml
rules:
  http:
    - host: "internal.mycorp.com"
```

---

## üõ∞Ô∏è L7 gRPC Policy

gRPC is HTTP/2 based, so Cilium supports method-level gRPC filtering.

### Example:

```yaml
rules:
  http:
    - method: "POST"
      path: "/mypackage.MyService/GetUser"
```

Yes ‚Üí gRPC methods appear as HTTP/2 paths.

---

## üßµ L7 Kafka Policies (Extremely Powerful)

Kafka security is notoriously difficult.
Cilium solves it elegantly.

### Example: allow only producing to `payments` topic

```yaml
rules:
  kafka:
    - topic: "payments"
      apiKey: produce
```

### Kafka API keys you can match:

- `produce`
- `fetch`
- `createTopics`
- `deleteTopics`
- `listOffsets`
- etc.

### Example: allow consumer on one topic only

```yaml
rules:
  kafka:
    - topic: "orders"
      apiKey: fetch
```

This is powerful because **identity-based + topic-level security** is extremely rare in Kubernetes worlds.

---

## üåê L7 DNS Policies (Critical for Egress Security)

DNS egress is required for almost ANY app to function.

When you apply ANY egress rule ‚Üí DNS is blocked unless explicitly allowed.

### Allow DNS (L7-aware)

```yaml
egress:
  - toEndpoints:
      - matchLabels:
          k8s-app: kube-dns
    toPorts:
      - ports:
          - port: "53"
            protocol: UDP
        rules:
          dns:
            - matchPattern: "*"
```

### Restrict DNS to specific domains

```yaml
rules:
  dns:
    - matchPattern: "*.mycorp.com"
```

### Example: Allow only GitHub + Stripe DNS queries

```yaml
rules:
  dns:
    - matchPattern: "*.github.com"
    - matchPattern: "*.stripe.com"
```

This is the foundation for **FQDN-aware egress**.

---

## üîê SNI & Host-Based Egress (TLS L7 Filtering)

You can restrict HTTPS egress using L7 rules + Cilium‚Äôs HTTP host matching.

Example: allow HTTPS only to `api.stripe.com`.

```yaml
egress:
  - toEntities:
      - world
    toPorts:
      - ports:
          - port: "443"
            protocol: TCP
        rules:
          http:
            - host: "api.stripe.com"
              method: POST
              path: "/v1/payments"
```

This matches HTTP Host header / TLS SNI.

---

## üõ†Ô∏è FULL REAL-WORLD L7 Example (Complete Microservice Security)

### Scenario:

- frontend ‚Üí backend only on GET /products
- backend ‚Üí db only port 5432
- backend ‚Üí stripe only on HTTPS POST /v1/payments
- DNS restricted to common domains
- Everything else is blocked

### FULL POLICY:

```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: complete-microservice-l7
  namespace: prod

spec:
  endpointSelector:
    matchLabels:
      app: backend

  ingress:
    - fromEndpoints:
        - matchLabels:
            app: frontend
            k8s:io.kubernetes.pod.namespace: prod
      toPorts:
        - ports:
            - port: "8080"
          rules:
            http:
              - method: GET
                path: "/products"

  egress:
    # DB access
    - toEndpoints:
        - matchLabels:
            app: db
            k8s:io.kubernetes.pod.namespace: prod
      toPorts:
        - ports:
            - port: "5432"

    # DNS access
    - toEndpoints:
        - matchLabels:
            k8s-app: kube-dns
      toPorts:
        - ports:
            - port: "53"
              protocol: UDP
          rules:
            dns:
              - matchPattern: "*"

    # Stripe API access (HTTPS)
    - toEntities:
        - world
      toPorts:
        - ports:
            - port: "443"
              protocol: TCP
        rules:
          http:
            - host: "api.stripe.com"
              path: "/v1/payments"
              method: POST
```

This enforces **true zero-trust microservice architecture**.

---

## üß® L7 Pitfalls (Very Important!)

### ‚ùó Pitfall 1 ‚Äî Missing DNS = all outbound breaks

- Solution: always add DNS rules when using egress NP.

### ‚ùó Pitfall 2 ‚Äî L7 rules do NOT apply without `toPorts`

- You MUST specify ports:

  ```yaml
  toPorts:
    - ports:
        - port: ‚Äú443‚Äù
  ```

### ‚ùó Pitfall 3 ‚Äî L7 policies only work on TCP-based protocols

- (No L7 for raw UDP except DNS)

### ‚ùó Pitfall 4 ‚Äî L7 causes traffic through Envoy proxy

- This introduces:

  - Minimal latency
  - Possible debugging complexity

- But is extremely powerful.

### ‚ùó Pitfall 5 ‚Äî Wildcard hostname matching must be correct

- `*.amazonaws.com` is different from `*.amazonaws.com.`
- DNS dot at the end matters.

---

## üî¨ Debugging L7 Policies

### Watch L7 decisions:

```bash
hubble observe --protocol http
```

### Watch L7 denies:

```bash
hubble observe --verdict denied
```

### Identify which rule blocked traffic:

```bash
hubble observe --trace
```

### Live view (Hubble UI):

```ini
hubble-ui
```

You will see:

- HTTP requests
- Kafka topics
- DNS queries
- Allow/deny decisions
- Identity of source/destination pods

---

## üéì END OF TOPIC

- ‚úîÔ∏è How L7 traffic is processed in Cilium
- ‚úîÔ∏è How to enforce HTTP, gRPC, Kafka, DNS rules
- ‚úîÔ∏è How SNI/Host matching works
- ‚úîÔ∏è How to enforce strict zero-trust architecture
- ‚úîÔ∏è How to debug L7 policies via Hubble
- ‚úîÔ∏è How to avoid common L7 pitfalls

You now understand the MOST advanced part of Cilium.
