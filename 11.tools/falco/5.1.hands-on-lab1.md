# ðŸ”¬ **Lab 1 â€” Detecting `kubectl exec` in a Pod**

This detection covers:

- Interactive shell spawned (`bash`, `sh`, etc.)
- `kubectl exec -it`
- Reverse shell attempts
- SSH-like behavior inside containers

This lab uses **default Falco rules**, plus Iâ€™ll show how to make your own.

---

## ðŸŸ¦ **Step 1 â€” Deploy a Test Pod**

We will use an Alpine pod:

```bash
kubectl run test-pod --image=alpine -it -- sh
```

This will drop you into `/bin/sh`.

---

## ðŸŸ© **Step 2 â€” Confirm Falco Is Running & Monitoring**

Check Falco logs:

```bash
kubectl logs -n falco -l app=falco | head
```

You should see something like:

```ini
Falco version: ...
Successfully opened /dev/falco0
Using system-probe (eBPF) driver
Rules loaded successfully
```

---

## ðŸŸ§ **Step 3 â€” Run a Shell (The Attack)**

Inside the test container, simply run:

```sh
sh
```

Or:

```bash
kubectl exec -it test-pod -- bash
```

---

## ðŸŸ¥ **Step 4 â€” Watch Falco Detect the Attack**

Now in another terminal, watch Falco logs:

```bash
kubectl logs -n falco -l app=falco -f
```

Falco should generate something like:

```ini
17:21:14.123456 Warning Falco: Terminal shell in container (user=root container=123abc pod=test-pod ns=default)
```

ðŸ”¥ **This confirms Falcoâ€™s syscall detection is working.**

---

## ðŸŸ¦ **Why Did This Rule Trigger? (Understanding the Logic)**

Falco ships with this default rule:

```yaml
- rule: Terminal shell in container
  desc: Detect a shell spawned inside a container with a TTY
  condition: >
    spawned_process and
    container.id != host and
    proc.name in (bash, zsh, sh, csh) and
    tty
  output: >
    A shell was spawned inside a container (user=%user.name command=%proc.cmdline container_id=%container.id image=%container.image.repository)
  priority: WARNING
```

### This triggered because:

- `proc.name = sh`
- `container.id != host` (it's inside a pod)
- `tty = true` (because you used `-it`)
- `spawned_process` macro matches `execve()`

Falco correctly identified interactive shell access.

---

## ðŸŸ© **Step 5 â€” Writing Your OWN Version of This Rule**

Letâ€™s create a cleaner custom rule with better output:

```yaml
- rule: Detect Interactive Shell
  desc: Someone executed an interactive shell inside a container
  condition: >
    evt.type = execve and
    container.id != host and
    proc.name in (bash, sh, zsh, ash)
  output: >
    [ALERT] Interactive shell detected in pod=%k8s.pod.name ns=%k8s.ns.name user=%user.name cmd=%proc.cmdline
  priority: WARNING
  tags: [k8s, container, exec]
```

Add this rule using a Helm customRules section:

```yaml
customRules:
  detect_shell.yaml: |
    (paste rule here)
```

Then apply:

```bash
helm upgrade falco falcosecurity/falco -f values.yaml
```

---

## ðŸŸ¥ **Step 6 â€” Debugging If the Rule Does NOT Trigger**

If your rule didn't fire, here are the common reasons:

### 1ï¸âƒ£ Your pod uses `sh` not `bash`

Add `sh` to the rule:

```yaml
proc.name in (bash, sh)
```

### 2ï¸âƒ£ Rule file was not loaded

Check:

```bash
falco --list | grep Detect Interactive Shell
```

If missing â†’ your ConfigMap or mount is wrong.

### 3ï¸âƒ£ eBPF driver not capturing events

Check logs:

```bash
kubectl logs -n falco -l app=falco | grep eBPF
```

Look for:

```ini
Connected to eBPF probe
```

### 4ï¸âƒ£ You used a non-interactive shell

Try:

```bash
kubectl exec -it ...
```

---

## ðŸŸ¦ **Step 7 â€” Bonus: Detect WHO executed the shell**

Add Kubernetes audit logging to see the user/operator:

```yaml
output: >
  Shell in container (pod=%k8s.pod.name ns=%k8s.ns.name exec_by=%ka.audit.user.name)
```

If audit logs are enabled, this becomes extremely useful for attributing attacks.

---

## ðŸŽ¯ **Lab 1 Outcome**

You now know how to:

âœ” Trigger a real Kubernetes runtime event
âœ” Watch Falco detect it
âœ” Understand which rule fired and why
âœ” Write your own version of the rule
âœ” Debug when rules donâ€™t trigger
âœ” Add meaningful Kubernetes context to alerts

This is exactly how SREs and DevSecOps engineers run Falco in production clusters.

---

## ðŸŸ¦ **Next Labs Available (Choose your next attack simulation)**

### **Lab 2 â€” Detect Privileged Pod Creation (K8s audit event)**

Attackers escalate privileges by creating privileged containers.

### **Lab 3 â€” Detect Reverse Shell inside containers**

Critical for detecting lateral movement & ransomware.

### **Lab 4 â€” Detect Crypto Miner Deployment**

Detect unauthorized CPU-intensive workloads.

### **Lab 5 â€” Detect Container Escape Attempt (setns, mount abuse)**

This is high-severity runtime detection.
