# ğŸ‘€ **How Falco Really Works**

## ğŸŸª **The Falco Event Pipeline (High-Level Flow)**

Hereâ€™s the real sequence inside every worker node in your cluster:

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
<img src="https://falco.org/img/falco-schema.svg" alt="istio installation" style="width: 100%">
</div>

---

> ğŸ§  Key idea:
>
> Falco does **not** run inside pods.  
> It runs on **each node**, monitoring the entire kernel.

---

## ğŸŸ¥ **How Falco Captures Events (Syscalls & eBPF)**

This is the heart of Falco.

When anything happens inside a Linux container:

- A process starts â†’ `execve()`
- A file is opened â†’ `open()`
- A namespace is changed â†’ `setns()`
- A network connection opens â†’ `connect()`
- A privilege changes â†’ `chmod()`, `capset()`

Falco **hooks into the kernel** and gets a copy of the syscall event **before it is executed**.

## ğŸ›ï¸ The 3 Falco Driver Types:

### 1ï¸âƒ£ eBPF Probe (Recommended)

- Safe, modern, cloud-friendly
- Zero kernel module compilation
- Works well with EKS, GKE, AKS
- Used by most enterprises

### 2ï¸âƒ£ Kernel Module (Legacy but powerful)

- Loads a custom kernel module
- highest observability but harder operationally
- Not recommended for managed k8s

### 3ï¸âƒ£ Userspace Instrumentation

- Lowest visibility
- Rarely used

---

## ğŸ“ **How Falco Interprets Events (Enrichment Process)**

Raw syscalls are not enough.

Falco **enriches** data with:

### âœ” Kubernetes Metadata

Falco maps syscalls â†’ container â†’ pod â†’ namespace â†’ user â†’ request

For example:

Syscall:

```ini
execve("/bin/bash")
```

Falco enriches:

```ini
pod=payments-api-7c3fd
namespace=production
container=image:myapp:v2
k8s.user=developer1
```

### âœ” Container Runtime Metadata

Falco integrates with:

- containerd
- CRI-O
- Docker (legacy)

It maps container IDs to:

- image repository
- image tag
- running processes

### âœ” File & Network Metadata

Including:

- file names
- ports
- IPs
- protocols

---

## ğŸ§  **Falco Rule Engine (The Brain)**

Once Falco receives an enriched event, it must evaluate matching rules.

### ğŸ” Step-by-step inside the rule engine:

1. **Event arrives** (e.g., `execve()` syscall)
2. Falco loads macros, lists, and rules
3. Falco checks if event satisfies rule conditions
4. If yes â†’ generate alert
5. If not â†’ skip to next rule

Falco Engine evaluates **thousands of events per second** with almost **zero performance impact** due to optimized filtering.

---

## â˜¸ï¸ **Falco on Kubernetes (DaemonSet Operation)**

Falco is deployed as a **DaemonSet**, meaning:

- **One Falco pod per node**
- Each Falco instance monitors only its own node
- Events never leave the node unless Falco forwards them

**Why DaemonSet?**

Because syscalls are **node-level**, not pod-level.

Falco pod runs privileged (for kernel access), but safe.

---

## ğŸ“ƒ **Ingesting Kubernetes Audit Logs (K8s API Security)**

Falco can monitor:

### âœ” Syscalls (runtime events)

â†’ From eBPF driver

### âœ” Kubernetes API Requests (audit events)

â†’ From kube-apiserver audit log stream

Examples:

- `kubectl exec`
- `kubectl create deployment`
- Someone modifying RBAC roles
- Someone creating privileged pods
- Someone deleting secrets

Falco rules can say things like:

```yaml
ka.audit.verb = delete and ka.audit.object = secrets
```

This means:

ğŸ”¥ **Falco sees both Linux + Kubernetes behavior.**

---

## ğŸ”” **Falco Output Layer**

When a rule triggers:

â†’ Falco emits an alert
â†’ Output can go to:

- File
- Stdout
- Syslog
- gRPC

Butâ€¦

---

## ğŸ“Š **Falco Sidekick (The Router of Alerts)**

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
<img src="https://falco.org/img/falcosidekick-ui-1.png" alt="istio installation" style="width: 100%">
</div>

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
<img src="https://repository-images.githubusercontent.com/336373988/751ea2c4-0dd7-48e8-84c0-06d9f0426493" alt="istio installation" style="width: 100%">
</div>

Falco Sidekick receives alerts and forwards them to:

| Destination                | Use Case                |
| -------------------------- | ----------------------- |
| **Slack**                  | Real-time DevOps alerts |
| **Teams/Discord**          | Incident notification   |
| **Elasticsearch / Kibana** | Search & dashboards     |
| **Loki / Grafana**         | Observability           |
| **AWS SNS/SQS**            | Cloud-native alerting   |
| **Kafka**                  | SIEM ingestion          |
| **Prometheus metrics**     | AlertManager triggers   |

Sidekick UI provides:

- visual dashboards
- filtering
- rule-by-rule overview

---

## ğŸš€ **Performance Considerations**

- âœ” eBPF uses ring buffers â†’ extremely fast
- âœ” Falco drops noisy events early
- âœ” Rules are optimized to avoid expensive matches
- âœ” Does NOT slow down your cluster
- âœ” Lightweight compared to full security suites

---

> Runtime event volume in production clusters can be massive, but Falco filters **at kernel level**, not at user space â†’ minimal overhead.
