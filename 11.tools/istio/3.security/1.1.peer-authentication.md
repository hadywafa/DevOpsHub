# ğŸ›¡ï¸ Istio Peer Authentication

(â€œmTLS Security Between Services â€” the real Zero Trust engineâ€)

Peer Authentication is the **Istio feature that controls how services authenticate to each other using mTLS**.

Think of it like this:

> **Peer Authentication = how workloads prove who they are when talking to each other.**  
> It defines **whether traffic between pods is plaintext, optional mTLS, or STRICT mTLS**.

It is a **mesh-wide or namespace-wide or workload-specific** policy.

---

## ğŸ§  Why do we need Peer Authentication?

In a microservices cluster without Istio:

- Services talk **unencrypted**
- Clients can **spoof** identity
- Anyone can connect to anything
- No TLS, no certificates, no identity verification

This is NOT Zero Trust ğŸ˜…

Istio Peer Authentication fixes this by:

- âœ”ï¸ Enforcing mTLS
- âœ”ï¸ Doing certificate-based identity
- âœ”ï¸ Verifying the calling workload
- âœ”ï¸ Securing traffic _inside_ the cluster
- âœ”ï¸ Enabling Zero Trust communication

---

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
<img src="image/1764502964008.png" alt="istio installation" style="width: 80%">
</div>

## ğŸ›ï¸ How Istio mTLS Works (Simple Mental Model)

Istio injects (sidecar mode) or uses ztunnel (ambient mode) to do:

1. **Issue certificates** to each workload
2. **Encrypt traffic** between workloads
3. **Verify identity** using SPIFFE IDs
4. **Apply PeerAuthentication policy**

Traffic flow (sidecar mode):

```ini
App A â†’ Envoy A â†’ mTLS â†’ Envoy B â†’ App B
```

Traffic flow (ambient mode):

```ini
Pod A â†’ ztunnel â†’ mTLS â†’ ztunnel â†’ Pod B
```

---

## ğŸ”® Peer Authentication Settings

A `PeerAuthentication` resource supports 3 modes:

### ğŸ”“ **1. PERMISSIVE**

- Accept both plaintext _and_ mTLS
- Useful during migration
- Allows rolling upgrades
- Not secure enough for production

### ğŸ” **2. STRICT**

- Require mTLS for all inbound connections
- Drops plaintext
- Recommended for Zero Trust
- Most secure

### ğŸ”„ **3. DISABLE**

- No mTLS
- Plaintext allowed
- Not recommended, but sometimes needed (legacy apps)

---

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
<img src="image/1764503004501.png" alt="istio installation" style="width: 80%">
</div>

## ğŸ“¦ Where can Peer Authentication be applied?

**3 levels**:

| Level                 | Applies To                      | Use Case                 |
| --------------------- | ------------------------------- | ------------------------ |
| **Mesh-wide**         | Entire mesh                     | Default security posture |
| **Namespace-wide**    | All workloads in that namespace | Isolating workloads      |
| **Workload-specific** | A specific Deployment/Pod       | Fine-grained policies    |

Priority (highest wins):

> Workload > Namespace > Mesh

---

## ğŸ§© CRD structure

Here is the structure:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: <policy-name>
  namespace: <ns>
spec:
  mtls:
    mode: STRICT | PERMISSIVE | DISABLE | UNSET
  selector:
    matchLabels:
      app: my-app
```

---

## ğŸ§ª How to Implement Peer Authentication

Weâ€™ll cover both:

- âœ”ï¸ Sidecar mode
- âœ”ï¸ Ambient mode

Because the implementation is slightly different in where traffic gets intercepted, but Peer Auth CRDs are the same.

---

### ğŸ **A. Mesh-Wide Peer Authentication (affects everything)**

This policy usually lives in the **istio-system** namespace.

Make _all traffic in the mesh_ STRICT mTLS:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
```

Apply:

```bash
kubectl apply -f mesh-peerauth.yaml
```

This means:

- All workloads MUST receive mTLS traffic
- Any HTTP/plaintext will get **rejected**

---

### ğŸŠ **B. Namespace-Level Peer Authentication**

Example: secure all workloads in namespace `payments`:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: namespace-policy
  namespace: payments
spec:
  mtls:
    mode: STRICT
```

Apply:

```bash
kubectl apply -f ns-peerauth.yaml
```

Everything in `payments` namespace now requires mTLS.

---

### ğŸ‰ **C. Workload-Level Peer Authentication**

Secure only the `checkout` service:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: checkout-strict
  namespace: retail
spec:
  selector:
    matchLabels:
      app: checkout
  mtls:
    mode: STRICT
```

Now:

- Only `app=checkout` strictly requires mTLS
- Other workloads in `retail` namespace donâ€™t

---

## ğŸ¯ How to fix mtls for non-compliment namespace

### Sidecar mode

```bash
kubectl labels namespace <namespace> istio-injection=enabled
```

### Ambient mode

```bash
kubectl labels namespace <namespace> istio.io/dataplane-mode=ambient
```

## ğŸ”„ Migration Example (How to gradually migrate to mTLS)

The recommended upgrade path:

### Step 1 â€” Set PERMISSIVE globally

```yaml
mtls:
  mode: PERMISSIVE
```

Now plaintext + mTLS both accepted.

### Step 2 â€” Configure workloads to send mTLS (DestinationRule)

```yaml
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: default
spec:
  host: "*.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
```

### Step 3 â€” Switch PeerAuthentication to STRICT

This ensures **100% secure mesh**.

---

## ğŸ¯ How to verify Peer Authentication is working

### Check mTLS mode applied:

```bash
istioctl authn tls-check <source-pod> <destination-pod>
```

Example:

```bash
istioctl authn tls-check reviews-v1 productpage-v1
```

You should see:

```ini
CLIENT â†’ reviews-v1: mTLS is enabled
SERVER â†’ productpage-v1: mTLS is required (STRICT)
```

### Check mesh-wide policies:

```bash
kubectl get peerauthentication -A
```

### Check sidecar certificates:

```bash
istioctl proxy-config secret <pod> -n <ns>
```

---

## ğŸŒ‰ Peer Authentication in **Ambient Mode**

Ambient mode still uses the **exact same PeerAuthentication resources**.

Key differences:

- âœ”ï¸ mTLS happens at **ztunnel level**
- âœ”ï¸ App Pods donâ€™t have sidecars, so they never handle certs
- âœ”ï¸ Traffic is encrypted node-to-node via ztunnel
- âœ”ï¸ STRICT mode means:

  - plaintext into ztunnel is accepted
  - but outgoing to another ztunnel is mTLS only

To enable STRICT for ambient workloads:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: ambient-strict
  namespace: default
spec:
  mtls:
    mode: STRICT
```

Apply:

```bash
kubectl apply -f ambient-peerauth.yaml
```

Ambient mode is easier because:

- You donâ€™t restart any app pods
- mTLS enforcement is centralized
- zTunnel updates happen as DaemonSets

---

## ğŸ§ TL;DR

**Istio Peer Authentication = telling Istio what kind of mTLS you want: DISABLE, PERMISSIVE, or STRICT.**

And you can apply it at:

1. Mesh level
2. Namespace level
3. Workload level

STRICT mode = **full Zero Trust**
PERMISSIVE mode = **safe migration**

Works in:

- Sidecar mode â†’ mTLS via Envoy
- Ambient mode â†’ mTLS via ztunnel

---

## ğŸ“š Reference

- [Peer Authentication:</br> Documentation -> Reference -> Configuration -> Security -> PeerAuthentication](https://istio.io/latest/docs/reference/config/security/peer_authentication/)
