# ğŸ§© Lab 1 â€” Two Network Namespaces (Red & Blue) Communication

## ğŸ¯ Objective

Weâ€™ll build this setup:

<div align="center" style="background-color:#ffff; border-radius: 10px; border: 2px solid">
  <img src="image/1760521176255.png" alt="Docker Image" style="width: 60%">
</div>

---

<div align="center" style="background-color:#00; border-radius: 10px; border: 2px solid">

```text
+-----------------------------------------------------------+
|                  Host (Default Namespace)                 |
|-----------------------------------------------------------|
|   eth0 â†’ 192.168.1.2   (Connected to LAN 192.168.1.0/24)  |
|                                                           |
|   +-------------------+       +-------------------+        |
|   |  ns: red          |       |  ns: blue         |        |
|   |  veth-red 10.10.0.1 <---> veth-blue 10.10.0.2 |        |
|   +-------------------+       +-------------------+        |
+-----------------------------------------------------------+
```

</div>

Goal:

- âœ… Create two isolated namespaces (`red`, `blue`)
- âœ… Connect them with a virtual cable (`veth-red`, `veth-blue`)
- âœ… Assign IPs
- âœ… Verify with ping

---

## âš™ï¸ Step 1 â€” Create Namespaces

```bash
ip netns add red
ip netns add blue
ip netns
```

Output:

```ini
red
blue
```

ğŸ“˜ Each namespace gets:

- its own routing table
- its own ARP table
- its own loopback (`lo`) interface

ğŸ§  Equivalent: `docker run --net=none` creates a namespace without connecting it to the bridge.

---

## ğŸ§© Step 2 â€” Create the Virtual Ethernet Cable

```bash
ip link add veth-red type veth peer name veth-blue
```

- `veth-red` â†” `veth-blue` are **two ends of one cable**.
- Anything sent into `veth-red` comes out of `veth-blue`.

---

## ğŸ§© Step 3 â€” Move Each End into Its Namespace

```bash
ip link set veth-red netns red
ip link set veth-blue netns blue
```

Now:

- `red` namespace owns `veth-red`
- `blue` namespace owns `veth-blue`

Host no longer sees them.

---

## ğŸŒ Step 4 â€” Assign IPs and Bring Interfaces Up

```bash
# red namespace
ip -n red addr add 10.10.0.1/24 dev veth-red
ip -n red link set veth-red up
ip -n red link set lo up

# blue namespace
ip -n blue addr add 10.10.0.2/24 dev veth-blue
ip -n blue link set veth-blue up
ip -n blue link set lo up
```

---

## ğŸ§  Step 5 â€” View ARP & Route Tables

### Hostâ€™s view:

```bash
arp
route
```

### Red namespace:

```bash
ip netns exec red arp
ip netns exec red route
```

### Blue namespace:

```bash
ip netns exec blue arp
ip netns exec blue route
```

Initially, their ARP tables are empty until they communicate.

---

## ğŸ§ª Step 6 â€” Test Communication

Ping from red â†’ blue:

```bash
ip netns exec red ping -c 2 10.10.0.2
```

Output:

```ini
64 bytes from 10.10.0.2: icmp_seq=1 ttl=64 time=0.025 ms
```

Now check ARP cache:

```bash
ip netns exec red arp
ip netns exec blue arp
```

Each namespace now knows the otherâ€™s MAC address.

---

## ğŸ§± Diagram: Result

```mermaid
---
config:
  look: handDrawn
---
graph LR
  subgraph Host [Host Network Namespace]
    Heth[eth0: 192.168.1.2]
  end
  subgraph Red [red namespace]
    Reth[veth-red: 10.10.0.1]
  end
  subgraph Blue [blue namespace]
    Beth[veth-blue: 10.10.0.2]
  end
  Reth<-->Beth
  Heth---LAN[192.168.1.0/24 LAN]
```

---

## ğŸ§° Step 7 â€” Cleanup

```bash
ip netns del red
ip netns del blue
```

---

## ğŸ§© Key Learnings

| Concept                  | Description                                                             |
| ------------------------ | ----------------------------------------------------------------------- |
| **Network Namespace**    | Separate networking stack per process                                   |
| **Veth Pair**            | Two connected interfaces acting as a virtual cable                      |
| **`ip -n`**              | Run networking commands inside a namespace                              |
| **ARP & Routing Tables** | Each namespace maintains its own                                        |
| **Isolation**            | Red & Blue cannot see each otherâ€™s routes or interfaces until connected |

---

## ğŸ§  Docker Analogy

| Manual Linux Namespace   | Docker Equivalent                            |
| ------------------------ | -------------------------------------------- |
| `ip netns add red`       | Container creation                           |
| `veth-red` â†” `veth-blue` | Dockerâ€™s veth to bridge                      |
| IP 10.10.0.x             | Containerâ€™s private IP                       |
| Ping test                | Same as container-to-container communication |

---

âœ… **End of Lab 1: Two Namespaces Communication**

Would you like me to proceed with **Lab 2 â€” Four Namespaces + Linux Bridge + Host Communication (like docker0)** next, with full diagrams and command visuals (exactly like your reference images)?
