# ğŸ§© Lab 2 â€” Four Namespaces + Central Linux Bridge (br0) + Host Communication

## ğŸ¯ Objective

Weâ€™ll create 4 isolated namespaces (like 4 containers), all connected to a **bridge (br0)**.
That bridge will let:  
âœ… All namespaces communicate with each other  
âœ… The host communicate with all namespaces

---

## ğŸ§± Topology Overview

<div align="center" style="background-color:#00; border-radius: 10px; border: 2px solid">

```text
                   +-----------------------+
                   |   Host (default ns)   |
                   |-----------------------|
                   | br0: 10.10.0.254/24   |
                   |                       |
                   +----------+------------+
                              |
          --------------------------------------------------
          |            |            |            |
       veth-red     veth-blue   veth-green   veth-yellow
          |            |            |            |
    +-----------+ +-----------+ +-----------+ +-----------+
    | red ns    | | blue ns   | | green ns  | | yellow ns |
    | 10.10.0.1 | | 10.10.0.2 | | 10.10.0.3 | | 10.10.0.4 |
    +-----------+ +-----------+ +-----------+ +-----------+
```

</div>

All 4 â€œcontainersâ€ are in the **10.10.0.0/24** network.

---

## ğŸ§  Whatâ€™s a Linux Bridge?

A **bridge** is like a **virtual switch**:

- It forwards packets between interfaces in the same broadcast domain (Layer 2)
- The kernel maintains an internal MAC address table (like a switch)
- Docker creates one by default (`docker0`)

Weâ€™ll make our own bridge: `br0`.

---

## âš™ï¸ Step 1 â€” Create the Bridge on Host

```bash
ip link add name br0 type bridge
ip addr add 10.10.0.254/24 dev br0
ip link set br0 up
```

âœ… Check:

```bash
ip addr show br0
```

Output should show:

```ini
3: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> ...
    inet 10.10.0.254/24 scope global br0
```

---

## âš™ï¸ Step 2 â€” Create Four Network Namespaces

```bash
for ns in red blue green yellow; do
  ip netns add $ns
done

ip netns
```

Output:

```ini
red
blue
green
yellow
```

---

## âš™ï¸ Step 3 â€” Create veth Pairs (Cables) for Each Namespace

Each namespace gets one end of a veth pair; the other end goes into the bridge.

```bash
ip link add veth-red type veth peer name veth-red-br
ip link add veth-blue type veth peer name veth-blue-br
ip link add veth-green type veth peer name veth-green-br
ip link add veth-yellow type veth peer name veth-yellow-br
```

---

## âš™ï¸ Step 4 â€” Move One End into Each Namespace

```bash
ip link set veth-red netns red
ip link set veth-blue netns blue
ip link set veth-green netns green
ip link set veth-yellow netns yellow
```

âœ… Host still has `veth-*-br` ends, which weâ€™ll now attach to the bridge.

---

## âš™ï¸ Step 5 â€” Connect Host Ends to the Bridge

```bash
ip link set veth-red-br master br0
ip link set veth-blue-br master br0
ip link set veth-green-br master br0
ip link set veth-yellow-br master br0
```

Bring them all up:

```bash
for i in red blue green yellow; do
  ip link set veth-${i}-br up
done
```

---

## âš™ï¸ Step 6 â€” Assign IPs Inside Each Namespace

```bash
ip -n red addr add 10.10.0.1/24 dev veth-red
ip -n blue addr add 10.10.0.2/24 dev veth-blue
ip -n green addr add 10.10.0.3/24 dev veth-green
ip -n yellow addr add 10.10.0.4/24 dev veth-yellow

for ns in red blue green yellow; do
  ip -n $ns link set lo up
  ip -n $ns link set veth-$ns up
done
```

---

## ğŸ§  Step 7 â€” Test Connectivity

Ping from host â†’ namespaces:

```bash
ping -c 1 10.10.0.1
ping -c 1 10.10.0.4
```

Ping from red â†’ blue:

```bash
ip netns exec red ping -c 2 10.10.0.2
```

âœ… They all can communicate because the bridge connects them at Layer 2.

---

## ğŸ§± Visual Diagram

```mermaid
---
config:
  look: handDrawn
---
graph TD
  subgraph Host [Host Namespace]
    BR0[br0: 10.10.0.254]
    VRB[veth-red-br]
    VBB[veth-blue-br]
    VGB[veth-green-br]
    VYB[veth-yellow-br]
  end
  subgraph Red [ns: red]
    VR[veth-red: 10.10.0.1]
  end
  subgraph Blue [ns: blue]
    VB[veth-blue: 10.10.0.2]
  end
  subgraph Green [ns: green]
    VG[veth-green: 10.10.0.3]
  end
  subgraph Yellow [ns: yellow]
    VY[veth-yellow: 10.10.0.4]
  end
  VR<-->VRB
  VB<-->VBB
  VG<-->VGB
  VY<-->VYB
  BR0---VRB
  BR0---VBB
  BR0---VGB
  BR0---VYB
```

---

## ğŸ§© Step 8 â€” Verify Bridge Connections

```bash
bridge link
```

Output will show all `veth-*-br` interfaces attached to `br0`.

---

## ğŸ§  Step 9 â€” Enable Host â†” Namespace Communication

The host is already in the same subnet (`10.10.0.254/24`), so it can talk directly with all namespaces.

Example:

```bash
ping -c 2 10.10.0.1  # Host â†’ red
ping -c 2 10.10.0.3  # Host â†’ green
```

---

## ğŸ§° Step 10 â€” Cleanup

```bash
ip link del br0
for ns in red blue green yellow; do
  ip netns del $ns
done
```

---

## ğŸ§  Key Concepts Recap

| Concept                | Description                                       |
| ---------------------- | ------------------------------------------------- |
| **Bridge (br0)**       | Virtual Layer 2 switch connecting interfaces      |
| **Veth Pair**          | Cable between namespace and bridge                |
| **Host Participation** | Assign IP to `br0` so host joins the same network |
| **Communication**      | All namespaces + host share same subnet           |

---

## ğŸ§© Analogy to Docker Networking

| Manual Setup            | Docker Equivalent                         |
| ----------------------- | ----------------------------------------- |
| br0                     | docker0                                   |
| veth-\*-br              | veth created by Docker for each container |
| Namespace (red/blue)    | Container network namespace               |
| 10.10.0.x IPs           | Container IPs                             |
| Ping between containers | Container inter-communication             |

---

âœ… **End of Lab 2: Multi-Namespace Bridge Network**

Would you like to continue with **Lab 3 â€” Another Host (192.168.1.3) communicating with this 10.10.x network** next (weâ€™ll add routing and NAT between two hosts)?
