# ğŸ›¡ï¸ Docker Daemon Security â€“ The Core of Docker Protection

## ğŸ“– What Is the Docker Daemon?

The **Docker Daemon (`dockerd`)** is the **brain** of Docker â€” it manages:

- Images
- Containers
- Networks
- Volumes

It listens for Docker API requests and performs actions on the host.

### ğŸ”¥ Why itâ€™s risky

The daemon runs as **root**.
So anyone who can talk to it â€” through the **Docker CLI**, **REST API**, or **Unix socket** â€” can effectively become root on the host.

```bash
# The default socket location
/var/run/docker.sock
```

If you give a container or user access to that socket â†’ you gave them **root on your host**.

---

## ğŸ•µï¸â€â™‚ï¸ **Docker Daemon Communication Channels**

Docker Daemon listens on two possible interfaces:

| Interface                                | Description                                      | Default                |
| ---------------------------------------- | ------------------------------------------------ | ---------------------- |
| **Unix Socket** (`/var/run/docker.sock`) | Local communication                              | âœ… Enabled by default  |
| **TCP Socket** (`tcp://HOST:PORT`)       | Remote access (used for remote management or CI) | âŒ Disabled by default |

You can check what the daemon is listening on:

```bash
ps aux | grep dockerd
```

Example:

```ini
dockerd --host=fd:// --host=tcp://0.0.0.0:2376
```

> ğŸ§¨ If you ever see `tcp://0.0.0.0:2375` with no TLS, it means the Docker API is exposed **unauthenticated** â€” total root compromise risk.

---

## ğŸ“ **Default Daemon Location and Config Files**

| File                                                 | Purpose                         |
| ---------------------------------------------------- | ------------------------------- |
| `/usr/bin/dockerd`                                   | Daemon executable               |
| `/etc/docker/daemon.json`                            | Main daemon configuration       |
| `/var/run/docker.sock`                               | Unix socket (client <-> daemon) |
| `/etc/systemd/system/docker.service.d/override.conf` | Systemd service overrides       |
| `/etc/docker/key.json`                               | Daemon identity key             |
| `/etc/docker/certs.d/`                               | Directory for TLS certs         |

---

## ğŸ›¡ï¸ **Secure Access to the Docker Daemon**

## ğŸ“ 1. **Use the Unix Socket (Local-Only Access)**

By default, the daemon only listens on:

```ini
unix:///var/run/docker.sock
```

Thatâ€™s good â€” it means **only local users with permission** to that socket can control Docker.

Check permissions:

```bash
ls -l /var/run/docker.sock
```

Output:

```ini
srw-rw---- 1 root docker 0 Oct 14 09:10 /var/run/docker.sock
```

Only `root` and users in the **docker** group can access it.

### âš ï¸ Danger:

Adding a user to the `docker` group gives them **root privileges** indirectly.

```bash
sudo usermod -aG docker <username>
```

ğŸ§  So donâ€™t add random users or CI agents here. Instead, use:

- `sudo docker <cmd>`
- Or **rootless Docker** (explained below)

---

## ğŸ“ 2. **Use Rootless Docker (Best for Developers)**

Rootless Docker runs the daemon as a **non-root user**.
It removes the biggest risk â€” daemon running as root.

```bash
curl -fsSL https://get.docker.com/rootless | sh
```

Then follow the setup instructions, e.g.:

```bash
export PATH=$HOME/bin:$PATH
systemctl --user enable --now docker
```

Check:

```bash
docker context ls
```

Youâ€™ll see:

```ini
rootless
```

ğŸ§  Benefits:

- No root privileges required
- No access to `/var/run/docker.sock`
- Completely isolated from system daemon

ğŸ“‰ Limitations:

- No low-number ports (<1024)
- Some advanced networking modes (macvlan, host) may not work

---

## ğŸ“ 3. **Use `userns-remap` for Privilege Isolation**

This feature **maps the containerâ€™s root user** to a **non-root user** on the host.

In `/etc/docker/daemon.json`:

```json
{
  "userns-remap": "default"
}
```

Create subordinate ID mappings:

```bash
echo "dockremap:165536:65536" | sudo tee -a /etc/subuid /etc/subgid
sudo systemctl restart docker
```

âœ… Now, even if a container breaks out, it runs as UID 165536 on the host â€” not real root.

---

## ğŸ“ 4. **Protect Remote Access (TCP Socket) with TLS (Updated Deep Version)**

When you expose the Docker Daemon over TCP (for remote management), you must protect it using **mutual TLS authentication**.
This ensures:

- ğŸ”‘ Only clients with valid certificates can connect.
- ğŸ”’ All traffic between Docker CLI and Daemon is encrypted.
- ğŸ§¾ Both sides verify each otherâ€™s identity.

---

### âš™ï¸ Key Files Involved

| File              | Side   | Purpose                                          |
| ----------------- | ------ | ------------------------------------------------ |
| `ca.pem`          | Both   | Root CA that signed both client and server certs |
| `server-cert.pem` | Server | Public certificate for dockerd                   |
| `server-key.pem`  | Server | Private key for dockerd                          |
| `client-cert.pem` | Client | Public certificate for Docker CLI                |
| `client-key.pem`  | Client | Private key for Docker CLI                       |

---

### ğŸ”¹ Step 1 â€” Create a Certificate Authority (CA)

First, generate your **own CA**.
This CA will be used to sign both **server** and **client** certificates.

```bash
mkdir -p ~/docker-certs
cd ~/docker-certs

# Generate CA private key
openssl genrsa -out ca-key.pem 4096

# Generate CA certificate
openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -subj "/CN=docker-CA" -out ca.pem
```

âœ… Files created:

- `ca-key.pem` â€” private key (keep it secret)
- `ca.pem` â€” public certificate (shared with server and clients)

---

### ğŸ”¹ Step 2 â€” Create and Sign the **Server Certificate**

This certificate is used by the **Docker Daemon** (`dockerd`) itself.

```bash
# Generate server private key
openssl genrsa -out server-key.pem 4096

# Create a certificate signing request (CSR)
openssl req -subj "/CN=<server-hostname>" -new -key server-key.pem -out server.csr

# Sign the server certificate using the CA
openssl x509 -req -days 365 -sha256 \
    -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial \
    -out server-cert.pem \
    -extfile <(echo subjectAltName = DNS:<server-hostname>,IP:<server-ip>)
```

âœ… Files created:

- `server-key.pem`
- `server-cert.pem`

ğŸ“Move these to the daemon host:

```bash
sudo mkdir -p /etc/docker/pki
sudo mv ca.pem server-cert.pem server-key.pem /etc/docker/pki/
```

---

### ğŸ”¹ Step 5 â€” Configure the Docker Daemon for TLS

Edit `/etc/docker/daemon.json`:

```json
{
  "hosts": ["fd://", "tcp://0.0.0.0:2376"],
  "tlsverify": true,
  "tlscacert": "/etc/docker/pki/ca.pem",
  "tlscert": "/etc/docker/pki/server-cert.pem",
  "tlskey": "/etc/docker/pki/server-key.pem"
}
```

Then reload and restart Docker:

```bash
sudo systemctl daemon-reload
sudo systemctl restart docker
```

You can verify:

```bash
sudo netstat -tulpn | grep dockerd
```

âœ… Should show:

```ini
tcp6  0  0 :::2376  :::*  LISTEN  /usr/bin/dockerd
```

---

### ğŸ”¹ Step 4 â€” Create and Sign the **Client Certificate**

This is what every **authorized client** (CLI, Jenkins, etc.) will use to authenticate.

```bash
# Generate client private key
openssl genrsa -out client-key.pem 4096

# Create CSR for the client
openssl req -subj "/CN=docker-client" -new -key client-key.pem -out client.csr

# Add extended key usage for client authentication
echo extendedKeyUsage = clientAuth > extfile-client.cnf

# Sign client certificate using the same CA
openssl x509 -req -days 365 -sha256 \
    -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial \
    -out client-cert.pem -extfile extfile-client.cnf
```

âœ… Files created:

- `client-key.pem`
- `client-cert.pem`

Move these to each authorized client (e.g. your laptop):

```ini
~/.docker/
  â”œâ”€â”€ ca.pem
  â”œâ”€â”€ client-cert.pem
  â””â”€â”€ client-key.pem
```

---

### ğŸ”¹ Step 5 â€” Connect from the Client (Securely)

From your workstation or CI agent, run:

```bash
docker --tlsverify \
  --tlscacert=~/.docker/ca.pem \
  --tlscert=~/.docker/client-cert.pem \
  --tlskey=~/.docker/client-key.pem \
  -H tcp://<server-ip>:2376 info
```

If everything is configured properly:  
âœ… Youâ€™ll see `Server Version`, `Storage Driver`, and other info.  
âŒ If you misconfigure, youâ€™ll see â€œcertificate signed by unknown authorityâ€ or â€œbad certificateâ€.

---

### ğŸ–¼ï¸ The TLS Handshake: Step-by-Step Flow

<div align="center" style="background-color:#071D28; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
    autonumber
    participant CLI as ğŸ§© Docker CLI (Client)
    participant D as ğŸ³ Docker Daemon (Server)
    participant CA as ğŸ›ï¸ Certificate Authority (CA)

    CLI->>D: TCP SYN â†’ Connect to tcp://<server-ip>:2376
    Note over CLI,D: TCP connection established â€” TLS handshake begins

    %% Step 1: Client Hello
    CLI->>D: ClientHello<br/>Supported ciphers, TLS version, random nonce

    %% Step 2: Server responds with identity
    D-->>CLI: ServerHello + Server Certificate (server-cert.pem)
    D-->>CLI: ServerKeyExchange (signed by server-key.pem)
    D-->>CLI: CertificateRequest (requests client cert for mTLS)
    D-->>CLI: ServerHelloDone

    %% Step 3: Server verification
    CLI->>CA: Validate server-cert.pem using ca.pem<br/>âœ” Trusted CA? âœ” Valid SAN? âœ” Not expired?
    alt invalid
        CLI-->>D: âŒ Abort (unknown authority)
    else valid
        CLI->>CLI: Continue handshake
    end

    %% Step 4: Client authentication
    CLI-->>D: Send client-cert.pem
    CLI-->>D: Send ClientKeyExchange (proves ownership of client-key.pem)
    CLI-->>D: Send CertificateVerify (signature over handshake data)
    CLI-->>D: Send ChangeCipherSpec + Finished

    %% Step 5: Server verifies client
    D->>CA: Verify client-cert.pem using ca.pem<br/>âœ” Signed by trusted CA? âœ” Valid CN? âœ” Not revoked?
    alt invalid
        D-->>CLI: âŒ Reject (bad certificate)
    else valid
        D-->>CLI: Send ChangeCipherSpec + Finished
    end

    %% Step 6: Secure channel
    Note over CLI,D: âœ… mTLS handshake complete â†’ Encrypted + Authenticated channel

    %% Step 7: Actual API
    CLI->>D: HTTPS GET /v1.xx/info
    D-->>CLI: 200 OK + JSON payload
```

</div>

---

### ğŸ§© What Each Side Verifies

| Verification           | Done By | Using                                             | Checks                                                     |
| ---------------------- | ------- | ------------------------------------------------- | ---------------------------------------------------------- |
| **Server Identity**    | Client  | `server-cert.pem` signed by `ca.pem`              | Validity, hostname (SAN), trusted CA                       |
| **Client Identity**    | Server  | `client-cert.pem` signed by `ca.pem`              | Validity, CN, trusted CA                                   |
| **Proof of Ownership** | Both    | Private keys (`server-key.pem`, `client-key.pem`) | Demonstrated via cryptographic signatures                  |
| **Session Security**   | Both    | TLS symmetric key                                 | Generated during handshake; ensures encryption & integrity |

---

### ğŸ§  Key Takeaways

âœ… **Both sides verify each other:**

- This is **mutual TLS (mTLS)** â€” not just HTTPS-style one-way trust.
- The client refuses to talk unless it trusts the daemonâ€™s certificate.
- The daemon refuses to talk unless the clientâ€™s cert is signed by its trusted CA.

âœ… **No passwords or tokens are exchanged.**

- Trust is purely certificate-based, verified by the CA chain.

âœ… **Everything after handshake is encrypted.**

- The Docker API traffic (`GET /info`, `GET /containers/json`, etc.) travels over an HTTPS channel secured by the negotiated symmetric key.

âœ… **Revocation/rotation:**

- If you regenerate the CA or revoke a client cert, that client can no longer connect â€” this is how you control who can access your Docker daemon.

---

## ğŸ“ **Example**: Hardened Daemon Configuration

Hereâ€™s a secure `/etc/docker/daemon.json` you can safely use in production:

```json
{
  "icc": false, // prevent inter-container communication on default bridge
  "userns-remap": "default", // isolate container users
  "tlsverify": true, // if TCP enabled
  "tlscacert": "/etc/docker/pki/ca.pem",
  "tlscert": "/etc/docker/pki/server-cert.pem",
  "tlskey": "/etc/docker/pki/server-key.pem",
  "log-driver": "local", // prevent log overflow
  "log-opts": { "max-size": "10m", "max-file": "3" },
  "live-restore": true, // containers keep running if daemon restarts
  "no-new-privileges": true // apply to supported containers
}
```

---

## âœ… **Verifying Daemon Security**

| Check                 | Command                              |     |
| --------------------- | ------------------------------------ | --- |
| TLS enabled           | `sudo netstat -tulpn | grep dockerd` |
| User namespace active | `docker info | grep -i userns`       |
| Rootless mode active  | `docker info | grep -i rootless`     |
| Socket permissions    | `ls -l /var/run/docker.sock`         |     |

---

## ğŸ”´ **Common Security Pitfalls**

| âŒ Bad Practice                               | âœ… Secure Alternative                        |
| --------------------------------------------- | -------------------------------------------- |
| Exposing port 2375 without TLS                | Use port 2376 with TLS mutual auth           |
| Adding many users to `docker` group           | Keep minimal, or use rootless                |
| Mounting `/var/run/docker.sock` in containers | Never do this; use a scoped API proxy        |
| Running daemon as root                        | Use rootless Docker or userns-remap          |
| Forgetting log rotation                       | Add `"log-driver": "local"` and `"max-size"` |

---

## ğŸ§­ 8. Quick Diagram

<div align="center" style="background-color:#071D28; border-radius: 10px; border: 2px solid">

```mermaid
flowchart LR
A[Docker CLI] -->|Unix Socket /var/run/docker.sock| B[(Docker Daemon)]
A -->|TLS over 2376| B
B -->|Manages| C[Containers]
B -->|Manages| D[Images]
B -->|Manages| E[Networks]
```

</div>

---

## ğŸ”š **Summary**

| Feature                  | Purpose                  | Best For                                   |
| ------------------------ | ------------------------ | ------------------------------------------ |
| **Unix Socket**          | Local CLI access         | Developers                                 |
| **TLS + TCP**            | Secure remote management | CI/CD or remote control                    |
| **Rootless Mode**        | No root privileges       | Dev/test or secure multi-user environments |
| **User Namespace Remap** | UID isolation            | Production hardened setups                 |
| **`daemon.json`**        | Central config           | Security + performance                     |
