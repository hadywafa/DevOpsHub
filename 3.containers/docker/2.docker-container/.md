# 🧩 What Happens When You Run a Docker Container

> Example command:
>
> ```bash
> docker run -d -p 8080:80 nginx
> ```

---

## 🧠 High-level idea

This one command triggers a **multi-step internal workflow** involving:

1. Docker CLI → Daemon communication
2. Image retrieval and unpacking
3. Container filesystem creation (layers + union mount)
4. Namespace and cgroup setup
5. Container process start (via containerd + runc)
6. Network and port binding
7. Lifecycle management

Let’s unpack these one by one.

---

<div align="center">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "High-Level Flow: docker run"
---
flowchart TD
    A["docker CLI"] -->|REST API over unix:///var/run/docker.sock| B["dockerd (Daemon)"]
    B --> C["containerd"]
    C --> D["runc"]
    D --> E["Linux kernel (namespaces, cgroups)"]
    E --> F["Isolated Process (Container)"]
    F --> G["Network namespace (bridge, eth0)"]
    F --> H["Union filesystem (OverlayFS layers)"]
```

</div>

---

## 1️⃣ Docker CLI talks to Docker Daemon

When you type:

```bash
docker run -d -p 8080:80 nginx
```

➡️ The **CLI** (`docker`) doesn’t actually run the container itself.
It sends a **REST API request** to the **Docker daemon (`dockerd`)** over the **Unix socket** `/var/run/docker.sock`.

You can even see this API:

```bash
curl --unix-socket /var/run/docker.sock http://localhost/containers/json
```

---

## 2️⃣ Daemon (dockerd) asks containerd to create a container

`dockerd` doesn’t handle low-level container operations itself anymore.
It delegates to **containerd**, a lightweight container supervisor.

👉 **containerd** manages:

- Pulling images
- Unpacking layers
- Creating and starting containers
- Managing runtime via **runc**

---

## 3️⃣ containerd checks if the image exists

If the image (`nginx`) isn’t already downloaded:

1. Docker contacts the **registry** (like Docker Hub)
2. Authenticates if needed
3. Pulls the image manifest + layers
4. Stores them under `/var/lib/docker/<storage-driver>/`

Each **layer** is a compressed tarball representing filesystem changes.

---

## 4️⃣ Union Filesystem (OverlayFS)

Once image layers are downloaded, Docker assembles them using **OverlayFS**, which merges multiple read-only layers + one writable layer.

Example for `nginx`:

```ini
nginx:latest
├── Layer 1: Ubuntu base image
├── Layer 2: Added libraries
├── Layer 3: Nginx binaries
└── Writable layer (container changes)
```

📂 Mounted at:

```ini
/var/lib/docker/overlay2/<container-id>/merged
```

This becomes the container’s root filesystem (`/` inside container).

---

## 5️⃣ containerd calls runc to “run” the container

Next, **containerd** uses **runc** to actually create and start the process.
runc is a **CLI tool (written in Go)** implementing the **Open Container Initiative (OCI)** runtime spec.

It’s responsible for:

- Setting up **namespaces**
- Applying **cgroups**
- Performing **pivot_root** (switching into the container filesystem)
- Executing the container’s process (like `/usr/sbin/nginx`)

---

<div align="center">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "How containerd & runc cooperate"
---
sequenceDiagram
    participant dockerd
    participant containerd
    participant runc
    participant kernel

    dockerd->>containerd: create + start container
    containerd->>runc: generate OCI bundle
    runc->>kernel: clone() with namespaces + cgroups
    kernel-->>runc: returns new isolated PID
    runc->>kernel: pivot_root() → chroot to container FS
    runc->>kernel: execve("/usr/sbin/nginx")
    kernel-->>containerd: process running in isolation
```

</div>

---

## 6️⃣ Namespaces — Isolation Magic 🧙‍♂️

runc uses **Linux namespaces** to give each container its own view of the system:

| Namespace | What It Isolates        | Example                                       |
| --------- | ----------------------- | --------------------------------------------- |
| `PID`     | Process tree            | Each container starts with PID 1              |
| `NET`     | Network interfaces, IPs | Container has its own `eth0`                  |
| `MNT`     | Filesystem mounts       | Separate `/` root                             |
| `UTS`     | Hostname & domain       | Container’s own hostname                      |
| `IPC`     | Interprocess comms      | Separate message queues                       |
| `USER`    | User IDs                | Map root inside container to non-root outside |

---

## 7️⃣ cgroups — Resource Control

Then, Docker applies **cgroups** (control groups) to limit and account for:

- CPU usage
- Memory
- Disk I/O
- Number of processes (PIDs)

They live under `/sys/fs/cgroup/`.

Example:

```ini
/sys/fs/cgroup/system.slice/docker-<id>.scope/memory.current
```

If the container exceeds the memory limit, Linux kills the process (`OOM killer`).

---

## 8️⃣ Network Setup

By default, Docker connects containers to a **bridge network** (`docker0`):

- Creates a **virtual Ethernet pair (veth)**

  - One end inside container (`eth0`)
  - Other end on host (`vethXXXX` connected to bridge)

- Assigns IP via internal DHCP
- Applies NAT rules (via iptables) for `-p 8080:80` port mapping

So `localhost:8080` → container’s port `80`.

---

## 9️⃣ Container Process Starts

Finally:

- `runc` calls `execve()` → replaces itself with the container’s main process (`nginx`)
- That process runs in its isolated namespaces
- Docker daemon tracks it and logs its output

You can see the running process with:

```bash
ps aux | grep nginx
```

It looks like a regular process — but is isolated by namespaces and cgroups.

---

## 🔄 Lifecycle Management

Now Docker:

- Monitors the container process
- Captures stdout/stderr logs
- Applies restart policy if it exits
- Removes cgroups and namespaces when it stops

---

## 🔍 Full Internal Flow Summary

| Step | Component      | Function                            |
| ---- | -------------- | ----------------------------------- |
| 1    | `docker CLI`   | Sends REST API to daemon            |
| 2    | `dockerd`      | Parses request, contacts containerd |
| 3    | `containerd`   | Handles image, lifecycle, runtime   |
| 4    | `runc`         | Creates namespaces, applies cgroups |
| 5    | `Linux kernel` | Enforces isolation                  |
| 6    | `Network`      | Bridge, NAT, IP assignment          |
| 7    | `Process`      | Executes inside isolated world      |

---

## 🧠 Simple Analogy

| Layer        | Analogy               | Real Component              |
| ------------ | --------------------- | --------------------------- |
| 🧑 User      | You type `docker run` | Docker CLI                  |
| 📬 Manager   | Takes request         | Docker daemon               |
| 🧱 Builder   | Prepares room         | containerd                  |
| 🚪 Locksmith | Locks doors & windows | runc (namespaces + cgroups) |
| 🏠 Room      | Container process     | Isolated environment        |

---

## 🔍 Check this yourself

Try these commands and see internals live:

```bash
docker run -d --name test nginx
docker inspect test | jq '.State.Pid'
```

Then:

```bash
sudo lsns -p <PID>
```

You’ll see namespaces like:

```ini
4026532575 net
4026532576 mnt
4026532577 pid
...
```

---

## 🧾 TL;DR Summary

| Concept              | Description                 |
| -------------------- | --------------------------- |
| **CLI**              | Sends request to daemon     |
| **Daemon (dockerd)** | Manages containers & API    |
| **containerd**       | Handles image + lifecycle   |
| **runc**             | Does actual Linux isolation |
| **Namespaces**       | Isolation                   |
| **Cgroups**          | Resource control            |
| **OverlayFS**        | Layered filesystem          |
| **Network bridge**   | Container connectivity      |

---

## 💡 Mnemonic to Remember:

> "**Cows Need Coffee, Running Never Ends**" ☕

| Letter                       | Meaning |
| ---------------------------- | ------- |
| **C** – CLI → Daemon         |         |
| **N** – Namespaces           |         |
| **C** – Cgroups              |         |
| **R** – Runc                 |         |
| **N** – Network setup        |         |
| **E** – Execution of process |         |
