# âš™ï¸ **Docker Objects**

<div align="center" style="background: #071D28; border-radius: 20px">
<img src="image/1760189112617.png" alt="2013 Docker 0.6 (LXC Era)" style="width: 70%;">
</div>

---

Weâ€™ll cover:

1. ğŸ§± Images
1. ğŸ“¦ Containers
1. ğŸŒ Networks
1. ğŸ’¾ Volumes
1. ğŸª Registry

---

## ğŸ§± 1. Docker Image

Think of an **image** like a **blueprint or recipe** for a container.

- Itâ€™s a **read-only template** that contains everything your app needs:

  - The base OS (like Ubuntu or Alpine)
  - App code
  - Dependencies (Python, .NET, Node.js, etc.)
  - Configuration (environment, commands)

When you run:

```bash
docker run nginx
```

Docker:

1. Downloads the **nginx image** from Docker Hub (if not already present).
2. Uses it as a **template** to create a container.

ğŸ§  Images are **built from layers**. Each command in a Dockerfile adds a new layer:

```dockerfile
FROM python:3.9
COPY app/ /app
RUN pip install -r requirements.txt
CMD ["python", "app/main.py"]
```

Each `FROM`, `COPY`, and `RUN` creates a layer â€” so rebuilding is fast and storage efficient.

---

## ğŸ“¦ 2. Docker Container

A **container** is a **running instance of an image**.

- Itâ€™s **read/write** (unlike images).
- When you start a container, Docker adds a **thin writable layer** on top of the imageâ€™s read-only layers.
- You can run, stop, or delete containers anytime.

Example:

```bash
docker run -d -p 8080:80 nginx
```

This starts a **container** from the **nginx image**, mapping:

- Port 80 in container â†’ Port 8080 on your machine.

When you delete the container, the writable layer is gone â€” the **image** remains unchanged.

ğŸ§  Think:

> Image = class
> Container = object (instance of that class)

---

## ğŸŒ 3. Docker Network

Containers need a way to talk to each other or to the outside world.
Thatâ€™s where **Docker Networks** come in.

There are 3 common types:

| Network Type | Description                                               |
| ------------ | --------------------------------------------------------- |
| **bridge**   | Default network; containers on same host can talk by name |
| **host**     | Shares hostâ€™s network stack (no isolation)                |
| **none**     | No network at all (fully isolated)                        |

Example:

```bash
docker network create myapp-net
docker run -d --name web --network myapp-net nginx
docker run -d --name db --network myapp-net mysql
```

Now `web` can reach `db` by name (`db:3306`).

ğŸ§  Think:

> Network = â€œVirtual switchâ€ connecting containers together.

---

## ğŸ’¾ 4. Docker Volume

Containers are **temporary** â€” when you delete one, its data is gone.
To keep data safe, Docker uses **volumes**.

A **volume** is a **special directory** stored outside the containerâ€™s filesystem.

You can share it between containers or persist it even after a container is deleted.

Example:

```bash
docker volume create mydata
docker run -v mydata:/var/lib/mysql mysql
```

Even if the MySQL container is removed, your database data in `mydata` still exists.

ğŸ§  Think:

> Volume = Hard drive for your containers.

---

## ğŸª 5. Docker Registry

A **registry** is where Docker stores and shares images.

- Public registry: **Docker Hub** (`hub.docker.com`)
- Private registries: AWS ECR, Azure ACR, Google GCR, Harbor, etc.

When you:

```bash
docker pull ubuntu
```

Docker downloads the image from the **registry** to your machine.
When you:

```bash
docker push myapp:latest
```

Docker uploads your image to a **registry** so others can use it.

ğŸ§  Think:

> Registry = â€œApp Storeâ€ for Docker images.

---

Perfect â€” your image already captures the **Docker Engine Command structure** beautifully ğŸ‘

Hereâ€™s how to explain it **simply and clearly**, in words matching your visual (and yes, the **left-side form** is the preferred / modern syntax):

---

## ğŸ§± Docker Engine Command Structure

Every Docker command follows this structure ğŸ‘‡

---

<div align="center" style="background: #071D28; border-radius: 20px">
<img src="image/1760194302556.png" alt="2013 Docker 0.6 (LXC Era)" style="width: 70%;">
</div>

---

```ini
docker <docker-object> <sub-command> [options] [arguments]
```

### ğŸ§© Explanation of Each Part

| Part                 | Meaning                                                             | Example                                   |
| -------------------- | ------------------------------------------------------------------- | ----------------------------------------- |
| **docker**           | The main command-line tool that talks to the Docker Engine          | `docker`                                  |
| **\<docker-object>** | What youâ€™re acting on (like a container, image, volume, or network) | `container`, `image`, `volume`, `network` |
| **\<sub-command>**   | The specific action you want to perform                             | `run`, `stop`, `build`, `ls`, `rm`        |
| **[options]**        | Optional flags that modify the commandâ€™s behavior                   | `-d`, `--name`, `-p 8080:80`              |
| **[arguments]**      | Target or value youâ€™re working with                                 | `ubuntu`, `myapp`                         |

---

## âœ… Preferred / Modern Syntax

Docker now recommends the **object-oriented syntax** (the left side in your image):

```bash
docker container run -it ubuntu
docker image build .
docker container ls
docker volume create mydata
docker network inspect bridge
```

âœ… **Why this form is preferred:**

- Itâ€™s more structured and readable
- Easier to remember what object youâ€™re working with
- Consistent across all Docker objects
- Future-proof â€” this is how all modern Docker docs are written

---

## âš™ï¸ Legacy / Shortcut Syntax

Older Docker versions allowed you to skip the object name:

```bash
docker run -it ubuntu      # shortcut for docker container run
docker build .             # shortcut for docker image build
docker ps                  # shortcut for docker container ls
docker rm mycontainer      # shortcut for docker container rm
```

These still work today, but theyâ€™re just **shorthand** â€” the **preferred modern form** is:

> ğŸŸ¢ **Use the left-side â€œobject + sub-commandâ€ structure.**

---

## ğŸ—ºï¸ Quick Visual Summary

<div align="center">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "Docker Objects Overview"
---
flowchart LR
    A["ğŸª Registry (Docker Hub)"] -->|pull image| B["ğŸ§± Image"]
    B -->|run| C["ğŸ“¦ Container"]
    C -->|store data| D["ğŸ’¾ Volume"]
    C -->|communicate| E["ğŸŒ Network"]
    B -->|push| A
```

</div>

---

âœ… **Summary Objects:**

| Object        | Description                          | Persistent?       |
| ------------- | ------------------------------------ | ----------------- |
| **Image**     | Blueprint for containers (read-only) | âœ… Yes            |
| **Container** | Running instance of an image         | âŒ No (temporary) |
| **Network**   | Connects containers together         | âœ… Yes            |
| **Volume**    | Stores persistent data               | âœ… Yes            |
| **Registry**  | Stores and distributes images        | âœ… Yes            |

âœ… **Summary Commands:**

| Preferred Form                    | Shortcut                | Meaning                     |
| --------------------------------- | ----------------------- | --------------------------- |
| `docker container run -it ubuntu` | `docker run -it ubuntu` | Run a new container         |
| `docker image build .`            | `docker build .`        | Build an image              |
| `docker container attach ubuntu`  | `docker attach ubuntu`  | Attach to running container |
| `docker container kill ubuntu`    | `docker kill ubuntu`    | Kill a running container    |
