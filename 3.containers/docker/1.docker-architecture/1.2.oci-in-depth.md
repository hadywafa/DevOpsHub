# ğŸ—ï¸ 2015 â€” The Open Container Initiative (OCI): The â€œContainer Civil Warâ€ and Peace Treaty

<div align="center">

> â€œIn 2015, Docker was both the king ğŸ‘‘ and the chaos creator âš¡ of the container world.â€

</div>

---

## ğŸ§¨ Step 1 â€” The Situation Before OCI

By 2015, Docker was **hugely successful**.
Everyone loved `docker run nginx` â€” but under the hood, Docker had become a **monolith**.

### âš™ï¸ Docker Stack (Before OCI)

| Layer                    | What Docker Owned                                      |
| ------------------------ | ------------------------------------------------------ |
| **Image Format**         | The `.tar` layered filesystem design (AUFS, overlayfs) |
| **Image Registry**       | Docker Hub & Registry API (for pulling/pushing images) |
| **Runtime**              | `libcontainer` for isolation                           |
| **Daemon**               | `dockerd` â€“ the monolithic controller                  |
| **CLI**                  | `docker` command                                       |
| **Networking & Volumes** | Built into `dockerd`                                   |
| **API**                  | Docker Engine REST API                                 |

Docker was **vertically integrated** â€” one vendor controlled every piece.

---

## âš”ï¸ Step 2 â€” The Competitors Appear

Other companies started building **alternatives** for specific layers of the stack â€”
they didnâ€™t want to depend on Docker Inc for production infrastructure.

| Project            | Company   | Goal                                                 |
| ------------------ | --------- | ---------------------------------------------------- |
| **rkt**            | CoreOS    | Alternative runtime â€” more secure, no central daemon |
| **LXD**            | Canonical | LXC-based system containers                          |
| **Mesos**          | Apache    | Container orchestration before Kubernetes            |
| **systemd-nspawn** | Red Hat   | Lightweight container runtime built into systemd     |
| **OpenVZ**         | Parallels | Kernel-level containers (older tech)                 |

ğŸ’¬ **Problem:**
Each runtime used its _own image format_ and _own container definition_.
â†’ A container built for Docker couldnâ€™t run on rkt or LXD.
â†’ Chaos in CI/CD pipelines, registries, and orchestration tools.

---

## ğŸ§© Step 3 â€” Docker Creates OCI to Save the Ecosystem (and Itself)

Docker realized:

> â€œIf everyone forks our format, containers will fragment â€” like RPM vs DEB.â€

So Docker donated key parts of its runtime to the **Linux Foundation**.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "2015: Docker Donates libcontainer to Form OCI"
---
flowchart TD
    D["Docker Inc."] -->|Donates| LC["libcontainer"]
    LF["Linux Foundation"] --> OCI["OCI (Open Container Initiative)"]
    OCI --> RS["runtime-spec"]
    OCI --> IS["image-spec"]

    classDef pink fill:#ffb6ff,stroke:#333,color:#222,font-weight:bold
    classDef blue fill:#a6f0ff,stroke:#333,color:#222,font-weight:bold
    class D,LC pink
    class LF,OCI,RS,IS blue
```

</div>

---

## ğŸ§  What Docker Had vs What Others Had (in 2015)

| Layer              | Docker                                          | Others                                 | Problem                     |
| ------------------ | ----------------------------------------------- | -------------------------------------- | --------------------------- |
| **Image Format**   | Docker Image (layered tarballs, JSON manifests) | CoreOS â€œACIâ€ (App Container Image)     | Incompatible formats        |
| **Runtime Engine** | `libcontainer` (Go)                             | `rkt`, `LXC`, `systemd-nspawn` (C/C++) | Different syscalls, configs |
| **Daemon**         | `dockerd` (central API + builder)               | rkt (daemonless), LXD (REST API)       | Fragmented lifecycle mgmt   |
| **Orchestration**  | Swarm (early), Docker Compose                   | Mesos, Kubernetes, Fleet               | No common runtime interface |
| **Registry**       | Docker Hub                                      | Private registries (custom APIs)       | Nonstandard push/pull       |

So â€” **everyone** had a â€œcontainerâ€ â€” but none of them were the _same type_ of container.

---

## ğŸ§© Step 4 â€” What OCI Actually Did

OCI was not a new runtime.
It was a **set of specifications (documents)** describing:

| Spec             | Defines                                                                                  |
| ---------------- | ---------------------------------------------------------------------------------------- |
| **image-spec**   | How container images are packaged (manifests, layers, metadata)                          |
| **runtime-spec** | How to create and run containers from an image (filesystem, process, env, mounts, hooks) |

---

### ğŸ§  Think of OCI as:

> â€œThe IEEE of containers.â€

It didnâ€™t tell you _which code to use_, only _how your runtime must behave_.

---

### ğŸ“œ Example (runtime-spec core ideas)

A valid OCI container must have:

- A `config.json` describing:

  - root filesystem path
  - user, environment variables
  - cgroup resources
  - namespace isolation

- A root filesystem directory (`rootfs/`) with the unpacked image
- Hooks for prestart, poststop, etc.

---

### ğŸ“œ Example (image-spec core ideas)

A valid OCI image must have:

- JSON manifest listing layers
- Layer tarballs (filesystem diffs)
- Config JSON (entrypoint, cmd, env)

So OCI turned Dockerâ€™s internal formats into **open standards**.

---

## ğŸ§© Step 5 â€” Did This Mean Alternatives to Docker Daemon?

YES â€” absolutely.

The **moment OCI specs existed**, other runtimes could replace Dockerâ€™s daemon entirely.

Docker Daemon was **just one implementation** that happened to speak OCI.

---

### ğŸ§  OCI opened the door to new runtimes:

| Runtime          | Developer               | Notes                                                    |
| ---------------- | ----------------------- | -------------------------------------------------------- |
| **runc**         | Docker (donated to OCI) | Reference implementation of runtime-spec                 |
| **containerd**   | Docker â†’ CNCF           | Mid-level daemon managing multiple runc containers       |
| **CRI-O**        | Red Hat                 | Kubernetes-focused runtime implementing CRI using runc   |
| **rkt (CoreOS)** | CoreOS                  | Implemented OCI (later deprecated)                       |
| **Podman**       | Red Hat                 | Daemonless runtime; uses `runc` under the hood           |
| **LXD**          | Canonical               | System container runtime; OCI-compatible through adapter |

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "After OCI â€” Docker Daemon Becomes Optional"
---
flowchart LR
    OCI["OCI Specs"]
    D["dockerd"]
    C["containerd"]
    CR["CRI-O"]
    P["Podman"]
    RKT["rkt"]
    RUNC["runc (reference runtime)"]
    KERNEL["Linux Kernel"]

    OCI --> D
    OCI --> C
    OCI --> CR
    OCI --> P
    OCI --> RKT

    D --> RUNC
    C --> RUNC
    CR --> RUNC
    P --> RUNC
    RKT --> RUNC
    RUNC --> KERNEL

    classDef oci fill:#9cf2ff,stroke:#111,color:#111,font-weight:bold
    classDef runtime fill:#f4afff,stroke:#111,color:#111,font-weight:bold
    classDef kernel fill:#b8ffb8,stroke:#111,color:#111,font-weight:bold
    class OCI oci
    class D,C,CR,P,RKT runtime
    class KERNEL kernel
```

</div>

---

## ğŸ§  So â€” Do All These Use `libcontainer`?

Hereâ€™s the nuance ğŸ‘‡

| Runtime            | Uses libcontainer? | Written In | Explanation                                         |
| ------------------ | ------------------ | ---------- | --------------------------------------------------- |
| **runc**           | âœ… Yes             | Go         | Directly uses libcontainer                          |
| **containerd**     | âœ… Indirectly      | Go         | Calls runc (which uses libcontainer)                |
| **dockerd**        | âœ… Indirectly      | Go         | Uses containerd â†’ runc â†’ libcontainer               |
| **Podman**         | âœ… Indirectly      | Go         | Calls runc                                          |
| **CRI-O**          | âœ… Indirectly      | Go         | Calls runc                                          |
| **rkt**            | âŒ No              | Go/C       | Used its own isolation engine                       |
| **LXD**            | âŒ No              | C          | Uses LXC, not libcontainer                          |
| **systemd-nspawn** | âŒ No              | C          | Uses systemd APIs, not OCI runtime-spec (initially) |

So `libcontainer` became the **de facto kernel interface** library for OCI runtimes, but not the only one.

---

## ğŸ§© Step 6 â€” runc: The Reference Runtime

To prove the OCI runtime spec was real, Docker donated `libcontainer` â†’ turned it into **runc**.

runc is now the **official reference implementation** of OCI runtime-spec.

All modern runtimes like `containerd`, `CRI-O`, `Podman`, and even `Buildah` call **runc** internally.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "runc â€” The Common Executor Beneath All OCI Runtimes"
---
flowchart TD
    K8S["Kubernetes"]
    CRI["CRI (Runtime Interface)"]
    CNT["containerd"]
    CRIO["CRI-O"]
    POD["Podman"]
    RUNC["runc (OCI runtime-spec impl)"]
    LIBC["libcontainer"]
    KERNEL["Linux Kernel (Namespaces, Cgroups)"]

    K8S --> CRI
    CRI --> CNT
    CRI --> CRIO
    POD --> RUNC
    CNT --> RUNC
    CRIO --> RUNC
    RUNC --> LIBC
    LIBC --> KERNEL

    classDef pink fill:#ffb6ff,stroke:#111,color:#111,font-weight:bold
    classDef blue fill:#9cf2ff,stroke:#111,color:#111,font-weight:bold
    classDef kernel fill:#a8ffa8,stroke:#111,color:#111,font-weight:bold
    class K8S,CRI,CNT,CRIO,POD,RUNC pink
    class LIBC,KERNEL blue
```

</div>

---

## âš™ï¸ Step 7 â€” The Aftermath: How the Ecosystem Unified

### ğŸ”¹ Docker Inc. kept:

- Docker CLI
- Docker Daemon
- Docker Hub

### ğŸ”¹ The Community (via OCI + CNCF) built:

- **containerd** â†’ runtime for K8s and Docker
- **runc** â†’ standard executor
- **CRI-O** â†’ K8s-native runtime
- **Podman/Buildah** â†’ developer tools without daemons

---

### ğŸ”¹ Kubernetes adopted:

- **CRI** (Container Runtime Interface) â†’ talks to containerd or CRI-O
- **Dockershim** (bridge to Docker) â†’ **removed in K8s v1.24**

Result:

> Kubernetes now uses the same runc/libcontainer engine, but **no Docker Daemon is needed**.

---

## ğŸ§­ Final Summary â€” The â€œPeace Treaty of Containersâ€

| Layer             | Standardized by                 | Implementation Examples      |
| ----------------- | ------------------------------- | ---------------------------- |
| **Image Format**  | OCI Image Spec                  | Docker, Podman, CRI-O        |
| **Runtime Spec**  | OCI Runtime Spec                | runc, crun, Kata Containers  |
| **Orchestration** | CNCF Projects                   | Kubernetes                   |
| **Registry API**  | Docker Registry API (open spec) | Docker Hub, Harbor, ECR, GCR |

---

## ğŸ§  TL;DR Answers to Your Questions

| Question                            | Answer                                                                                                                                |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Why did Docker create OCI?**      | To prevent fragmentation of image/runtime formats and gain trust of enterprise + ecosystem by open-sourcing its internals.            |
| **What did Docker have vs others?** | Docker had full vertical stack (daemon, CLI, image, runtime), while others built isolated alternatives.                               |
| **What did OCI define?**            | Two open specs: `runtime-spec` (how to run containers) and `image-spec` (how to package them).                                        |
| **Did it replace Docker Daemon?**   | Not directly â€” but it **allowed others** to replace it (containerd, CRI-O, Podman).                                                   |
| **Do they all use libcontainer?**   | Most OCI-compliant runtimes use libcontainer (via runc), except some like LXC or nspawn that have their own low-level implementation. |

---

Would you like me to continue next with
ğŸ‘‰ **â€œHow runc and libcontainer actually create a container process (syscalls, namespaces, pivot_root, cgroups setup, step-by-step with diagrams)â€**?

Thatâ€™s the real kernel-level magic underneath everything â€” the part Kubernetes and containerd ultimately depend on.
