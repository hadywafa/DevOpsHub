# ğŸ§© Docker Image Build â€” The Complete Guide

## ğŸ•°ï¸ **Why Image Building Exists?**

Before Docker, deploying an app looked like this:

- Install dependencies manually
- Set up runtime (e.g., Python, Node, .NET)
- Copy source code
- Configure environment variables manually

This caused:

- ğŸ’¥ â€œworks on my machineâ€ problems
- ğŸ’¥ inconsistent dependencies
- ğŸ’¥ hard-to-reproduce environments

Docker solved this by introducing:

> A **reproducible image build system**, where your app and environment live together.

---

## ğŸ¯ **Image Build Overview â€” Flask App Example**

Before diving into image building, letâ€™s start with a foundational example: building a Docker image for a simple Python web application using Flask.

---

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">
  <img src="image/1760372903564.png" alt="Docker Image" style="width: 80%;">
</div>

---

**ğŸ“¦ Dockerfile Breakdown:**

```dockerfile
FROM Ubuntu

RUN apt-get update && apt-get -y install python

RUN pip install flask flask-mysq1

COPY ./opt/source-code

ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run
```

| Step                                              | Purpose                                                                              |
| ------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `FROM Ubuntu`                                     | Starts from a minimal Ubuntu base image                                              |
| `RUN apt-get update && apt-get -y install python` | Installs Python after updating package repositories                                  |
| `RUN pip install flask flask-mysq1`               | Adds Flask and MySQL connector (note: `flask-mysq1` may be a typo for `flask-mysql`) |
| `COPY ./opt/source-code`                          | Copies application code into the container                                           |
| `ENTRYPOINT ...`                                  | Launches the Flask app using the specified entrypoint                                |

**ğŸ› ï¸ Build & Push Commands:**

```bash
docker build . -f Dockerfile -t mumshad/my-custom-app
docker push mumshad/my-custom-app
```

- `docker build`: Constructs the image using the Dockerfile
- `-t`: Tags the image for Docker Hub
- `docker push`: Publishes the image to a remote registry

**ğŸš€ Runtime Behavior:**

When the container starts:

- It sets `FLASK_APP=/opt/source-code/app.py`
- Executes `flask run` to start the web server
- Serves the app from the copied source code

---

Excellent ğŸ‘‘ â€” now weâ€™re entering one of the most **fundamental and powerful** parts of Docker:
ğŸ‘‰ **Image Building** â€” the process that turns your code and a `Dockerfile` into a layered, immutable, versioned image.

Weâ€™ll go step-by-step â€” from the **historical context**, to **how Docker actually builds images internally**, to **how caching and intermediate containers work**, and weâ€™ll visualize it all ğŸ§±âš™ï¸

---

## ğŸ“œ **The Dockerfile**

The **Dockerfile** defines how to build the image â€” step-by-step.

Example:

```dockerfile
FROM python:3.11
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
EXPOSE 8080
CMD ["python", "app.py"]
```

Each instruction adds a **new read-only layer** to the image.

---

## âš™ï¸ **The Build Command**

The command to build an image is:

```bash
docker build -t myapp:1.0 .
```

### Breakdown:

| Part           | Meaning                                                       |
| -------------- | ------------------------------------------------------------- |
| `docker build` | Tells Docker to build an image                                |
| `-t myapp:1.0` | Tags the image (name:version)                                 |
| `.`            | Build context (current directory) â€” sent to the Docker daemon |

---

## ğŸ—‚ï¸ **Build Context**

The **build context** is everything inside the directory you pass (`.`).

- Docker **sends** this entire context (all files) to the **Docker daemon**.
- Itâ€™s stored temporarily under `/var/lib/docker/tmp/docker-builder*`.
- So files can be from current host or remote host.

---

<div align="center" style="background-color:#081C27; border-radius: 10px; border: 2px solid">
  <img src="image/1760386832432.png" alt="Docker Image" style="width: 80%;">
</div>

---

âš ï¸ So never pass `.` if your folder has too many unnecessary files â€” use `.dockerignore`.

Example `.dockerignore`:

```ini
node_modules
.git
*.log
```

> ğŸ“’ **Notes:**
>
> - you can build code from git repository
>
>   ```bash
>   docker build https://github.com/myaccount/myapp
>   # or
>   docker build https://github.com/myaccount/myapp#<branch>
>   # or
>   docker build https://github.com/myaccount/myapp:<folder>
>   ```
>
> - Docker file can be from any path with any name
>
>   ```bash
>   docker build -f ./config/Dockerfile.dev https://github.com/myaccount/myapp
>   ```
>
> ---

## ğŸ§  **Internal Build Process** (Under the Hood)

Letâ€™s visualize what happens when you run `docker build` ğŸ‘‡

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  <!-- look: handDrawn -->
  theme: dark
title: "Docker Build Internals"
---

flowchart TB
    %% Nodes
    A["ğŸ§‘â€ğŸ’» **1.Client**"]
    B["ğŸ“¦ **2.Send build context to Docker Daemon**"]
    C["ğŸ“œ **3.Daemon parses Dockerfile line by line**"]
    D["ğŸ§± **4.Each instruction â†’ Create container layer**"]
    E["ğŸ§Š **5.Commit container â†’ New read-only image layer**"]
    F["ğŸ—‚ï¸ **6.Store metadata in** _**/var/lib/docker/image/**_"]
    G["ğŸ·ï¸ **7.Final image tagged as myapp:latest**"]

    %% Flow
    A --> |docker build -t myapp| B --> C --> D --> E --> F --> G

    %% Styling
    classDef client fill:#ffcc99,stroke:#333,stroke-width:2px,color:#000,font-size:14px;
    classDef daemon fill:#99ccff,stroke:#333,stroke-width:2px,color:#000,font-size:14px;
    classDef layer fill:#ccffcc,stroke:#333,stroke-width:2px,color:#000,font-size:14px;
    classDef meta fill:#ff99cc,stroke:#333,stroke-width:2px,color:#000,font-size:14px;
    classDef tag fill:#ffff99,stroke:#333,stroke-width:2px,color:#000,font-size:14px;

    %% Assign classes
    class A client
    class B,C daemon
    class D,E layer
    class F meta
    class G tag
```

</div>

---

**ğŸ§© Step-by-Step: What Actually Happens:**

Letâ€™s take a simple Dockerfile:

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y python3
COPY app.py /usr/src/app/
CMD ["python3", "/usr/src/app/app.py"]
```

Hereâ€™s what Docker does internally ğŸ‘‡

- 1ï¸âƒ£ Pulls the base image (`ubuntu:22.04`)
- 2ï¸âƒ£ Starts a **temporary container** from that base
- 3ï¸âƒ£ Executes the `RUN` command inside the container
- 4ï¸âƒ£ Docker **commits** those filesystem changes as a **new read-only layer**
- 5ï¸âƒ£ Next instruction (`COPY`) repeats process â€” new temp container on top of last layer
- 6ï¸âƒ£ When all layers are built, Docker creates the **final image manifest**
- 7ï¸âƒ£ The image is saved in `/var/lib/docker/overlay2` and tagged

---

## ğŸ° **Build Layers and Caching**

Each instruction in the Dockerfile â†’ creates one **immutable layer**.

Docker caches each step so next builds are faster.

Example:

```dockerfile
FROM node:18
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "server.js"]
```

If only the last line changes, Docker **reuses** earlier cached layers.

---

### âš¡ Caching Flow

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "Layer Cache Reuse"
---
flowchart TD
    A["COPY package*.json ./"] --> B["RUN npm install"]
    B --> C["COPY . ."]
    C --> D["CMD node server.js"]

    A -->|Unchanged| A1["Use cached layer âœ…"]
    B -->|Unchanged| B1["Use cached layer âœ…"]
    C -->|Changed| C1["Rebuild layer âŒ"]
```

</div>

Docker uses **layer digests (SHA hashes)** to detect changes,  
if the instruction or any file it depends on changed â†’ cache invalidates.

> ğŸ’¡ Just like Git, each layer is immutable and stacked, you end up with something like 7 commits/layers, each with its own hash tree.

---

## ğŸ§  Temporary Containers and `commit`

During build:

- Each step runs in a temporary container.
- Once the step succeeds, Docker commits that container into a new image layer.

You can actually see those temp containers:

```bash
docker ps -a
```

They look like:

```ini
<missing>  "/bin/sh -c 'apt-gâ€¦"  Exited (0)  2 seconds ago
```

---

## ğŸ—‚ï¸ **Where Are Layers Stored?**

All layers live inside:

```ini
/var/lib/docker/overlay2/
```

Each layer has:

```ini
diff/       # The actual filesystem diff
lower/      # References to parent layers
merged/     # Runtime merge view
work/       # Temporary files during build
```

---

## âš™ï¸ **Multi-Stage Builds** (for Optimization)

Multi-stage builds let you create **smaller images** by separating build and runtime.

Example:

```dockerfile
# Stage 1: Build
FROM golang:1.22 AS builder
WORKDIR /src
COPY . .
RUN go build -o app main.go

# Stage 2: Runtime
FROM debian:12
COPY --from=builder /src/app /usr/local/bin/app
CMD ["app"]
```

âœ… Only the compiled binary is kept
âœ… No Go compiler or build dependencies in the final image

---

## ğŸ§© **Build Flags** You Should Know

| Flag               | Description               | Example                                  |
| ------------------ | ------------------------- | ---------------------------------------- |
| `-t`               | Tag the image             | `docker build -t myapp:v1 .`             |
| `-f`               | Specify Dockerfile path   | `docker build -f Dockerfile.dev .`       |
| `--no-cache`       | Ignore cache              | `docker build --no-cache -t myapp .`     |
| `--pull`           | Always pull base image    | `docker build --pull .`                  |
| `--build-arg`      | Pass build-time variables | `docker build --build-arg VERSION=1.2 .` |
| `--progress=plain` | Show detailed output      | `docker build --progress=plain .`        |

---

## âš”ï¸ **Build Arguments** vs **Environment Variables**

| Type       | Keyword | Available            | Use Case                               |
| ---------- | ------- | -------------------- | -------------------------------------- |
| Build-time | `ARG`   | Only during build    | Inject versions or secrets temporarily |
| Run-time   | `ENV`   | In container runtime | Used by running app                    |

Example:

```dockerfile
ARG APP_VERSION
ENV VERSION=$APP_VERSION
```

Usage:

```bash
docker build --build-arg APP_VERSION=1.0 .
```

---

## ğŸ§  **Docker BuildKit** (Modern Builder)

`BuildKit` is Dockerâ€™s new build engine â€” faster, secure, and supports parallelism.

Enable it:

```bash
export DOCKER_BUILDKIT=1
```

Benefits:

- Parallel build steps
- Better cache handling
- Secret mounting (`--secret`)
- Remote caching (`--cache-to`, `--cache-from`)

Example:

```bash
docker build --secret id=awscreds,src=~/.aws/credentials .
```

---

## ğŸ” **Debugging Builds**

### ğŸ‘‰ğŸ» See intermediate containers

```bash
docker ps -a | grep build
```

### ğŸ‘‰ğŸ» Keep intermediate containers (donâ€™t auto-remove)

```bash
docker build --rm=false .
```

### ğŸ‘‰ğŸ» Verbose output

```bash
docker build --progress=plain .
```

---

## ğŸ“‹ **Common Dockerfile Instructions Summary**

| Instruction  | Description              | Example                       |
| ------------ | ------------------------ | ----------------------------- |
| `FROM`       | Base image               | `FROM ubuntu:22.04`           |
| `RUN`        | Execute shell commands   | `RUN apt-get install -y curl` |
| `COPY`       | Copy files from context  | `COPY . /app`                 |
| `ADD`        | Copy with tar extraction | `ADD app.tar.gz /app`         |
| `WORKDIR`    | Change working dir       | `WORKDIR /app`                |
| `ENV`        | Set environment var      | `ENV PORT=8080`               |
| `EXPOSE`     | Document port            | `EXPOSE 8080`                 |
| `CMD`        | Default command          | `CMD ["node", "app.js"]`      |
| `ENTRYPOINT` | Main binary              | `ENTRYPOINT ["python"]`       |
| `ARG`        | Build-time var           | `ARG VERSION=1.0`             |
| `LABEL`      | Metadata                 | `LABEL maintainer="Ali"`      |

---

## ğŸ” **Internal Flow Summary**

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "Docker Image Build Flow"
---
flowchart TD
    A["docker build ."] --> B["Send context to daemon"]
    B --> C["Parse Dockerfile"]
    C --> D["For each instruction:"]
    D --> E["Create temp container"]
    E --> F["Execute step"]
    F --> G["Commit as new layer"]
    G --> H["Cache layer digest"]
    H --> I["Repeat for next instruction"]
    I --> J["Store manifest + metadata"]
    J --> K["Tag final image"]
```

</div>

---

## ğŸ’¡ **Practical Tips** & **Best Practices**

- âœ… Use **multi-stage builds** to keep images small
- âœ… Always start from **minimal base** (`alpine`, `distroless`)
- âœ… Put frequently changing steps **at the bottom** of Dockerfile
- âœ… Use `.dockerignore` to shrink context size
- âœ… Avoid `apt-get upgrade` or large unnecessary packages
- âœ… Use `--build-arg` for secrets only with `BuildKit + --secret`
- âœ… Label your images (`LABEL maintainer=... version=...`)

---

## ğŸ“„ **Quick Cheatsheet**

| Task                  | Command                                |
| --------------------- | -------------------------------------- |
| Build image           | `docker build -t app:v1 .`             |
| No cache build        | `docker build --no-cache .`            |
| Use custom Dockerfile | `docker build -f Dockerfile.dev .`     |
| Pass argument         | `docker build --build-arg KEY=value .` |
| Inspect built image   | `docker image inspect app:v1`          |
| Show image history    | `docker history app:v1`                |
