# 📜 **Dockerfile Instructions**

> “Every Dockerfile instruction = one layer of behavior.”

---

🧭 **Table of Contents:**

1. [📌 `FROM` — Base Image](#1)
2. [📌 `LABEL` — Metadata for Images](#2)
3. [📌 `ARG` — Build-Time Variables](#3)
4. [📌 `ENV` — Set Environment Variables](#4)
5. [⚔️ **ARG vs ENV**](#5)
6. [📌 `WORKDIR` — Set the Working Directory](#6)
7. [📌 `COPY` — Copy Files into Image (Build Time)](#7)
8. [📌 `ADD` — Copy with Superpowers](#8)
9. [⚔️ **COPY vs ADD**](#9)
10. [📌 `RUN` — Execute Shell Commands (Build Time)](#10)
11. [📌 `EXPOSE` — Document Container Ports](#11)
12. [📌 `USER` — Change Running User](#12)
13. [📌 `VOLUME` — Declare Storage Mount Points](#13)
14. [📌 `SHELL` — Default Shell for RUN, CMD, ENTRYPOINT](#14)
15. [📌 `ENTRYPOINT` — Main Container Command (Runtime)](#15)
16. [📌 `CMD` — Default Command (Runtime)](#16)
17. [⚔️ **CMD vs ENTRYPOINT**](#17)
18. [🍰 **Image Layering Recap**](#18)
19. [📄 **Quick Dockerfile Instruction Reference**](#19)
20. [💡 **Pro Best Practices**](#20)

---

## 📌 1. `FROM` — Base Image <a id="1"></a>

### 👉🏻 Purpose

- Defines the **starting point** (base image) of your build.
- It’s the **first instruction** in every Dockerfile (except multistage `COPY --from`).

### 📝 Example

```dockerfile
FROM ubuntu:22.04
```

This means:

- Docker will **pull `ubuntu:22.04`** (if not cached)
- All next instructions apply _on top of_ that base filesystem

You can also chain multiple stages:

```dockerfile
FROM golang:1.22 AS builder
FROM alpine:latest
COPY --from=builder /app /usr/local/bin/
```

### 🧠 Internally

- Each `FROM` creates a **new build stage** → previous one’s layers are finalized.

---

## 📌 2. `LABEL` — Metadata for Images <a id="2"></a>

### 👉🏻 Purpose

- Add key–value metadata to image for documentation or automation.

### 📝 Example

```dockerfile
LABEL maintainer="Ali <ali@example.com>" \
      version="1.0" \
      description="Flask web app"
```

### 💡 Tips

Visible in:

```bash
docker inspect myapp | grep Label
```

Used by:

- Docker Hub
- CI/CD metadata scanners
- Kubernetes image labels

---

## 📌 3. `ARG` — Build-Time Variables<a id="3"></a>

### 👉🏻 Purpose

- Pass build-time variables to customize builds (not available at runtime).

### 📝 Example

```dockerfile
ARG APP_VERSION=1.0
RUN echo "Building version $APP_VERSION"
```

At build:

```bash
docker build --build-arg APP_VERSION=2.0 .
```

### 💡 Tips

- After the build finishes, ARG values **disappear** — they are **not kept in the image**.

---

## 📌 4. `ENV` — Set Environment Variables<a id="4"></a>

### 👉🏻 Purpose

- Defines environment variables in the image (available at runtime).

### 📝 Example

```dockerfile
ENV APP_ENV=production
ENV PATH="/custom/bin:$PATH"
```

At runtime, you can verify:

```bash
docker run myapp env
```

### 💡 Tips

- those **Available during container runtime**, but not in build unless explicitly referenced later in same Dockerfile.

---

## ⚔️ 5. **ARG vs ENV**<a id="5"></a>

| Feature                     | `ARG`           | `ENV`                   |
| --------------------------- | --------------- | ----------------------- |
| Availability                | Build-time only | Runtime                 |
| Default in Dockerfile       | ✅ Yes          | ✅ Yes                  |
| Can override at runtime     | ❌ No           | ✅ Yes (`-e VAR=value`) |
| Visible in `docker inspect` | ❌ No           | ✅ Yes                  |

---

## 📌 6. `WORKDIR` — Set the Working Directory<a id="16"></a><a id="6"></a>

### 👉🏻 Purpose

- Sets the default directory for all subsequent instructions (`RUN`, `CMD`, `COPY`).

### 📝 Example

```dockerfile
WORKDIR /app
COPY . .
RUN npm install
```

### 💡 Tips

- If directory doesn’t exist → Docker automatically creates it.
- Safer than `RUN cd /app` — because `RUN` doesn’t persist across layers.

---

## 📌 7. `COPY` — Copy Files into Image (Build Time)<a id="7"></a>

### 👉🏻 Purpose

- Copies files/folders from your **build context** → image filesystem.

### ✅ Syntax

```dockerfile
COPY <src> <dest>
```

### 📝 Examples

**🧪 Example 1: Copy Folder _Into_ Target Folder**

```dockerfile
COPY myfolder /app/
```

- If `myfolder` contains `a.txt`, `b.txt`, `c/`
- Result: `/app/myfolder/a.txt`, `/app/myfolder/b.txt`, `/app/myfolder/c/`

👉🏻 The **entire folder** is copied **under** `/app/`

---

**🧪 Example 2: Copy Contents _Into_ Target Folder:**

```dockerfile
COPY myfolder/ /app/
```

- Trailing slash on `myfolder/` means: copy **contents only**
- Result: `/app/a.txt`, `/app/b.txt`, `/app/c/`

👉🏻 The **files inside** `myfolder` are copied directly into `/app/`

---

| Source Path | Behavior                    |
| ----------- | --------------------------- |
| `myfolder`  | Copies folder into target   |
| `myfolder/` | Copies contents into target |

### 🧠 Internally

Docker:

- Takes file from context (the directory you passed to `docker build`)
- Adds it as a new layer inside `/usr/src/app/`

### 💡 Tips

- **Source path: trailing `/` is ignored.**

  - `COPY something/ /dest` **≡** `COPY something /dest`.
  - > If **source is a directory**, Docker **copies its contents**, not the directory itself.

- **Destination path: trailing `/` matters.**

  - `COPY file.txt /abs` creates `/abs` **as a file**;
  - `COPY file.txt /abs/` creates `/abs/file.txt`.
  - > If you copy **multiple sources**, destination **must be a directory and end with `/`**.

- Only works within the **build context**
- **Build context rules** (you can’t copy from `..`): sources are resolved **relative to the build context**.

- Use `.dockerignore` to avoid copying unnecessary files

- **Common Pitfall:**

  - If you modify a single file → Docker invalidates all later cached layers.
  - To optimize:

    ```dockerfile
    COPY requirements.txt .
    RUN pip install -r requirements.txt
    COPY . .
    ```

---

## 📌 8. `ADD` — Copy with Superpowers<a id="8"></a>

### 👉🏻 Purpose

- Like `COPY`, but with **extra features**:

  - Can extract compressed files (like `.tar.gz`)
  - Can copy directly from a **URL**

### 📝 Example

```dockerfile
ADD app.tar.gz /usr/src/app/
ADD https://example.com/app.zip /tmp/
```

### 💡 Tips

⚠️ Recommended:

> Use `COPY` unless you **really need** auto-extraction or URL.

---

## ⚔️ 9. **COPY vs ADD**<a id="9"></a>

| Feature                 | `COPY`                 | `ADD`                                |
| ----------------------- | ---------------------- | ------------------------------------ |
| **Purpose**             | Copy files/directories | Copy + extra features                |
| **Source types**        | Local files only       | Local files + remote URLs + archives |
| **Extracts archives?**  | ❌ No                  | ✅ Yes (`.tar`, `.gz`, etc.)         |
| **Downloads from URL?** | ❌ No                  | ✅ Yes (e.g., `ADD http://...`)      |
| **Preferred for**       | Simplicity, clarity    | Special cases (auto-extract, remote) |

---

**✅ Best Practice:**

> Use `COPY` by default — it’s cleaner and more predictable.  
> Use `ADD` **only** when you need archive extraction or remote downloads.

---

## 📌 10. `RUN` — Execute Shell Commands (Build Time)<a id="10"></a>

### 👉🏻 Purpose

- Runs commands in a temporary container **during image build**, and commits the filesystem changes as a **new image layer**.

### 📝 Example

```dockerfile
RUN apt-get update && apt-get install -y curl
```

### 🧠 Internally

- Docker creates a **temp container** from the current image
- Runs `/bin/sh -c "apt-get update..."` inside it
- Commits changes into a new read-only layer
- Removes the container

---

### 💡 Tips

- ✅ Combine related commands in one line to minimize layers:

  ```dockerfile
  RUN apt-get update && apt-get install -y python3 && rm -rf /var/lib/apt/lists/*
  ```

- ✅ Use `\` for readability:

  ```dockerfile
  RUN apt-get update && \
      apt-get install -y curl git && \
      rm -rf /var/lib/apt/lists/*
  ```

---

## 📌 11. `EXPOSE` — Document Container Ports<a id="11"></a>

### 👉🏻 Purpose

- Declares which port the container _intends_ to listen on.

  ```dockerfile
  EXPOSE 8080
  ```

### 💡 Tips

- This does **not** actually publish the port; it’s just metadata.
- You must still run:

  ```bash
  docker run -p 8080:8080 myapp
  ```

- Useful for documentation and automatic port mapping in Compose or Kubernetes.

---

## 📌 12. `USER` — Change Running User<a id="12"></a>

### 👉🏻 Purpose

- Specifies which user the container runs as.

### 📝 Example

```dockerfile
USER appuser
```

### 💡 Tips

- By default, containers run as `root` (inside container level, not host level).
- For security, create and switch user:

  ```dockerfile
  RUN useradd -m appuser
  USER appuser
  ```

---

## 📌 13. `VOLUME` — Declare Storage Mount Points<a id="13"></a>

### 👉🏻 Purpose

- Specifies directories in the container meant to persist or be shared.

### 📝 Example

```dockerfile
VOLUME ["/data"]
```

When container runs:

- Docker automatically creates `/data` as a volume.
- Data written here is stored under:

  ```ini
  /var/lib/docker/volumes/<volume-id>/_data
  ```

✅ Protects data from deletion when container removed.

---

## 📌 14. `SHELL` — Default Shell for RUN, CMD, ENTRYPOINT<a id="14"></a>

### 👉🏻 Purpose

- Change the default shell used to interpret commands.

### 📝 Example

- Default on Linux:

  ```dockerfile
  SHELL ["/bin/sh", "-c"]
  ```

- To use Bash:

  ```dockerfile
  SHELL ["/bin/bash", "-c"]
  ```

- Useful in Windows containers:

  ```dockerfile
  SHELL ["powershell", "-Command"]
  ```

---

## 📌 15. `ENTRYPOINT` — Main Container Command (Runtime)<a id="15"></a>

### 👉🏻 Purpose

- Defines the **main executable** of the container — cannot be overridden easily.

### 📝 Example

```dockerfile
ENTRYPOINT ["python3", "app.py"]
```

### 💡 Tips

- If you pass extra args, they’re **appended** to ENTRYPOINT:

  ```bash
  docker run myapp --port 8080
  ```

- Result executed inside container:

  ```ini
  python3 app.py --port 8080
  ```

---

## 📌 16. `CMD` — Default Command (Runtime)<a id="16"></a>

### 👉🏻 Purpose

- Defines the **default command** to run when the container starts.

### 📝 Example

```dockerfile
CMD ["python3", "app.py"]
```

### 💡 Tips

- If you provide another command at runtime, it **overrides CMD**:

  ```bash
  docker run myapp echo "Hello"
  ```

- Then CMD is ignored.

---

## ⚔️ 17. **CMD vs ENTRYPOINT**<a id="17"></a>

This is one of the **most misunderstood** pairs.
Let’s break it down clearly:

| Behavior                            | `CMD`                                | `ENTRYPOINT`           |
| ----------------------------------- | ------------------------------------ | ---------------------- |
| Purpose                             | Default arguments / command          | Fixed main process     |
| Overridden by `docker run` command? | ✅ Yes                               | ❌ No (args appended)  |
| Common usage                        | Default behavior                     | Always-run binary      |
| Example                             | `CMD ["nginx", "-g", "daemon off;"]` | `ENTRYPOINT ["nginx"]` |

---

**🧩 Combine ENTRYPOINT + CMD:**

The best practice:

```dockerfile
ENTRYPOINT ["python3", "app.py"]
CMD ["--port", "8080"]
```

If you run:

```bash
docker run myapp --debug
```

It executes:

```ini
python3 app.py --debug
```

✅ CMD acts as **default args**  
✅ ENTRYPOINT acts as **core executable**

---

**🔬 Visual Summary:**

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "CMD vs ENTRYPOINT Flow"
---
flowchart LR
    A["docker run myapp [args]"] --> B{"ENTRYPOINT defined?"}
    B -->|Yes| C["Use ENTRYPOINT as base command"]
    B -->|No| D["Use CMD as full command"]
    C --> E{"CMD exists?"}
    E -->|Yes| F["Append CMD as default args"]
    E -->|No| G["Run ENTRYPOINT only"]
```

---

## 🍰 18. **Image Layering Recap**<a id="18"></a>

Each instruction (except `FROM`, `ARG`, `LABEL`) creates a **new immutable layer**.  
Layers are **stacked** to form your final image.

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "Docker Image Layer Stack"
---
graph TB

    A["Layer 1: FROM ubuntu:22.04"]
    B["Layer 2: RUN apt-get install"]
    C["Layer 3: COPY app/"]
    D["Layer 4: CMD"]
    A --> B --> C --> D
```

</div>

- ✅ Docker reuses unchanged layers via cache
- ✅ Each layer is read-only
- ✅ Container adds a final **read-write layer** when run

---

## 📄 19. **Quick Dockerfile Instruction Reference**<a id="19"></a>

| Instruction  | Time        | Creates Layer | Notes                               |
| ------------ | ----------- | ------------- | ----------------------------------- |
| `FROM`       | Build start | ✅            | Defines base image                  |
| `LABEL`      | Build       | ✅            | Metadata                            |
| `ARG`        | Build       | ❌            | Build-time only                     |
| `ENV`        | Build+Run   | ✅            | Persists in runtime                 |
| `WORKDIR`    | Build       | ✅            | Sets working directory              |
| `COPY`       | Build       | ✅            | Copies files into image             |
| `ADD`        | Build       | ✅            | Like COPY but can extract URLs/tars |
| `RUN`        | Build       | ✔️            | Executes shell command              |
| `EXPOSE`     | Build       | ✅            | Documentation                       |
| `USER`       | Build+Run   | ✅            | Sets user context                   |
| `VOLUME`     | Runtime     | ✅            | Mount points                        |
| `SHELL`      | Build       | ✅            | Changes shell interpreter           |
| `ENTRYPOINT` | Runtime     | ✅            | Primary executable                  |
| `CMD`        | Runtime     | ✅            | Default runtime command             |

---

## 💡 20. **Pro Best Practices**<a id="20"></a>

- ✅ Use one `RUN` per logical operation (for cache efficiency).
- ✅ Put least changing instructions **at the top**.
- ✅ Use `COPY` not `ADD`, unless extracting archives.
- ✅ Always specify explicit versions in `FROM`.
- ✅ Combine `ENTRYPOINT` + `CMD` for flexibility.
- ✅ Create non-root users with `USER` for security.
- ✅ Always use `.dockerignore` to minimize context.
