# ğŸ“œ **Dockerfile Instructions**

> â€œEvery Dockerfile instruction = one layer of behavior.â€

---

## ğŸ“Œ `FROM` â€” Base Image

### ğŸ‘‰ğŸ» Purpose

- Defines the **starting point** (base image) of your build.
- Itâ€™s the **first instruction** in every Dockerfile (except multistage `COPY --from`).

### ğŸ“ Example

```dockerfile
FROM ubuntu:22.04
```

This means:

- Docker will **pull `ubuntu:22.04`** (if not cached)
- All next instructions apply _on top of_ that base filesystem

You can also chain multiple stages:

```dockerfile
FROM golang:1.22 AS builder
FROM alpine:latest
COPY --from=builder /app /usr/local/bin/
```

### ğŸ§  Internally

- Each `FROM` creates a **new build stage** â†’ previous oneâ€™s layers are finalized.

---

## ğŸ“Œ `LABEL` â€” Metadata for Images

### ğŸ‘‰ğŸ» Purpose

- Add keyâ€“value metadata to image for documentation or automation.

### ğŸ“ Example

```dockerfile
LABEL maintainer="Ali <ali@example.com>" \
      version="1.0" \
      description="Flask web app"
```

### ğŸ’¡ Tips

Visible in:

```bash
docker inspect myapp | grep Label
```

Used by:

- Docker Hub
- CI/CD metadata scanners
- Kubernetes image labels

---

## ğŸ“Œ `ARG` â€” Build-Time Variables

### ğŸ‘‰ğŸ» Purpose

- Pass build-time variables to customize builds (not available at runtime).

### ğŸ“ Example

```dockerfile
ARG APP_VERSION=1.0
RUN echo "Building version $APP_VERSION"
```

At build:

```bash
docker build --build-arg APP_VERSION=2.0 .
```

### ğŸ’¡ Tips

- After the build finishes, ARG values **disappear** â€” they are **not kept in the image**.

---

## ğŸ“Œ `ENV` â€” Set Environment Variables

### ğŸ‘‰ğŸ» Purpose

- Defines environment variables in the image (available at runtime).

### ğŸ“ Example

```dockerfile
ENV APP_ENV=production
ENV PATH="/custom/bin:$PATH"
```

At runtime, you can verify:

```bash
docker run myapp env
```

### ğŸ’¡ Tips

- those **Available during container runtime**, but not in build unless explicitly referenced later in same Dockerfile.

---

## âš”ï¸ **ARG vs ENV**

| Feature                     | `ARG`           | `ENV`                   |
| --------------------------- | --------------- | ----------------------- |
| Availability                | Build-time only | Runtime                 |
| Default in Dockerfile       | âœ… Yes          | âœ… Yes                  |
| Can override at runtime     | âŒ No           | âœ… Yes (`-e VAR=value`) |
| Visible in `docker inspect` | âŒ No           | âœ… Yes                  |

---

## ğŸ“Œ `WORKDIR` â€” Set the Working Directory

### ğŸ‘‰ğŸ» Purpose

- Sets the default directory for all subsequent instructions (`RUN`, `CMD`, `COPY`).

### ğŸ“ Example

```dockerfile
WORKDIR /app
COPY . .
RUN npm install
```

### ğŸ’¡ Tips

- If directory doesnâ€™t exist â†’ Docker automatically creates it.
- Safer than `RUN cd /app` â€” because `RUN` doesnâ€™t persist across layers.

---

## ğŸ“Œ `COPY` â€” Copy Files into Image (Build Time)

### ğŸ‘‰ğŸ» Purpose

- Copies files/folders from your **build context** â†’ image filesystem.

### ğŸ“ Example

```dockerfile
COPY app.py /usr/src/app/
```

### ğŸ§  Internally

Docker:

- Takes file from context (the directory you passed to `docker build`)
- Adds it as a new layer inside `/usr/src/app/`

### ğŸ’¡ Tips

- Only works within the **build context**
- Use `.dockerignore` to avoid copying unnecessary files

- **Common Pitfall:**

  - If you modify a single file â†’ Docker invalidates all later cached layers.
  - To optimize:

    ```dockerfile
    COPY requirements.txt .
    RUN pip install -r requirements.txt
    COPY . .
    ```

---

## ğŸ“Œ `ADD` â€” Copy with Superpowers

### ğŸ‘‰ğŸ» Purpose

- Like `COPY`, but with **extra features**:

  - Can extract compressed files (like `.tar.gz`)
  - Can copy directly from a **URL**

### ğŸ“ Example

```dockerfile
ADD app.tar.gz /usr/src/app/
ADD https://example.com/app.zip /tmp/
```

### ğŸ’¡ Tips

âš ï¸ Recommended:

> Use `COPY` unless you **really need** auto-extraction or URL.

---

## âš”ï¸ **COPY vs ADD**

| Feature                 | `COPY`                 | `ADD`                                |
| ----------------------- | ---------------------- | ------------------------------------ |
| **Purpose**             | Copy files/directories | Copy + extra features                |
| **Source types**        | Local files only       | Local files + remote URLs + archives |
| **Extracts archives?**  | âŒ No                  | âœ… Yes (`.tar`, `.gz`, etc.)         |
| **Downloads from URL?** | âŒ No                  | âœ… Yes (e.g., `ADD http://...`)      |
| **Preferred for**       | Simplicity, clarity    | Special cases (auto-extract, remote) |

---

**âœ… Best Practice:**

> Use `COPY` by default â€” itâ€™s cleaner and more predictable.  
> Use `ADD` **only** when you need archive extraction or remote downloads.

---

## ğŸ“Œ `RUN` â€” Execute Shell Commands (Build Time)

### ğŸ‘‰ğŸ» Purpose

- Runs commands in a temporary container **during image build**, and commits the filesystem changes as a **new image layer**.

### ğŸ“ Example

```dockerfile
RUN apt-get update && apt-get install -y curl
```

### ğŸ§  Internally

- Docker creates a **temp container** from the current image
- Runs `/bin/sh -c "apt-get update..."` inside it
- Commits changes into a new read-only layer
- Removes the container

---

### ğŸ’¡ Tips

- âœ… Combine related commands in one line to minimize layers:

  ```dockerfile
  RUN apt-get update && apt-get install -y python3 && rm -rf /var/lib/apt/lists/*
  ```

- âœ… Use `\` for readability:

  ```dockerfile
  RUN apt-get update && \
      apt-get install -y curl git && \
      rm -rf /var/lib/apt/lists/*
  ```

---

## ğŸ“Œ `EXPOSE` â€” Document Container Ports

### ğŸ‘‰ğŸ» Purpose

- Declares which port the container _intends_ to listen on.

  ```dockerfile
  EXPOSE 8080
  ```

### ğŸ’¡ Tips

- This does **not** actually publish the port; itâ€™s just metadata.
- You must still run:

  ```bash
  docker run -p 8080:8080 myapp
  ```

- Useful for documentation and automatic port mapping in Compose or Kubernetes.

---

## ğŸ“Œ `USER` â€” Change Running User

### ğŸ‘‰ğŸ» Purpose

- Specifies which user the container runs as.

### ğŸ“ Example

```dockerfile
USER appuser
```

### ğŸ’¡ Tips

- By default, containers run as `root` (inside container level, not host level).
- For security, create and switch user:

  ```dockerfile
  RUN useradd -m appuser
  USER appuser
  ```

---

## ğŸ“Œ `VOLUME` â€” Declare Storage Mount Points

### ğŸ‘‰ğŸ» Purpose

- Specifies directories in the container meant to persist or be shared.

### ğŸ“ Example

```dockerfile
VOLUME ["/data"]
```

When container runs:

- Docker automatically creates `/data` as a volume.
- Data written here is stored under:

  ```ini
  /var/lib/docker/volumes/<volume-id>/_data
  ```

âœ… Protects data from deletion when container removed.

---

## ğŸ“Œ `SHELL` â€” Default Shell for RUN, CMD, ENTRYPOINT

### ğŸ‘‰ğŸ» Purpose

- Change the default shell used to interpret commands.

### ğŸ“ Example

- Default on Linux:

  ```dockerfile
  SHELL ["/bin/sh", "-c"]
  ```

- To use Bash:

  ```dockerfile
  SHELL ["/bin/bash", "-c"]
  ```

- Useful in Windows containers:

  ```dockerfile
  SHELL ["powershell", "-Command"]
  ```

---

## ğŸ“Œ `ENTRYPOINT` â€” Main Container Command (Runtime)

### ğŸ‘‰ğŸ» Purpose

- Defines the **main executable** of the container â€” cannot be overridden easily.

### ğŸ“ Example

```dockerfile
ENTRYPOINT ["python3", "app.py"]
```

### ğŸ’¡ Tips

- If you pass extra args, theyâ€™re **appended** to ENTRYPOINT:

  ```bash
  docker run myapp --port 8080
  ```

- Result executed inside container:

  ```ini
  python3 app.py --port 8080
  ```

---

## ğŸ“Œ `CMD` â€” Default Command (Runtime)

### ğŸ‘‰ğŸ» Purpose

- Defines the **default command** to run when the container starts.

### ğŸ“ Example

```dockerfile
CMD ["python3", "app.py"]
```

### ğŸ’¡ Tips

- If you provide another command at runtime, it **overrides CMD**:

  ```bash
  docker run myapp echo "Hello"
  ```

- Then CMD is ignored.

---

## âš”ï¸ **CMD vs ENTRYPOINT**

This is one of the **most misunderstood** pairs.
Letâ€™s break it down clearly:

| Behavior                            | `CMD`                                | `ENTRYPOINT`           |
| ----------------------------------- | ------------------------------------ | ---------------------- |
| Purpose                             | Default arguments / command          | Fixed main process     |
| Overridden by `docker run` command? | âœ… Yes                               | âŒ No (args appended)  |
| Common usage                        | Default behavior                     | Always-run binary      |
| Example                             | `CMD ["nginx", "-g", "daemon off;"]` | `ENTRYPOINT ["nginx"]` |

---

**ğŸ§© Combine ENTRYPOINT + CMD:**

The best practice:

```dockerfile
ENTRYPOINT ["python3", "app.py"]
CMD ["--port", "8080"]
```

If you run:

```bash
docker run myapp --debug
```

It executes:

```ini
python3 app.py --debug
```

âœ… CMD acts as **default args**  
âœ… ENTRYPOINT acts as **core executable**

---

**ğŸ”¬ Visual Summary:**

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "CMD vs ENTRYPOINT Flow"
---
flowchart LR
    A["docker run myapp [args]"] --> B{"ENTRYPOINT defined?"}
    B -->|Yes| C["Use ENTRYPOINT as base command"]
    B -->|No| D["Use CMD as full command"]
    C --> E{"CMD exists?"}
    E -->|Yes| F["Append CMD as default args"]
    E -->|No| G["Run ENTRYPOINT only"]
```

---

## ğŸ° **Image Layering Recap**

Each instruction (except `FROM`, `ARG`, `LABEL`) creates a **new immutable layer**.  
Layers are **stacked** to form your final image.

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "Docker Image Layer Stack"
---
graph TB

    A["Layer 1: FROM ubuntu:22.04"]
    B["Layer 2: RUN apt-get install"]
    C["Layer 3: COPY app/"]
    D["Layer 4: CMD"]
    A --> B --> C --> D
```

</div>

- âœ… Docker reuses unchanged layers via cache
- âœ… Each layer is read-only
- âœ… Container adds a final **read-write layer** when run

---

## ğŸ“„ **Quick Dockerfile Instruction Reference**

| Instruction  | Time        | Creates Layer | Notes                               |
| ------------ | ----------- | ------------- | ----------------------------------- |
| `FROM`       | Build start | âœ…            | Defines base image                  |
| `LABEL`      | Build       | âœ…            | Metadata                            |
| `ARG`        | Build       | âŒ            | Build-time only                     |
| `ENV`        | Build+Run   | âœ…            | Persists in runtime                 |
| `WORKDIR`    | Build       | âœ…            | Sets working directory              |
| `COPY`       | Build       | âœ…            | Copies files into image             |
| `ADD`        | Build       | âœ…            | Like COPY but can extract URLs/tars |
| `RUN`        | Build       | âœ”ï¸            | Executes shell command              |
| `EXPOSE`     | Build       | âœ…            | Documentation                       |
| `USER`       | Build+Run   | âœ…            | Sets user context                   |
| `VOLUME`     | Runtime     | âœ…            | Mount points                        |
| `SHELL`      | Build       | âœ…            | Changes shell interpreter           |
| `ENTRYPOINT` | Runtime     | âœ…            | Primary executable                  |
| `CMD`        | Runtime     | âœ…            | Default runtime command             |

---

## ğŸ’¡ **Pro Best Practices**

- âœ… Use one `RUN` per logical operation (for cache efficiency).
- âœ… Put least changing instructions **at the top**.
- âœ… Use `COPY` not `ADD`, unless extracting archives.
- âœ… Always specify explicit versions in `FROM`.
- âœ… Combine `ENTRYPOINT` + `CMD` for flexibility.
- âœ… Create non-root users with `USER` for security.
- âœ… Always use `.dockerignore` to minimize context.

---

Would you like me next to explain **Docker Image History and Layer Caching Internals** â€” showing how each Dockerfile instruction translates into actual filesystem layers (`diff`, `lower`, `merged`) and how Docker optimizes builds via content hashes?
