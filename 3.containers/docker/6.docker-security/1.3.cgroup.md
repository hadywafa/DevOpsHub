# âš™ï¸ **Docker Security â€” Control Groups (Cgroups) & Resource Limits**

> ğŸ§  _How Docker ensures no single container eats all your host resources â€” explained with Linux internals, visuals, and hands-on examples._

---

## ğŸ“– **What Are Control Groups (cgroups)?**

**Linux Control Groups (cgroups)** are a **kernel feature** that lets you:

- **Limit** how much CPU, memory, disk I/O, or network a process can use
- **Prioritize** some workloads over others
- **Isolate** resource usage between groups of processes

Cgroups are the _â€œresource policeâ€_ for containers ğŸš“
They make sure one misbehaving container doesnâ€™t choke your entire host.

---

### ğŸ§  Core Concept

When Docker starts a container, it groups its processes under a **cgroup hierarchy**.
Each hierarchy controls a specific type of resource:

- CPU â†’ `cpu` or `cpu,cpuacct`
- Memory â†’ `memory`
- Block I/O â†’ `blkio`
- Network â†’ `net_cls`, `net_prio`

Cgroups apply **quotas and limits** that the Linux kernel enforces.

---

### ğŸ§© Docker + Cgroups Integration

Docker sits between your containers and the Linux kernel:

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart TD
    A["Container (nginx, redis, etc)"] --> B["Docker Daemon"]
    B --> C["Linux Cgroups"]
    C --> D["Kernel Schedulers (CPU, Memory, I/O)"]
```

</div>

When you set flags like `--cpus` or `--memory`,
Docker writes those values into cgroup files under `/sys/fs/cgroup`.

---

## ğŸ·ï¸ **Cgroups Versions â€” v1 vs v2**

| Version | Introduced                 | Key Difference                    | Docker Support                   |
| ------- | -------------------------- | --------------------------------- | -------------------------------- |
| **v1**  | Older (since Linux 2.6)    | Separate hierarchies per resource | âœ… Full                          |
| **v2**  | Unified hierarchy (modern) | Cleaner, more consistent model    | âœ… Supported since Docker 20.10+ |

To check which version your system uses:

```bash
mount | grep cgroup
```

If you see `cgroup2`, youâ€™re on v2 (default on modern Ubuntu/Fedora).

---

## ğŸ­ **Resource Control Types**

| Resource  | Docker Flag                               | Description                    |
| --------- | ----------------------------------------- | ------------------------------ |
| CPU       | `--cpus`, `--cpu-shares`, `--cpuset-cpus` | Limit or schedule CPU usage    |
| Memory    | `--memory`, `--memory-swap`               | Limit RAM + optional swap      |
| Block I/O | `--blkio-weight`                          | Control disk I/O priority      |
| Network   | `--network` + `tc`                        | Manage bandwidth caps manually |

---

## ğŸ§  **1. CPU Resource Limits** (CFS Scheduling)

### â‰ï¸ How Linux Shares CPU Time

Linux uses the **Completely Fair Scheduler (CFS)**.  
Imagine one CPU core like a pizza ğŸ• â€”
CFS divides it into small time slices (microseconds) and shares them _fairly_ among processes.

Without limits, containers compete freely â€” whoeverâ€™s hungriest gets more pizza.

---

### âš™ï¸ CPU Shares â€” Relative Weights

CPU shares (`--cpu-shares`) define **relative priority**, not hard caps.

| Container | CPU Shares | Relative CPU % (if 2 containers) |
| --------- | ---------- | -------------------------------- |
| webapp1   | 1024       | 66%                              |
| webapp2   | 512        | 33%                              |

Command:

```bash
docker run --cpu-shares=512 --name webapp2 nginx
```

ğŸ§  If webapp1 is idle, webapp2 can still take 100% of CPU.

---

#### ğŸ“Š Visualizing CPU Shares

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart LR
  A["CPU Scheduler (CFS)"] --> B["webapp1 (1024 shares)"]
  A --> C["webapp2 (512 shares)"]
  B:::good
  C:::bad
  classDef good fill:#00aaff,stroke:#000;
  classDef bad fill:#ffaa00,stroke:#000;
```

</div>

Each container gets time slices proportional to its weight.

---

### âš™ï¸ Pinning to Specific Cores â€” `--cpuset-cpus`

Use **CPU pinning** to bind a container to certain cores.

```bash
docker run --cpuset-cpus="0-1" nginx
```

This runs the container only on cores 0 and 1.
Useful for **real-time workloads** or **NUMA-aware systems**.

You can verify:

```bash
docker inspect <container_id> | grep CpusetCpus
```

---

### âš™ï¸ Hard CPU Limit â€” `--cpus`

For a _strict_ CPU cap, use:

```bash
docker run --cpus=2.5 nginx
```

Meaning:

- On a 4-core host, the container can use max 2.5 cores (â‰ˆ62.5% CPU).
- The rest is reserved for other containers or system processes.

You can also update running containers:

```bash
docker update --cpus=2.5 nginx
```

---

#### âš ï¸ Without CPU limitsâ€¦

A misbehaving container can:

- Hog CPU â†’ Freeze the host
- Starve the Docker daemon itself
- Cause latency in other workloads

Always apply sane CPU quotas in production.

---

### ğŸ§© CPU Flags Summary

| Flag            | Description                | Example               |
| --------------- | -------------------------- | --------------------- |
| `--cpu-shares`  | Relative scheduling weight | `--cpu-shares=512`    |
| `--cpuset-cpus` | Bind to specific cores     | `--cpuset-cpus="0,1"` |
| `--cpus`        | Hard CPU limit             | `--cpus=1.5`          |

---

## ğŸ§  **2. Memory Resource Limits** (OOM Prevention)

### â‰ï¸ Why Memory Limits Matter

Unlike CPU, memory cannot be â€œshared fairly.â€
If a process exceeds system RAM, the kernel invokes the **OOM Killer**,
which terminates random processes (even your Docker daemon ğŸ˜±).

To prevent this, Docker uses the `memory` cgroup to **enforce limits**.

---

### âš™ï¸ Hard Memory Limit â€” `--memory`

This sets a **strict RAM ceiling**.

Example:

```bash
docker run --memory=512m nginx
```

If the container tries to use >512 MB â†’ ğŸ’¥ it gets killed instantly with an OOM error.

> Memory limits are **enforced**, not throttled.

---

### âš™ï¸ Swap Control â€” `--memory-swap`

You can allow or disable swap explicitly.

| Configuration      | Description              | Example                            |
| ------------------ | ------------------------ | ---------------------------------- |
| Disable swap       | Equal memory and swap    | `--memory=512m --memory-swap=512m` |
| Allow limited swap | Add some disk swap space | `--memory=512m --memory-swap=768m` |
| Unlimited swap     | Dangerous!               | `--memory=512m --memory-swap=-1`   |

---

#### ğŸ§© Example

```bash
docker run \
  --memory=512m \
  --memory-swap=768m \
  nginx
```

ğŸ‘‰ Total memory budget = 512 MB RAM + 256 MB swap.

---

### âš™ï¸ Soft Memory Reservation â€” `--memory-reservation`

Set a â€œsoft floorâ€ â€” a memory guarantee during contention.

```bash
docker run \
  --memory=200m \
  --memory-reservation=100m \
  nginx
```

Meaning:

- Guaranteed 100 MB
- Can grow to 200 MB if free memory exists

---

### âš™ï¸ Memory Swappiness â€” `--memory-swappiness`

Controls how aggressively the kernel swaps memory to disk (0â€“100).

```bash
docker run --memory=512m --memory-swappiness=10 nginx
```

Lower values = prefer RAM, minimize swap (better performance).

---

### ğŸ§© Memory Flags Summary

| Flag                   | Description            | Example                            |
| ---------------------- | ---------------------- | ---------------------------------- |
| `--memory`             | Hard RAM limit         | `--memory=200m`                    |
| `--memory-reservation` | Soft limit (guarantee) | `--memory-reservation=100m`        |
| `--memory-swap`        | RAM + swap total limit | `--memory=200m --memory-swap=512m` |
| `--memory-swappiness`  | Swap aggressiveness    | `--memory-swappiness=10`           |

---

## âœğŸ» **Practical Demo** â€” CPU & Memory Limits

### ğŸ”¹ Default (No Limits)

```bash
docker run -d --name=default ubuntu sleep 1000
docker inspect default | grep -i mem
```

Output shows all `0` â€” meaning unlimited.

---

### ğŸ”¹ Hard Limit (200MB RAM)

```bash
docker run -d --name=limited --memory=200m ubuntu sleep 1000
docker inspect limited | grep -i mem
```

---

### ğŸ”¹ Unlimited Swap

```bash
docker run -d --name=swappy --memory=200m --memory-swap=-1 ubuntu sleep 1000
```

---

### ğŸ”¹ Soft Reservation

```bash
docker run -d \
  --name=softmem \
  --memory=200m \
  --memory-reservation=100m \
  ubuntu sleep 1000
```

---

### ğŸ”¹ CPU Limit (1 Core)

```bash
docker run -d --name=cpu1 --cpus=1 ubuntu sleep 1000
docker inspect cpu1 | grep NanoCpus
```

---

### ğŸ”¹ Pinning to Core 0

```bash
docker run -d --name=core0 --cpuset-cpus="0" ubuntu sleep 1000
```

---

## âœ… **Best Practices** for Production

| Category                    | Recommendation              | Reason                      |
| --------------------------- | --------------------------- | --------------------------- |
| ğŸ§± Always set limits        | `--cpus`, `--memory`        | Prevent resource starvation |
| ğŸ§  Tune swap carefully      | Avoid `-1` unless necessary | Prevent slow I/O            |
| ğŸ§ Use reservations         | Combine with Kubernetes QoS | Guarantee baseline          |
| ğŸ“Š Monitor usage            | `docker stats`, Prometheus  | Detect bottlenecks early    |
| ğŸš« Avoid overcommit         | Donâ€™t over-allocate CPU     | Ensures predictability      |
| âš¡ Use namespaces + cgroups | Together = full isolation   | Security + fairness         |

---

## ğŸ–¼ï¸ **Diagram**: Full Isolation Flow

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart TD
  A["Container Process"] --> B["Namespaces (Visibility)"]
  B --> C["Cgroups (Resource Control)"]
  C --> D["Capabilities (Privilege Control)"]
  D --> E["Kernel Enforcement"]
```

</div>

- **Namespaces** hide resources
- **Cgroups** throttle resource consumption
- **Capabilities** limit power
  Together, they form the _holy trinity_ of Docker isolation ğŸ”±

---

## ğŸ§  **Summary**

| Concept              | What It Does        | Docker Flag            |
| -------------------- | ------------------- | ---------------------- |
| **CPU Shares**       | Relative scheduling | `--cpu-shares`         |
| **CPU Cores**        | Pin to CPUs         | `--cpuset-cpus`        |
| **CPU Limit**        | Hard quota          | `--cpus`               |
| **Memory Limit**     | Max RAM usage       | `--memory`             |
| **Swap Control**     | RAM + swap total    | `--memory-swap`        |
| **Soft Reservation** | Minimum guarantee   | `--memory-reservation` |
| **Swappiness**       | Swap tendency       | `--memory-swappiness`  |

---

## ğŸ **Block I/O (Disk) and Network**

also there is a Block I/O cgroup and a Network cgroup that can be used to control bandwidth.

---

### ğŸ§© Block I/O Priority

Control disk throughput with:

```bash
--blkio-weight=500
```

Range: 10â€“1000 (default = 500)

Useful when multiple containers perform heavy disk I/O.

---

### ğŸ§© Network Control

Docker doesnâ€™t directly cap bandwidth â€”
but you can use Linux `tc` (traffic control) or advanced plugins.

Example:

```bash
tc qdisc add dev eth0 root tbf rate 1mbit burst 32kbit latency 400ms
```
