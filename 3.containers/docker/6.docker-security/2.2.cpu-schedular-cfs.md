# ğŸš¦ The Linux CPU Scheduler â€” **Completely Fair Scheduler (CFS)**

> ğŸ§  _CFS decides who gets how much CPU time, when, and for how long._

---

## ğŸ“– **What Is a CPU Scheduler?**

The **CPU scheduler** is part of the Linux kernel that decides:

- Which process should run next
- For how long it should run
- When to pause and switch to another process

You can think of it as the **traffic controller** of your CPU,
making sure all processes get a turn, nobody blocks forever, and system stays responsive.

---

## â‰ï¸ **Why It Exists**

A CPU can execute **one thread per core** at a time.
But your system runs hundreds (or thousands) of processes simultaneously â€” Docker containers, system daemons, browsers, etc.

â¡ï¸ So Linux must **pretend** that everyone runs in parallel
by quickly switching between processes many times per second (context switching).

---

## âš™ï¸ **The CFS Philosophy** â€” â€œBe Fair to Everyoneâ€

CFS = **Completely Fair Scheduler**
Introduced in Linux 2.6.23 (2007), it replaced the old â€œO(1)â€ scheduler.

Its goal:

> **Every runnable process should get an equal share of CPU over time.**

Instead of fixed time slices, CFS uses a **virtual clock** system that tracks _how much CPU time_ each process has already received.

---

## ğŸ• **How CFS Shares CPU Time** (Simplified)

Letâ€™s imagine:

- You have 1 CPU core
- 3 processes are running: P1, P2, P3

CFS tracks a â€œ**virtual runtime (vruntime)**â€ for each process:

- `vruntime` = how much CPU time that process already used
- The smaller the `vruntime`, the **more â€œhungryâ€** the process is

CFS always picks the process with the **smallest vruntime** next.

---

### ğŸ”„ Example

| Process | vruntime (ms) | Meaning           |
| ------- | ------------- | ----------------- |
| P1      | 10            | Used a lot of CPU |
| P2      | 5             | Used less         |
| P3      | 2             | Hardly ran yet    |

â¡ï¸ CFS picks **P3** to run next, since itâ€™s the most â€œstarved.â€
After running, its vruntime increases.
Eventually, all processesâ€™ vruntimes converge â€” achieving fairness.

---

### ğŸ§© Visual Timeline

<div align="center" style="background-color:#1b1515ff; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
gantt
    title CPU Scheduler (CFS) Fair Sharing Example
    dateFormat X
    section CPU Core
    Process P1 : 0, 1
    Process P2 : 1, 2
    Process P3 : 2, 3
    Process P1 : 3, 4
    Process P2 : 4, 5
    Process P3 : 5, 6
```

</div>

Each process gets a turn â€” **the illusion of parallelism** on a single core.

---

## âš–ï¸ **CPU Shares** â€” Adding Weights

In Docker (and cgroups), each container has a **CPU weight** (default = 1024).
CFS uses these weights to decide **how big each processâ€™s share** of CPU time should be.

If you have two containers:

- `webapp1` â†’ 1024 shares
- `webapp2` â†’ 512 shares

Then CFS ensures:

- `webapp1` gets 2Ã— more CPU time than `webapp2`
- But if `webapp2` is alone, it can still use 100% CPU

---

### ğŸ§© Visualizing Weighted Fairness

<div align="center" style="background-color:#1b1515ff; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
pie showData
    title CPU Time Distribution by CFS Weights
    "webapp1 (1024 shares)" : 66
    "webapp2 (512 shares)" : 33
```

</div>

CFS doesnâ€™t impose a hard cap â€” it adjusts scheduling **proportionally**.

---

## â±ï¸ **Time Slices** â€” â€œScheduling Periodsâ€

CFS divides CPU time into **scheduling periods** â€” usually around **6â€“10 ms**.

Each process gets a slice of that period proportional to its share.

For example:

- 1 CPU core, 2 containers (weights 1024 and 512)
- Scheduling period = 9 ms

  - Container A â†’ 6 ms
  - Container B â†’ 3 ms

Then the next period begins, and both get another slice.

This keeps CPU sharing smooth and balanced.

---

## âš™ï¸ **Preemption and Context Switching**

If a new, higher-priority process appears (or a process wakes from sleep),
CFS can **preempt** (pause) the running process and switch instantly.

This ensures:

- Interactive tasks (like SSH, terminal, GUI) respond fast
- Background tasks (like batch jobs) donâ€™t block them

Each context switch adds a small overhead (~1â€“3 microseconds),
but itâ€™s necessary for fairness.

---

## ğŸ§  **Docker + CFS = Resource Fairness**

When you use:

```bash
docker run --cpu-shares=512 nginx
```

Docker writes to the cgroup file:

```ini
/sys/fs/cgroup/cpu/docker/<id>/cpu.shares
```

Then the kernelâ€™s CFS scheduler reads that value
and divides CPU time accordingly.

So **Docker doesnâ€™t implement CPU throttling itself** â€”
it delegates the job to **CFS inside the kernel**.

---

## âš ï¸ **Hard CPU Limits with Quota System**

CFS also supports **hard caps**, used by Dockerâ€™s `--cpus` flag.

It uses two key parameters:

- `cpu.cfs_period_us` â€” how long each cycle lasts (default: 100000 Âµs = 100ms)
- `cpu.cfs_quota_us` â€” how much time your process can run within that period

Example:

```bash
docker run --cpus=2 nginx
```

Docker sets:

```ini
cpu.cfs_period_us = 100000
cpu.cfs_quota_us  = 200000
```

â†’ meaning: every 100ms, this container can run for 200ms of CPU time total (â‰ˆ2 cores).

---

### ğŸ§© Visualization â€” CFS Quota Logic

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart LR
  A["Scheduling Period (100ms)"]
  B["Quota (200ms worth of CPU time = 2 cores)"]
  C["Container A can run 200ms worth per 100ms window"]
  A --> B --> C
```

</div>

If it exceeds its quota â†’ the kernel throttles it until the next period.

---

## âš¡ **Real-Time Scheduler (FYI)**

CFS handles **normal workloads**,
but Linux also supports **real-time (RT)** schedulers (e.g., `SCHED_RR`, `SCHED_FIFO`)
for ultra-low-latency tasks like audio, robotics, or embedded systems.

Docker supports these too (with the `--cpu-rt-runtime` flag),
but only if your host kernel allows RT scheduling â€” not common in production servers.

---

## ğŸ§­ **Commands** to Observe CFS in Action

### Check CPU usage per container

```bash
docker stats
```

### Inspect container CPU quota

```bash
cat /sys/fs/cgroup/cpu/docker/<id>/cpu.cfs_*
```

### Inspect all process weights

```bash
cat /sys/fs/cgroup/cpu/docker/*/cpu.shares
```

---

## ğŸ **Summary** â€” CFS in Plain English

| Concept               | Meaning                               | Analogy                                    |
| --------------------- | ------------------------------------- | ------------------------------------------ |
| **CFS**               | Kernel scheduler for normal processes | â€œFair judge of CPU timeâ€ âš–ï¸                |
| **vruntime**          | Virtual time tracking CPU use         | â€œHow long youâ€™ve eaten pizzaâ€ ğŸ•           |
| **cpu.shares**        | Relative priority                     | â€œMore weight = more slicesâ€                |
| **cpu.cfs_quota_us**  | Hard CPU limit                        | â€œYou can only eat 2 slices per 10 secondsâ€ |
| **cpu.cfs_period_us** | Period length for quota               | â€œThe timer that resets your eating rightsâ€ |

---

## ğŸ’¡ **Example Recap**

| Docker Flag     | What It Does               | Backed by CFS Parameter                |
| --------------- | -------------------------- | -------------------------------------- |
| `--cpu-shares`  | Relative scheduling weight | `cpu.shares`                           |
| `--cpus`        | Hard CPU limit (cores)     | `cpu.cfs_quota_us / cpu.cfs_period_us` |
| `--cpuset-cpus` | Core affinity              | CPU affinity mask (not CFS directly)   |

---

âœ… **In short:**  
CFS is what makes Dockerâ€™s CPU limits _real_.  
It gives every container a fair share of CPU cycles using **virtual runtime tracking**,
**weighted fairness**, and **periodic quotas** â€”
so one container canâ€™t hijack your system.
