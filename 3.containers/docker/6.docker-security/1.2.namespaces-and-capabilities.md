# ğŸ›¡ï¸ Docker Security â€” Namespaces & Capabilities

> ğŸ” _How Docker builds isolation using Linux kernel features â€” explained clearly, visually, and practically._

---

## â‰ï¸ **Why We Even Need Isolation**

When you run `docker run ubuntu`, it **feels** like youâ€™ve got a full Linux system â€” with its own `ps`, `/bin/bash`, network, and processes.

Butâ€¦ surprise! ğŸ˜²  
That container is actually sharing the **same Linux kernel** with your host.  
So, Docker had to invent a way to **trick each process** into believing itâ€™s alone in the world.

Enter **Namespaces** (what you can _see_) and **Capabilities** (what you can _do_).  
Together, they make up the â€œsandbox wallsâ€ of a container.

---

## âš™ï¸ **Linux Namespaces** â€” "You Live in Your Own Universe"

When Linux boots, it creates the first process:

```ini
PID 1 â†’ systemd (init)
```

Every other process (nginx, bash, etc.) is a child of that first process.
So all PIDs must be globally unique.

Docker containers canâ€™t use those same PIDs, so Linux introduces **namespaces**,
which are **isolated copies** of global resources â€” like PIDs, networks, mounts, and more.

---

### ğŸ§  Think of a Namespace Like a â€œPrivate Lensâ€

Every container looks through its own â€œlensâ€ and sees only its resources,
even though everything runs on the same kernel.

---

### ğŸ§© Types of Namespaces Docker Uses

| Namespace | What It Isolates          | Linux Flag      | Real Example                         |
| --------- | ------------------------- | --------------- | ------------------------------------ |
| `pid`     | Process IDs               | `CLONE_NEWPID`  | Each container has its own PID 1     |
| `net`     | Network interfaces        | `CLONE_NEWNET`  | Separate `eth0`, IP, routes          |
| `mnt`     | Mount points              | `CLONE_NEWNS`   | Container has its own `/` filesystem |
| `ipc`     | Shared memory, semaphores | `CLONE_NEWIPC`  | Apps canâ€™t talk via host IPC         |
| `uts`     | Hostname & domain         | `CLONE_NEWUTS`  | Container hostname â‰  host hostname   |
| `user`    | UID/GID mapping           | `CLONE_NEWUSER` | Root inside â‰  root outside           |

---

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">
  <img src="image/1760477902786.png" alt="Docker Image" style="width: 60%;">
</div>

---

### ğŸ§© How PID Namespace Works

#### ğŸ”¸ When you run:

```bash
docker run -d --name pid-test ubuntu sleep 3600
```

Docker creates:

- A new **PID namespace**
- A process `sleep 3600` inside it

Inside container:

```bash
docker exec -it pid-test ps -ef
```

Output:

```ini
UID  PID  CMD
root   1  sleep 3600
```

On host:

```bash
ps aux | grep sleep
```

Output:

```ini
root  3816  sleep 3600
```

> So inside, itâ€™s PID 1.
> On host, itâ€™s PID 3816.
> Linux maps the containerâ€™s PID 1 â†’ host PID 3816.

---

### ğŸ” Visualizing PID Namespaces

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart TD
    A["Host Namespace</br>PID 1 (systemd)</br>PID 3816 (sleep)"]
    subgraph B["Container Namespace"]
        C["PID 1 (sleep)"]
    end
    A -.maps PID 1 -> PID 3816.-> C
```

</div>

---

<div align="center" style="background-color:#071A28; border-radius: 10px; border: 2px solid">
  <img src="image/1760453833444.png" alt="Docker Image" style="width: 60%;">
</div>

---

> ğŸ“’ Note:
>
> - Each container gets its **own PID tree** starting from 1.
> - The host can see all processes, but containers can only see theirs.

---

## ğŸŒ **1. Network Namespace** â€” â€œYour Own Ethernet Cardâ€

Every container gets a **separate network stack**:

- Its own `eth0`
- Its own IP (usually in Docker bridge network)
- Its own routing table and firewall rules

Behind the scenes, Docker uses **veth pairs**:

- One end inside the container â†’ `eth0`
- One end on the host â†’ `vethXXXX`
- Connected through a bridge â†’ `docker0`

You can inspect it:

```bash
ip link show
```

---

## ğŸ“‚ **2. Mount Namespace** â€” â€œYour Own Filesystem Treeâ€

Each container sees its own `/` (root directory).  
Underneath, Docker actually mounts it from:

```ini
/var/lib/docker/overlay2/<layer_id>/merged
```

So container `/bin/bash` â†’ `/var/lib/docker/overlay2/.../merged/bin/bash` on the host.

Thatâ€™s why deleting `/` inside container doesnâ€™t wipe your host ğŸ˜…

---

## ğŸ§ **3. User Namespace** â€” â€œRoot, But Not Reallyâ€

Without user namespaces, the containerâ€™s root (UID 0) = host root ğŸ˜¨.  
Thatâ€™s why user namespaces exist â€” to map container users to **different host UIDs**.

Example mapping:

| Inside Container | Host UID |
| ---------------- | -------- |
| root (0)         | 100000   |
| user (1000)      | 101000   |

> So even if the container is â€œrootâ€, the host sees it as UID 100000 â€” unprivileged!

---

### ğŸ§© Run as a Non-root User

```bash
docker run --user 1000 ubuntu id
```

Output:

```ini
uid=1000 gid=1000 groups=1000
```

Or set it permanently in Dockerfile:

```dockerfile
FROM ubuntu
USER 1000
```

---

## ğŸ’ªğŸ» **Linux Capabilities** â€” â€œSuperpowers with Boundariesâ€

Historically, `root` = **all powerful**.
But Linux divided rootâ€™s powers into **capabilities** â€” small permission sets like Lego blocks ğŸ§±.

---

### ğŸ§© Common Linux Capabilities

| Capability             | Description                     | Example                                 |
| ---------------------- | ------------------------------- | --------------------------------------- |
| `CAP_CHOWN`            | Change file ownership           | `chown file.txt`                        |
| `CAP_NET_BIND_SERVICE` | Bind ports <1024                | Run web servers                         |
| `CAP_SYS_ADMIN`        | Perform system admin ops        | Mount filesystems, modify kernel params |
| `CAP_NET_ADMIN`        | Change network config           | `iptables`, `ifconfig`                  |
| `CAP_SYS_TIME`         | Change system clock             | Set date/time                           |
| `CAP_KILL`             | Send signals to other processes | `kill -9`                               |

---

<div align="center" style="background-color:#EFEFEF; border-radius: 10px; border: 2px solid">
  <img src="image/1760477852642.png" alt="Docker Image" style="width: 60%;">
</div>

---

### ğŸ§© Dockerâ€™s Default Capability Set

Docker automatically:

- **Drops dangerous ones** (e.g., `CAP_SYS_ADMIN`, `CAP_SYS_MODULE`)
- **Keeps minimal safe ones** (e.g., `CHOWN`, `SETUID`, `SETGID`, `NET_BIND_SERVICE`)

So containers can run servers, manage files, and change ownership,
but canâ€™t reboot the host or reconfigure the kernel.

---

### âš™ï¸ Control Capabilities at Runtime

| Option                | What It Does             | Example                                 |
| --------------------- | ------------------------ | --------------------------------------- |
| `--cap-add=NET_ADMIN` | Add a capability         | `docker run --cap-add=NET_ADMIN ubuntu` |
| `--cap-drop=CHOWN`    | Remove a capability      | `docker run --cap-drop=CHOWN ubuntu`    |
| `--privileged`        | Add **all** capabilities | `docker run --privileged ubuntu`        |

> ğŸš¨ Warning: `--privileged` = full host access (breaks all isolation).
> Use it **only** in controlled lab environments.

---

### ğŸ§© Diagram: Capability Filtering Flow

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart TD
    subgraph A["Container Process"]
      B["root user (UID 0)"]
    end

    subgraph C["Docker Daemon"]
      D["Capability Filter"]
      D -->|Allow minimal caps| E["Kernel Syscalls"]
      D -.Drops dangerous caps.-> F["Blocked Syscalls"]
    end

    A --> D
    E -->|Executes| G["Host Kernel"]
```

</div>

When you run a process as root in Docker:

- The **Docker daemon** mediates which capabilities are passed to the kernel.
- The **kernel** executes only permitted syscalls.

---

## ğŸš¨ **Checking Capabilities Inside a Container**

You can use:

```bash
apt install libcap2-bin -y
capsh --print
```

Output:

```ini
Current: = cap_chown,cap_setgid,cap_setuid,cap_net_bind_service,cap_dac_override+i
```

Thatâ€™s your active â€œsuperpower list.â€ âœ¨

---

## âš–ï¸ **Real-Life Examples**

### âœ… Add minimal capabilities

Allow a container to open privileged ports (<1024) but nothing else:

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx
```

### ğŸš« Drop all capabilities (safe sandbox)

```bash
docker run --cap-drop=ALL alpine
```

### ğŸ’£ Full host control (dangerous)

```bash
docker run --privileged ubuntu
```

---

## ğŸ§¬ **Namespaces + Capabilities**

Docker layers both features:

| Layer                  | Role                   | Example                    |
| ---------------------- | ---------------------- | -------------------------- |
| **Namespaces**         | Isolation (visibility) | PID, Network, Mount        |
| **User Namespace**     | Privilege boundary     | Root inside â‰  Root outside |
| **Capabilities**       | Power control          | Drop dangerous privileges  |
| **Seccomp / AppArmor** | Syscall filtering      | Block kernel-level actions |

They work together like Russian dolls ğŸª† â€”
each layer adds another boundary around the process.

---

## ğŸ–¼ï¸ **Diagram:** Full Container Isolation Model

<div align="center">

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
flowchart TD
  A["Container Process"]
  B["PID Namespace"]
  C["Network Namespace"]
  D["Mount Namespace"]
  E["User Namespace"]
  F["Capabilities Filter"]
  G["Seccomp / AppArmor"]
  H["Host Kernel"]

  A --> B --> C --> D --> E --> F --> G --> H
```

</div>

Each layer ensures:

- You only **see** whatâ€™s inside your namespace
- You only **do** what your capabilities allow
- You only **call** safe syscalls the kernel permits

---

## âœ… **Best Practices** for DevOps / SREs

| Category                         | Recommendation                              | Command / Config                            |
| -------------------------------- | ------------------------------------------- | ------------------------------------------- |
| ğŸ”’ Run as non-root               | Avoid UID 0 in containers                   | `--user 1000` or `USER 1000`                |
| ğŸ§± Drop all unneeded caps        | Keep only what you need                     | `--cap-drop=ALL --cap-add=NET_BIND_SERVICE` |
| ğŸš« Avoid privileged mode         | Never use `--privileged`                    | Use per-capability addition                 |
| ğŸ§ Enable user namespaces        | Map container root â†’ unprivileged host user | `/etc/docker/daemon.json`                   |
| ğŸ” Add `no-new-privileges`       | Prevent escalation inside container         | `--security-opt no-new-privileges`          |
| ğŸ” Audit with `capsh`            | Check capabilities                          | `capsh --print`                             |
| ğŸ§° Combine with AppArmor/Seccomp | Final syscall filter                        | `/etc/docker/default.json`                  |

---

## ğŸ“ **Example:** Hardened NGINX Run Command

```bash
docker run \
  --read-only \
  --user 1000 \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt no-new-privileges \
  --security-opt seccomp=default.json \
  nginx
```

This runs NGINX as:

- Non-root user
- Minimal capabilities
- No filesystem writes
- Kernel syscall filtering enabled

âœ… Thatâ€™s how real SREs run production containers securely.

---

## ğŸ **Summary**

| Concept              | Analogy                | Key Purpose                    |
| -------------------- | ---------------------- | ------------------------------ |
| **Namespaces**       | Your own private room  | Isolate what containers _see_  |
| **User Namespace**   | Fake identity          | Prevent real host root access  |
| **Capabilities**     | Small Lego permissions | Limit what containers _can do_ |
| **Seccomp/AppArmor** | Kernel firewall        | Block dangerous syscalls       |
| **Privileged Mode**  | God mode               | Never use in production ğŸš«     |
