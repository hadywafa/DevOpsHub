# âš™ï¸ **CPU Resource Limits in Docker (Cgroups + Scheduler)**

> Docker containers share the host kernel, including the CPU.  
> Without limits, one noisy container can hog all CPU time.  
> To prevent that, Docker uses **Linux Control Groups (cgroups)** and the **Completely Fair Scheduler (CFS)** to control **who gets how much CPU time**.

---

## âš™ï¸ **How Docker Controls CPU Resources**

There are **three main ways** to manage CPU usage in containers:

| Method | Flag            | Type              | Description                           |
| ------ | --------------- | ----------------- | ------------------------------------- |
| 1ï¸âƒ£     | `--cpu-shares`  | _Relative Weight_ | Share CPU _fairly_ between containers |
| 2ï¸âƒ£     | `--cpus`        | _Absolute Limit_  | Set hard CPU usage cap                |
| 3ï¸âƒ£     | `--cpuset-cpus` | _Pinning_         | Restrict to specific cores            |

---

## 1ï¸âƒ£ `--cpu-shares` â€” Relative CPU Weight

### ğŸ’¡ Concept:

This doesnâ€™t _limit_ CPU.
It just defines **relative priority** between containers when CPU contention happens.

> If only one container is active, it can still use **100% of CPU** even with a small share.

---

### ğŸ§ª Example

Letâ€™s say your host has **4 cores**.

You run two containers:

```bash
docker run -d --name web1 --cpu-shares=1024 nginx
docker run -d --name web2 --cpu-shares=512 nginx
```

ğŸ§® **Result:**

- `web1` gets **twice** as much CPU time as `web2` when both are busy.
- Ratio: `1024 : 512 = 2 : 1`

If both are under full load,

- `web1` â†’ â‰ˆ **66% CPU time**
- `web2` â†’ â‰ˆ **33% CPU time**

If `web1` is idle â†’ `web2` can use **100%** of the CPU.

---

### ğŸ§© Notes

| Concept | Description                                                    |
| ------- | -------------------------------------------------------------- |
| Default | All containers = `1024` shares                                 |
| Range   | Any positive integer (not capped, but typically 2â€“2048)        |
| Scope   | Only affects CPU allocation _when multiple containers compete_ |
| Type    | **Soft limit** (relative weighting, not enforcement)           |

---

### ğŸ§  Analogy

Think of **`--cpu-shares`** as â€œhow many ticketsâ€ each container gets in a CPU lottery ğŸŸï¸:

- More tickets â†’ higher chance to run more often.
- But if the others arenâ€™t competing, you get all the CPU anyway.

---

## 2ï¸âƒ£ `--cpus` â€” Hard CPU Limit

### ğŸ’¡ Concept:

This defines the **maximum number of CPU cores** a container can use.

Itâ€™s an **absolute limit** â€” enforced by the **CFS quota system** (`cpu.cfs_quota_us`).

---

### ğŸ§ª Example 1 â€” Half a CPU Core

```bash
docker run -d --name api --cpus=0.5 nginx
```

ğŸ§® **Result:**

- The container can only use **50% of one CPU core**.
- CFS sets a time quota:

  - Period: 100,000 Î¼s (100ms)
  - Quota: 50,000 Î¼s â†’ container can run for half of that period.

---

### ğŸ§ª Example 2 â€” 2.5 CPUs

```bash
docker run -d --name backend --cpus=2.5 nginx
```

ğŸ§® **Result:**

- Container can use **2.5 full CPU cores**.
- On a 4-core host, thatâ€™s **62.5%** of total CPU time.
- The kernel enforces this strictly, even if other containers are idle.

---

### ğŸ§ª Example 3 â€” Update Running Container

You can also update an existing container:

```bash
docker update --cpus=1.5 backend
```

The limit is applied dynamically, without stopping the container.

---

### âš ï¸ Notes

| Option          | Description                                         |
| --------------- | --------------------------------------------------- |
| `--cpus`        | Defines the number of cores the container can use   |
| Internally Uses | `cpu.cfs_quota_us` and `cpu.cfs_period_us`          |
| Enforced By     | **CFS quota system** (Linux Scheduler)              |
| Type            | **Hard limit** â€” container cannot exceed this quota |

---

### ğŸ§© Visual â€” How CFS Quota Works

```mermaid
---
config:
  look: handDrawn
  theme: dark
---
sequenceDiagram
  participant Container
  participant CPU
  Container->>CPU: Request 100ms of CPU time
  CPU-->>Container: Granted 50ms (quota)
  Note over CPU,Container: CFS enforces --cpus=0.5 (50% of a core)
  Container->>CPU: Waits for next scheduling period
```

ğŸ§  The **CFS** (Completely Fair Scheduler) divides time into small periods
and assigns each container its â€œfair shareâ€ of execution time based on quota.

---

## 3ï¸âƒ£ `--cpuset-cpus` â€” Pinning Containers to Specific Cores

### ğŸ’¡ Concept:

Bind a container to specific **CPU cores**, improving cache locality and predictability.

---

### ğŸ§ª Example

Host with **4 cores (0â€“3)**

```bash
docker run -d --cpuset-cpus="0-1" --name web1 nginx
docker run -d --cpuset-cpus="2,3" --name web2 nginx
```

ğŸ§® **Result:**

- `web1` only runs on cores 0 and 1
- `web2` only runs on cores 2 and 3
  They donâ€™t compete, which improves stability for performance-sensitive apps (e.g., databases).

---

### âš ï¸ Notes

| Option                | Description                                       |
| --------------------- | ------------------------------------------------- |
| `--cpuset-cpus="0,1"` | Use cores 0 and 1 only                            |
| `--cpuset-cpus="2-3"` | Use core range 2 to 3                             |
| Type                  | **Core affinity** â€” physical pinning, not a limit |

---

## ğŸ“ **Combined Example** â€” All Together

```bash
docker run -d \
  --name webapp \
  --cpus=2.5 \
  --cpu-shares=512 \
  --cpuset-cpus="0-2" \
  nginx
```

| Flag                  | Meaning                       |
| --------------------- | ----------------------------- |
| `--cpus=2.5`          | Hard limit: use max 2.5 cores |
| `--cpu-shares=512`    | Lower priority if contention  |
| `--cpuset-cpus="0-2"` | Run only on cores 0â€“2         |

ğŸ§© The container can use only 2.5 cores (out of 3 assigned), and if it competes with others, itâ€™ll get half their share.

---

## âš™ï¸ **Inspecting CPU Limits**

You can verify limits using:

```bash
docker inspect <container> | grep -i cpu
```

or monitor live usage:

```bash
docker stats
```

Output includes:

```ini
CONTAINER   CPU %   MEM USAGE / LIMIT
webapp      62.3%   200MiB / 512MiB
```

---

## ğŸ **Summary**

| Flag            | Purpose                | Type     | Example               |
| --------------- | ---------------------- | -------- | --------------------- |
| `--cpu-shares`  | Relative weight        | Soft     | `--cpu-shares=512`    |
| `--cpus`        | Hard CPU limit         | Hard     | `--cpus=2.5`          |
| `--cpuset-cpus` | Bind to specific cores | Affinity | `--cpuset-cpus="0-1"` |

---

## ğŸš¨ **Best Practices**

- âœ… Always use `--cpus` for **production containers**
- âœ… Use `--cpu-shares` only when sharing CPU between non-critical services
- âœ… Use `--cpuset-cpus` for **latency-sensitive workloads** (e.g., DBs, APIs)
- âœ… Monitor with `docker stats` or `cAdvisor`
- âœ… Tune with real-world load tests â€” not guesses

---

## ğŸ§© **Mental Model**

Think of your CPU like a **pizza ğŸ•**:

- `--cpus` = how many slices you _can_ eat
- `--cpu-shares` = your _priority_ when everyoneâ€™s hungry
- `--cpuset-cpus` = which slices (cores) youâ€™re allowed to take
