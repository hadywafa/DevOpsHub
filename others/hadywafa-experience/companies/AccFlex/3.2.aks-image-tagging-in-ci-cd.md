# Kubernetes image tagging in Azure DevOps

Got it — here are **two Azure DevOps pipelines** that show exactly how we handle **image tagging** differently for **dev** and **prod** (plus SonarQube + Trivy, Helm deploy to AKS, and ACR push).

- **Dev**: push **two tags** → an **immutable** tag (`0.0.0-<shortsha>`) and a **moving** tag (`dev-latest`). Deploy with the **moving tag** for fast iteration (the immutable stays for traceability).
- **Prod**: triggered by a **SemVer git tag** (e.g., `v1.8.2`). Build and push **only the immutable** tag (`1.8.2-<shortsha>`). Deploy **with the immutable tag**.

---

## `azure-pipelines-dev.yml` (auto-deploy to AKS dev)

```yaml
trigger:
  branches:
    include: [dev]

variables:
  # Change to your values
  azureSubscription: "SC-My-AzureRM-Connection" # Azure Resource Manager service connection
  acrName: "mycompanyacr" # ACR name (no domain)
  acrLoginServer: "mycompanyacr.azurecr.io"
  imageRepo: "apps/crm-service"
  aksRG: "rg-aks-dev"
  aksCluster: "aks-dev"
  k8sNamespace: "dev"
  helmRelease: "crm-service"
  helmChartPath: "charts/crm-service" # path in repo to Helm chart
  sonarService: "SonarQubeServiceConnection" # Service connection name
  sonarProjectKey: "crm-service"
  sonarProjectName: "crm-service"
  # Trivy severity policy for dev: fail on high/critical only
  trivySeverities: "HIGH,CRITICAL"

stages:
  - stage: BuildScanPush
    displayName: Build + Scan + Push to ACR
    jobs:
      - job: build
        displayName: Build & Scan
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            clean: true

          # Compute tags (immutable + moving)
          - bash: |
              SHORT=$(git rev-parse --short HEAD)
              echo "##vso[task.setvariable variable=TAG_IMMUTABLE]0.0.0-${SHORT}"
              echo "##vso[task.setvariable variable=TAG_MOVING]dev-latest"
            displayName: Compute Tags

          # SonarQube (prepare -> run -> publish)
          - task: SonarQubePrepare@6
            inputs:
              SonarQube: $(sonarService)
              scannerMode: "Other"
              extraProperties: |
                sonar.projectKey=$(sonarProjectKey)
                sonar.projectName=$(sonarProjectName)

          - bash: |
              echo "Running unit tests here if applicable..."
              # dotnet test / npm test / pytest ...
            displayName: Run tests (placeholder)

          - bash: |
              # Pre-build FS scan
              curl -L https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b $(Agent.ToolsDirectory)/trivy
              $(Agent.ToolsDirectory)/trivy/trivy fs --severity $(trivySeverities) --exit-code 1 --ignore-unfixed .
            displayName: Trivy FS scan

          # Docker build (multi-tag) and push to ACR
          - task: AzureCLI@2
            displayName: ACR Login + Build + Push
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr login -n $(acrName)
                IMAGE="$(acrLoginServer)/$(imageRepo)"
                docker build -t "$IMAGE:$(TAG_IMMUTABLE)" -t "$IMAGE:$(TAG_MOVING)" .
                docker push "$IMAGE:$(TAG_IMMUTABLE)"
                docker push "$IMAGE:$(TAG_MOVING)"

          # Trivy image scan on the immutable tag
          - bash: |
              $(Agent.ToolsDirectory)/trivy/trivy image --severity $(trivySeverities) --exit-code 1 --ignore-unfixed $(acrLoginServer)/$(imageRepo):$(TAG_IMMUTABLE)
            displayName: Trivy Image scan

          - task: SonarQubePublish@6
            inputs:
              pollingTimeoutSec: "300"

  - stage: DeployDev
    displayName: Deploy to AKS Dev (Helm)
    dependsOn: BuildScanPush
    jobs:
      - job: helmDeploy
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: AKS Login (get-credentials)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g $(aksRG) -n $(aksCluster) --overwrite-existing

          - task: HelmInstaller@1
            displayName: Install Helm

          # Deploy using the moving tag (fast iteration), but also annotate with immutable tag for traceability
          - bash: |
              IMAGE="$(acrLoginServer)/$(imageRepo)"
              helm upgrade --install $(helmRelease) $(helmChartPath) \
                --namespace $(k8sNamespace) --create-namespace \
                --set image.repository="$IMAGE" \
                --set image.tag="$(TAG_MOVING)" \
                --set-string deployment.annotations.commitTag="$(TAG_IMMUTABLE)"
            displayName: Helm upgrade (DEV) with moving tag
```

**Why this works (dev):**

- You **push two tags**. ArgoCD isn’t used here; you **push** with Helm.
- You **deploy with `dev-latest`** for quick loops, but you **record** the immutable tag in an annotation (or env var) for auditing.
- Trivy/Sonar run **before** deploy and can **fail** the build.

---

## `azure-pipelines-prod.yml` (manual approval, deploy immutable to prod)

```yaml
# Trigger on SemVer git tags only: v1.2.3, v10.0.0, etc.
trigger:
  tags:
    include: ["v*.*.*"]

pr: none

variables:
  azureSubscription: "SC-My-AzureRM-Connection"
  acrName: "mycompanyacr"
  acrLoginServer: "mycompanyacr.azurecr.io"
  imageRepo: "apps/crm-service"
  aksRG: "rg-aks-prod"
  aksCluster: "aks-prod"
  k8sNamespace: "prod"
  helmRelease: "crm-service"
  helmChartPath: "charts/crm-service"
  sonarService: "SonarQubeServiceConnection"
  sonarProjectKey: "crm-service"
  sonarProjectName: "crm-service"
  # Tighter policy for prod (still HIGH/CRITICAL; adjust as needed)
  trivySeverities: "HIGH,CRITICAL"

stages:
  - stage: BuildScanPush
    displayName: Build + Scan + Push (immutable only)
    jobs:
      - job: build
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            clean: true

          # Compute immutable tag from Git tag + short SHA
          - bash: |
              SHORT=$(git rev-parse --short HEAD)
              RAWREF="$(Build.SourceBranchName)"       # e.g., v1.8.2
              VERSION="${RAWREF#v}"                    # strip leading v => 1.8.2
              echo "##vso[task.setvariable variable=VERSION]$VERSION"
              echo "##vso[task.setvariable variable=TAG_IMMUTABLE]${VERSION}-${SHORT}"
            displayName: Compute Tags

          - task: SonarQubePrepare@6
            inputs:
              SonarQube: $(sonarService)
              scannerMode: "Other"
              extraProperties: |
                sonar.projectKey=$(sonarProjectKey)
                sonar.projectName=$(sonarProjectName)

          - bash: |
              echo "Run unit/integration tests here..."
            displayName: Run tests (placeholder)

          - bash: |
              curl -L https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b $(Agent.ToolsDirectory)/trivy
              $(Agent.ToolsDirectory)/trivy/trivy fs --severity $(trivySeverities) --exit-code 1 --ignore-unfixed .
            displayName: Trivy FS scan

          - task: AzureCLI@2
            displayName: ACR Login + Build + Push (immutable)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr login -n $(acrName)
                IMAGE="$(acrLoginServer)/$(imageRepo)"
                docker build -t "$IMAGE:$(TAG_IMMUTABLE)" .
                docker push "$IMAGE:$(TAG_IMMUTABLE)"

          - bash: |
              $(Agent.ToolsDirectory)/trivy/trivy image --severity $(trivySeverities) --exit-code 1 --ignore-unfixed $(acrLoginServer)/$(imageRepo):$(TAG_IMMUTABLE)
            displayName: Trivy Image scan

          - task: SonarQubePublish@6
            inputs:
              pollingTimeoutSec: "300"

  - stage: ManualApproval
    displayName: Manual Approval
    dependsOn: BuildScanPush
    jobs:
      - job: hold
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - task: ManualValidation@0
            inputs:
              notifyUsers: ""
              instructions: |
                Review SonarQube and Trivy results. Confirm readiness for PROD.
              onTimeout: "reject"
              timeout: "0" # no timeout

  - stage: DeployProd
    displayName: Deploy to AKS Prod (Helm) with immutable tag
    dependsOn: ManualApproval
    condition: succeeded()
    jobs:
      - job: helmDeploy
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: AKS Login (get-credentials)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g $(aksRG) -n $(aksCluster) --overwrite-existing

          - task: HelmInstaller@1
            displayName: Install Helm

          - bash: |
              IMAGE="$(acrLoginServer)/$(imageRepo)"
              helm upgrade --install $(helmRelease) $(helmChartPath) \
                --namespace $(k8sNamespace) --create-namespace \
                --set image.repository="$IMAGE" \
                --set image.tag="$(TAG_IMMUTABLE)" \
                --set-string deployment.annotations.version="$(VERSION)" \
                --set-string deployment.annotations.commitTag="$(TAG_IMMUTABLE)"
            displayName: Helm upgrade (PROD) with immutable tag
```

**Why this works (prod):**

- Triggered by **git tags** (`v1.8.2`), so your **app version** is the source of truth.
- The **immutable tag** is `1.8.2-<shortsha>`. You **deploy with that exact tag**.
- A **manual validation** gate ensures human approval before prod rollout.

---

## Notes & Options

- **AKS access**: Both pipelines use `az aks get-credentials` via an Azure RM service connection (backed by a SP or managed identity).
- **Helm values**: If you prefer per-env `values.yaml` files, add `-f environments/dev/values.yaml` and override only the `image.*` via `--set` flags.
- **TLS & Ingress**: Add/override values for `ingress.hosts`, `ingress.tls`, and cert-manager issuers in env values.
- **Private ACR pull**: Give the AKS kubelet identity `AcrPull` on your ACR (or use imagePullSecrets).
- **Rollback**: `helm rollback crm-service <rev>` — your immutable tag annotations help you see the exact image deployed.

---

## TL;DR — Tagging Strategy

- **Dev**: push **`dev-latest` + immutable `0.0.0-<sha>`**, deploy **`dev-latest`** for speed (annotation keeps the immutable for auditing).
- **Prod**: push **only immutable** **`<version>-<sha>`** (derived from git tag `v<version>`), deploy **that immutable tag**.
