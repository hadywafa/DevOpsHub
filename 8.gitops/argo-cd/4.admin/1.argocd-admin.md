# ğŸš€ **Argo CD Management: RBAC, User Management, and Dex Connectors**

Argo CD is more than just â€œdeploy from Gitâ€.
Real production GitOps needs:

- **User accounts**
- **SSO (OIDC/SAML)**
- **RBAC policies**
- **Team-based access**
- **Token management**
- **SSO identity mapping**
- **LDAP/AD integration**

This topic explains **everything**, structured simply and cleanly.

---

## ğŸŸ¦ PART 1 â€” **Argo CD RBAC (Role-Based Access Control)**

Argo CD uses **built-in RBAC** powered by two components:

1. The **argocd-rbac-cm** ConfigMap â†’ defines roles & policies
2. The **argocd-cm** ConfigMap â†’ maps user groups to roles

RBAC controls what each user/group can do.

---

<div align="center" style="background-color:#F2F2F2; border-radius: 10px; border: 2px solid">
  <img src="image/1763812760326.png" alt="Reconciliation Loop" style="width: 80%">
</div>

---

## ğŸ§© **1.1. RBAC Concepts**

### âœ” Subjects

Who we are granting permissions to:

- Argo CD local user (`admin`, `dev1`)
- Dex/OIDC group (`oidc:team-dev`)
- GitHub team (`github:myorg/team-dev`)
- LDAP group

### âœ” Actions (verbs)

What the user can do:

- `get`, `update`, `create`, `delete`
- `sync`
- `override`
- `action` (resource actions like restart rollout)

### âœ” Scopes (objects)

What the user can access:

- `applications`
- `clusters`
- `projects`
- `certificates`
- `repositories`
- `accounts`

---

## ğŸŸ© **1.2. RBAC Policy Format**

Inside **argocd-rbac-cm**:

```ini
p, <subject>, <resource>, <action>, <scope>
```

Example:

```ini
p, role:dev-team, applications, sync, my-app/*
p, role:dev-team, applications, get, my-app/*
p, role:dev-team, logs, get, my-app/*
```

---

## ğŸŸ§ **1.3. RBAC Example**

### ğŸ”¹ Step 1: Define a role in argocd-rbac-cm

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-rbac-cm
  namespace: argo-cd
data:
  policy.csv: |
    # DEV TEAM: can view + sync only their apps
    p, role:devs, applications, get, dev-*
    p, role:devs, applications, sync, dev-*
    p, role:devs, applications, logs, dev-*
    p, role:devs, applications, action/*, dev-*

    # OPS: full control
    p, role:ops, applications, *, *
    p, role:ops, clusters, *, *
    p, role:ops, projects, *, *

  scopes: "[groups]"
```

---

## ğŸŸ¨ **1.4. RBAC Wildcards**

Argo CD supports:

```ini
dev-*       â†’ only apps starting with dev-
*           â†’ everything
prod/*      â†’ all resources inside project prod
```

---

## ğŸŸ¥ **1.5. RBAC Role Binding**

Binding roles is done in **argocd-cm**, not argocd-rbac-cm.

Example: Bind GitHub â€œteam-devâ€ to â€œrole:devsâ€

```yaml
data:
  dex.config: |
    connectors: [...etc...]

  policy.default: role:readonly

  # RBAC role bindings
  accounts.admin.enabled: "true"

  # map SSO groups to roles
  groups:
    - name: github:myorg/team-dev
      policies:
        - role:devs
```

---

## ğŸŸ¦ PART 2 â€” **Argo CD User Management**

You can manage users in **two ways**:

1. **Local accounts** (built-in Argo CD users)
2. **SSO-based users** (Dex â†’ OIDC/SAML/LDAP)

---

<div align="center" style="background-color:#F2F2F2; border-radius: 10px; border: 2px solid">
  <img src="image/1763811391719.png" alt="Reconciliation Loop" style="width: 80%">
</div>

---

## ğŸ§© **2.1. Local Accounts**

Local users are defined in **argocd-cm** using:

```ini
accounts.<name>.enabled=true
accounts.<name>.password=<bcrypt>
accounts.<name>.tokens=<count>
```

### âœ” Create a new local user

```yaml
data:
  accounts.dev1.enabled: "true"
  accounts.dev1.password: "$bcrypt..."
  accounts.dev1.tokens: "5"
```

Generate bcrypt password:

```bash
argocd account bcrypt --password MyPassword
```

### âœ” Login as local user:

```bash
argocd login <ARGOCD_URL> --username dev1 --password MyPassword
```

### âœ” Disable user

```yaml
accounts.dev1.enabled: "false"
```

---

## ğŸŸ§ **2.2. Local User Permissions**

After creating a local user, bind RBAC role:

```yaml
data:
  policy.csv: |
    p, role:devs, applications, get, dev-*
    p, dev1, role, devs
```

---

## ğŸŸ© **2.3. Token Management**

Users can create tokens via CLI:

```bash
argocd account generate-token --account dev1
```

Useful for:

- CI/CD pipelines
- GitHub Actions
- Azure Pipelines

---

## ğŸŸª **2.4. Best Practices for Local Users**

- Avoid local users in production
- Use local users only for break-glass access
- Prefer SSO + RBAC groups
- Rotate local user tokens
- Disable default `admin` after bootstrapping

---

## ğŸŸ§ PART 3 â€” **Dex Connector (SSO Integration)**

Argo CD uses **Dex as an identity broker**.
Dex supports:

- GitHub
- GitLab
- Azure AD
- Google
- OIDC providers
- LDAP
- SAML providers

Dex essentially maps **external identity â†’ Argo CD user/group**.

---

<div align="center" style="background-color:#F2F2F2; border-radius: 10px; border: 2px solid">
  <img src="image/1763811556143.png" alt="Reconciliation Loop" style="width: 80%">
</div>

---

## ğŸ§© **3.1. Dex Configuration Location**

Dex config is placed inside **argocd-cm**:

```yaml
data:
  dex.config: |
    connectors:
      - type: github
        id: github
        name: GitHub
        config: ...
```

---

## ğŸŸ¥ **3.2. Example: GitHub SSO**

```yaml
data:
  dex.config: |
    connectors:
    - type: github
      id: github
      name: GitHub Login
      config:
        clientID: $argocd-github-client-id
        clientSecret: $argocd-github-client-secret
        orgs:
          - name: myorg
```

Argo CD will receive groups like:

```ini
github:myorg/team-dev
github:myorg/team-ops
```

Bind those to RBAC roles.

---

## ğŸŸ¦ **3.3. Example: Azure AD SSO (enterprise)**

```yaml
data:
  dex.config: |
    connectors:
    - type: oidc
      id: azure
      name: Azure AD
      config:
        clientID: $azure_client_id
        clientSecret: $azure_client_secret
        tenant: <TENANT-ID>
        redirectURI: https://argocd.mycompany.com/api/dex/callback
        groupsClaim: groups
```

Then bind Azure groups:

```yaml
groups:
  - name: "aad:DevTeam"
    policies:
      - role:devs
```

---

## ğŸŸ© **3.4. Example: LDAP**

```yaml
connectors:
  - type: ldap
    id: ldap
    name: LDAP
    config:
      host: ldap.mycompany.com:636
      bindDN: "cn=admin,dc=mycompany,dc=com"
      bindPW: $LDAP_PASSWORD
      userSearch:
        baseDN: "ou=users,dc=mycompany,dc=com"
        filter: "(objectClass=person)"
        username: uid
      groupSearch:
        baseDN: "ou=groups,dc=mycompany,dc=com"
        filter: "(objectClass=groupOfNames)"
        userMatchers:
          - userAttr: DN
            groupAttr: member
```

---

## ğŸŸ« **Connecting Dex with RBAC**

This is the essence of User Management.

Flow:

```mermaid
flowchart LR
    A[User logs in via SSO] --> B[Dex Authenticates User]
    B --> C[Dex sends groups to Argo CD]
    C --> D[Argo CD RBAC maps groups to roles]
    D --> E[User gets permissions]
```

You must:

1. Define **roles** in `argocd-rbac-cm`
2. Map **groups** to roles in `argocd-cm`
3. Let Dex authenticate & send those groups

---

## ğŸŸ§ **Complete Example (SSO + RBAC + User Management)**

```yaml
--- # ---- 1. User Mapping + Dex ----
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
data:
  dex.config: |
    connectors:
      - type: github
        id: github
        name: GitHub
        config:
          clientID: $github_clientid
          clientSecret: $github_secret
          orgs:
            - name: myorg

  # Default access
  policy.default: role:readonly

  # Map GitHub groups to roles
  groups:
    - name: "github:myorg/team-dev"
      policies:
        - role:devs

    - name: "github:myorg/team-ops"
      policies:
        - role:ops
```

```yaml
--- # ---- 2. RBAC roles & policies ----
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-rbac-cm
data:
  policy.csv: |
    # DEV ROLE
    p, role:devs, applications, get, dev-*
    p, role:devs, applications, sync, dev-*
    p, role:devs, applications, logs, dev-*

    # OPS ROLE
    p, role:ops, applications, *, *
    p, role:ops, clusters, *, *
    p, role:ops, projects, *, *

  scopes: "[groups]"
```

---

## ğŸŸ© **Best Practices for Argo CD Management**

### âœ” Use SSO whenever possible

Azure AD / GitHub Teams / LDAP / Okta / Keycloak

### âœ” Manage RBAC via Git

Never edit via UI.

### âœ” Disable default admin

After bootstrap:

```ini
accounts.admin.enabled: "false"
```

### âœ” Use groups, not individual user usernames

Group-based roles scale better.

### âœ” Separate â€œread-onlyâ€ vs â€œsyncâ€ roles

Read-only should NOT sync accidentally.

### âœ” Use AppProjects for stronger boundaries

AppProjects + RBAC â†’ strong multi-tenancy.

---

## ğŸ¯ Final Summary

**Argo CD Management** consists of:

### âœ” RBAC

Defines _what_ a user/group can do.

### âœ” User Management

Local accounts + tokens + SSO.

### âœ” Dex Connectors

Connect Argo CD to identity providers (GitHub, Azure AD, LDAP, etc.)

Together, these give you:

- secure access
- team boundaries
- full GitOps automation
- production-grade governance

---

If you want, I can also create:

ğŸ”¥ A diagram showing RBAC + Projects + SSO together
ğŸ”¥ A â€œrole designâ€ for multi-team environments
ğŸ”¥ Argo CD full security hardening guide
Just tell me!
