# âœğŸ» **Hands-on Custom Health Checks**

> Custom health checks are a new feature in Argo CD 3.1.  
> it used for **monitoring custom resources (CRDs)** in your cluster.

You want:

> create **custom health checks** (custom resource logic) for an app called **`my-backend`** that Argo CD deploys from a **Helm chart in your GitHub repo**.

Iâ€™ll walk you through:

1. Assumptions & goal
2. Argo CD Application for `my-backend` (Helm from GitHub)
3. Example â€œcustom resourceâ€ we want to monitor
4. How Argo CD initially sees it (Unknown)
5. Adding a **custom health check** in `argocd-cm`
6. Testing & verifying in UI/CLI

---

## ğŸ¯ **Assumptions & Goal**

Weâ€™ll assume:

- You already have Argo CD running in namespace `argo-cd`
- Your Git repo: `https://github.com/YourOrg/your-helm-repo.git`
- Your Helm chart: `charts/my-backend`
- That Helm chart creates a **custom resource** (CRD) called `BackendApp`:

  - API group: `apps.mycompany.com`
  - Kind: `BackendApp`
  - Status field looks like:

  ```yaml
  status:
    phase: Ready | Progressing | Error
    message: "..."
  ```

Your **goal**:

> Make Argo CD show health for `BackendApp` as **Healthy / Progressing / Degraded** based on `status.phase`, and thus show a correct health state for the `my-backend` Application.

---

## ğŸ”¹ Step 1 â€“ Argo CD Application for `my-backend` (Helm from GitHub)

This is a typical Argo CD Application using a Helm chart from your GitHub repo:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-backend
  namespace: argo-cd
spec:
  project: default
  source:
    repoURL: https://github.com/YourOrg/your-helm-repo.git
    targetRevision: main
    chart: my-backend # OR use 'path:' if not using Helm repo-style structure
    helm:
      valueFiles:
        - values-prod.yaml # optional
  destination:
    server: https://kubernetes.default.svc
    namespace: my-backend
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

Apply it:

```bash
kubectl apply -f my-backend-app.yaml
```

Argo CD will:

- Pull the Helm chart from GitHub
- Render Kubernetes objects
- Deploy them to namespace `my-backend`

Among those resources, your Helm chart creates a **custom resource**:

```yaml
apiVersion: apps.mycompany.com/v1
kind: BackendApp
metadata:
  name: my-backend
  namespace: my-backend
spec:
  replicas: 3
  image: your-image:tag
status:
  phase: Progressing
  message: "Pods are starting"
```

---

## ğŸ”¹ Step 2 â€“ What Argo CD Shows _Before_ Custom Health

Now if you go to the Argo CD UI:

- Open app **`my-backend`**
- Look at the tree view

Youâ€™ll probably see `BackendApp` with **Health = Unknown**.

Why?
Because Argo CD **doesnâ€™t know** how to interpret `apps.mycompany.com/BackendApp` by default.

So Application health might show as:

- Health: **Unknown**
- Sync: Synced

We want Argo CD to map:

- `status.phase: Ready` â†’ **Healthy**
- `status.phase: Progressing` â†’ **Progressing**
- `status.phase: Error` â†’ **Degraded**

---

## ğŸ”¹ Step 3 â€“ Add Custom Health Check in `argocd-cm`

Argo CD lets you define custom health logic in the **`argocd-cm` ConfigMap** using **Lua**.

Weâ€™ll add an entry:

`resource.customizations.health.apps.mycompany.com/BackendApp`

### ğŸ”§ Create/Edit `argocd-cm`

You can edit live:

```bash
kubectl edit cm argocd-cm -n argo-cd
```

Or create a patch yaml:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argo-cd
data:
  resource.customizations.health.apps.mycompany.com/BackendApp: |
    hs = {}
    -- If no status yet, it's still starting
    if obj.status == nil or obj.status.phase == nil then
      hs.status = "Progressing"
      hs.message = "Waiting for BackendApp status..."
      return hs
    end

    if obj.status.phase == "Ready" then
      hs.status = "Healthy"
      hs.message = obj.status.message or "BackendApp is ready"
      return hs
    end

    if obj.status.phase == "Progressing" then
      hs.status = "Progressing"
      hs.message = obj.status.message or "BackendApp is progressing"
      return hs
    end

    if obj.status.phase == "Error" then
      hs.status = "Degraded"
      hs.message = obj.status.message or "BackendApp is in error state"
      return hs
    end

    -- Fallback for unexpected values
    hs.status = "Unknown"
    hs.message = "Unknown BackendApp phase: " .. tostring(obj.status.phase)
    return hs
```

Apply it (if using file):

```bash
kubectl apply -f argocd-cm-custom-health.yaml
```

Argo CD automatically reloads config maps (no restart normally needed; if stuck, you can restart the `argocd-application-controller` pod).

---

## ğŸ”¹ Step 4 â€“ Test Custom Health Check

Now:

1. Trigger a refresh/sync of the app:

   ```bash
   argocd app get my-backend
   argocd app sync my-backend
   ```

2. In the Argo CD UI, open **`my-backend`** again.

   You should see:

   - The `BackendApp` CR now shows a meaningful **Health**:

   - `Ready` â†’ **Healthy**
   - `Progressing` â†’ **Progressing**
   - `Error` â†’ **Degraded**

3. Application-level health:

   - If **all** resources (including `BackendApp`) become Healthy â†’ app = **Healthy**
   - If `BackendApp` is Progressing â†’ app = **Progressing**
   - If `BackendApp` is Error â†’ app = **Degraded**

---

## ğŸ”¹ Step 5 â€“ Simulate Phase Changes (Hands-On Testing)

To feel it â€œfor realâ€, you can manually patch your CR and watch Argo CD:

### ğŸ”¸ Set to Progressing

```bash
kubectl patch backendapp my-backend -n my-backend --type merge -p '{
  "status": {
    "phase": "Progressing",
    "message": "Starting upâ€¦"
  }
}'
```

Expected in Argo CD:

- Resource: `BackendApp` â†’ **Progressing**
- Application: **Progressing**

---

### ğŸ”¸ Set to Ready

```bash
kubectl patch backendapp my-backend -n my-backend --type merge -p '{
  "status": {
    "phase": "Ready",
    "message": "All pods running"
  }
}'
```

Expected in Argo CD:

- `BackendApp` â†’ **Healthy**
- Application (`my-backend`) â†’ **Healthy** (if all others are OK)

---

### ğŸ”¸ Set to Error

```bash
kubectl patch backendapp my-backend -n my-backend --type merge -p '{
  "status": {
    "phase": "Error",
    "message": "Database connection failed"
  }
}'
```

Expected in Argo CD:

- `BackendApp` â†’ **Degraded**
- App â†’ **Degraded**

Thatâ€™s full end-to-end custom health logic working ğŸ¯

---

## âš™ï¸ How This Ties to Your Helm Chart from GitHub

Where does Helm fit in?

- Your **Helm chart** defines both:

  - Deployment, Service, etc.
  - The custom CR `BackendApp`

- Argo CD **does not care** that it was Helm; it sees resources after render.
- Once you add the Lua script in `argocd-cm`, _any_ `BackendApp` created by your chart (from GitHub or anywhere) will use that health logic.

You donâ€™t have to touch the chart itself; health customization is **centralized in Argo CD**.

---

## ğŸ‰ Bonus: Tie Health to Standard K8s Resources (Optional)

If instead of a CRD you just want _stricter_ health for the Helm-rendered **Deployment** (`apps/Deployment`), you can even override that too:

```yaml
data:
  resource.customizations.health.apps/Deployment: |
    hs = {}
    if obj.status ~= nil and obj.status.availableReplicas ~= nil then
      if obj.status.availableReplicas == obj.spec.replicas then
        hs.status = "Healthy"
        hs.message = "All replicas available"
      else
        hs.status = "Progressing"
        hs.message = "Available replicas: " .. obj.status.availableReplicas .. "/" .. obj.spec.replicas
      end
    else
      hs.status = "Progressing"
      hs.message = "Waiting for Deployment status"
    end
    return hs
```

Now your **my-backend Deployment** health will follow your stricter logic.

---

## ğŸ”š Quick Recap

- You deploy **`my-backend`** from a **Helm chart in GitHub** using an Argo CD Application.
- The chart creates a custom resource `BackendApp` (CRD).
- Argo CD sees CRDs as **Unknown** by default.
- You add a **custom health check** in `argocd-cm` under:

  - `resource.customizations.health.apps.mycompany.com/BackendApp`

- Lua script reads `obj.status.phase` and returns: Healthy / Progressing / Degraded.
- After that, Argo CD shows accurate health for both `BackendApp` and the whole `my-backend` app.

If you want, next I can:

- Adapt the YAML exactly to your **real CRD name & status fields**
- Show how to **version control** this `argocd-cm` in your own Helm deployment of Argo CD
- Or combine this with your **App-of-Apps** structure so all clusters get the same health logic automatically.
