# üüß TYPE 4 ‚Äî Application Using Community Helm Repo (Public / Remote Helm Chart)

Here Argo CD doesn‚Äôt read a chart from _your_ Git repo.
Instead, it pulls a **Helm chart directly from a Helm repository**, for example:

- Bitnami (`https://charts.bitnami.com/bitnami`)
- Ingress NGINX (`https://kubernetes.github.io/ingress-nginx`)
- Prometheus community, etc.

## üîπ Basic Example (No custom values yet)

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: redis-community
  namespace: argo-cd
spec:
  project: default

  source:
    repoURL: https://charts.bitnami.com/bitnami
    chart: redis
    targetRevision: 18.3.2

  destination:
    server: https://kubernetes.default.svc
    namespace: redis

  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

---

## üßæ How to Add Your Values to a Community Helm Chart

You have **three main ways** to pass custom values for a remote Helm chart:

---

## ‚úÖ Option 1 ‚Äî Small tweaks via `helm.parameters`

Good for simple overrides like replica count, enabling/disabling features, etc.

```yaml
source:
  repoURL: https://charts.bitnami.com/bitnami
  chart: redis
  targetRevision: 18.3.2
  helm:
    parameters:
      - name: architecture
        value: "replication"
      - name: replica.replicaCount
        value: "2"
      - name: auth.enabled
        value: "true"
```

**Notes:**

- `name` is **the key path** inside values.yaml (like `replica.replicaCount`)
- `value` is always a **string** in YAML, Helm will cast it

Best when:

- Few values
- Simple stuff: numbers, bools, short strings

---

## ‚úÖ Option 2 ‚Äî Inline full `values` block (like embedding values.yaml)

If you have many settings and don‚Äôt want to fork the chart, you can embed a virtual `values.yaml` directly in the Application:

```yaml
source:
  repoURL: https://charts.bitnami.com/bitnami
  chart: redis
  targetRevision: 18.3.2
  helm:
    values: |
      architecture: replication

      replica:
        replicaCount: 3

      auth:
        enabled: true
        password: "my-redis-password"

      resources:
        requests:
          cpu: 100m
          memory: 256Mi
        limits:
          cpu: 500m
          memory: 512Mi
```

This is basically like having a `values.yaml` inside the Application spec.

Best when:

- Many related settings
- You want clear structure
- You don‚Äôt want to maintain a Git repo just for values

---

## ‚úÖ Option 3 ‚Äî `valueFiles` (but **careful** with remote charts!)

### **‚ö†Ô∏è The Problem with `valueFiles` + Remote Helm Charts**

When you use a **remote Helm repo** (e.g. Bitnami) like this:

```yaml
source:
  repoURL: https://charts.bitnami.com/bitnami
  chart: redis
  targetRevision: 18.3.2
  helm:
    valueFiles:
      - ../my-values/redis-prod.yaml
```

Argo CD **cannot** see `../my-values/redis-prod.yaml`, because:

- For remote Helm charts, Argo CD only has access to **files inside the Helm chart package** (the `.tgz` from the Helm repo).
- It does **not** have your own Git repo‚Äôs folder structure in that context.

So what happens?

- Helm fails with **‚Äúcould not find values file‚Äù** or similar error
  **or**
- Argo CD simply **ignores** the invalid file and uses default values (depending on version/behavior), which is even more dangerous.

In short:

> `valueFiles` with remote `repoURL` can only point to files that are **inside** that chart, not arbitrary paths in your Git repos.

---

### **‚úÖ Solution: Use a Multi-Source Application**

With a **multi-source Application**, you can:

- Use **Source 1** = remote Helm chart (Bitnami, etc.)
- Use **Source 2** = your Git repo that contains `values.yaml`
- Then reference the values file from the second source.

Example: Redis from Bitnami + values from your Git repo

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: redis-multisource
  namespace: argo-cd
spec:
  project: default

  sources:
    # Source 1: Community Helm chart (remote)
    - repoURL: https://charts.bitnami.com/bitnami
      chart: redis
      targetRevision: 18.3.2
      helm:
        valueFiles:
          - $values/values/redis-prod.yaml # üëà comes from Source 2

    # Source 2: Your Git repo with values
    - repoURL: https://github.com/YourOrg/infrastructure-configs.git
      targetRevision: main
      ref: values # üëà ref name used above

  destination:
    server: https://kubernetes.default.svc
    namespace: redis

  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

Key points:

- `sources:` (plural) lets you define **multiple inputs**
- Second source has `ref: values`
- In the Helm source, you use:
  `valueFiles: [ "$values/values/redis-prod.yaml" ]`
  ‚Üí `$values` = the `ref` of the Git source
  ‚Üí `values/redis-prod.yaml` = path inside that Git repo

This way you **properly** use:

- Remote Helm chart for logic
- Your Git repo for environment-specific values

And you avoid the broken behavior of trying to reference local paths in `valueFiles` with a pure Helm repo source.

## üö® Common Pitfalls with Community Helm + Values

Here are the things that bite people all the time:

---

### üî¥ 1. Assuming `valueFiles` can point to your own Git repo

‚ùå Wrong:

```yaml
helm:
  valueFiles:
    - ../../my-values/redis-prod.yaml
```

This path is **not visible** when using `repoURL` as a Helm repo (e.g. Bitnami). Argo CD only sees **what the chart bundle contains**, not your own folder structure.

‚úÖ Fix:

- Use `helm.values: |` and paste your content, **or**
- Copy chart to your repo and use _Type 3_ (Helm from Git), **or**
- Use multi-source applications (advanced pattern)

---

### üî¥ 2. Wrong parameter names when using `helm.parameters`

If your `values.yaml` has:

```yaml
replica:
  replicaCount: 2
```

You must use:

```yaml
parameters:
  - name: replica.replicaCount
    value: "3"
```

Not:

```yaml
# ‚ùå Will not work
parameters:
  - name: replicaCount
```

Always think in **dotted path**.

---

### üî¥ 3. Forgetting to update `targetRevision` when chart changes

If chart version is `18.3.2` and you use:

```yaml
targetRevision: 18.3.2
```

Argo CD will **never update** Redis when Bitnami releases `18.4.0` ‚Äî that‚Äôs by design (GitOps = pinned versions).

If you want a newer chart version ‚Üí you must manually change `targetRevision` in Git.

---

### üî¥ 4. Mixing `helm.values` and `helm.parameters` in confusing ways

You _can_ use both:

```yaml
helm:
  values: |
    architecture: replication
    replica:
      replicaCount: 2
  parameters:
    - name: replica.replicaCount
      value: "3"
```

But then:

- `parameters` will **override** what‚Äôs in `values`
- This gets confusing over time

Best practice:

- Use **either** mostly `values:` **or** mostly `parameters`
- Keep overrides obvious

---

### üî¥ 5. Forgetting namespace

Many Helm charts install into `default` by default. In Argo CD, the **destination namespace** controls where manifests go (unless chart hardcodes namespace).

Always set:

```yaml
destination:
  server: https://kubernetes.default.svc
  namespace: redis
```

And optionally:

```yaml
syncOptions:
  - CreateNamespace=true
```

---

## ‚úçüèª Final Example ‚Äî Community Helm + Inline Values + Parameters

Here‚Äôs a **nice, realistic Redis example** combining best practices:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: redis-community
  namespace: argo-cd
spec:
  project: default

  source:
    repoURL: https://charts.bitnami.com/bitnami
    chart: redis
    targetRevision: 18.3.2
    helm:
      values: |
        architecture: replication

        replica:
          replicaCount: 2

        auth:
          enabled: true
          password: "super-secret"

        metrics:
          enabled: true

      parameters:
        - name: master.persistence.size
          value: 8Gi

  destination:
    server: https://kubernetes.default.svc
    namespace: redis

  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
      - ServerSideApply=true
```

- `values:` ‚Üí main configuration in a structured way
- `parameters:` ‚Üí small overrides (like disk size)
- Clean, clear, and fully declarative.
