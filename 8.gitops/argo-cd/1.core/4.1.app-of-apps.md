# üöÄ **Argo CD ‚ÄúApp of Apps‚Äù Pattern**

The **App of Apps** pattern is a GitOps design where **one Argo CD Application manages many other Applications**.

Think of it as:

> **A parent application that creates and manages child applications ‚Äî all driven from Git.**

This is the foundational pattern for:

- Multi-environment GitOps
- Multi-cluster GitOps
- Platform engineering
- Environment bootstrapping
- Fully declarative Argo CD configuration

Let‚Äôs break it down.

---

## ‚ùì **Why App of Apps Exists**

Without the App of Apps pattern, you would need to manually create:

- app-dev.yaml
- app-stage.yaml
- app-prod.yaml
- app-monitoring.yaml
- app-networking.yaml
- app-ingress.yaml
- app-databases.yaml
- app-backend.yaml
- app-frontend.yaml

‚Ä¶hundreds of Application files
‚Ä¶manually applied to Argo CD.

This doesn't scale.

**App of Apps solves this by letting one parent app manage everything else.**

---

## üå≥ **What App of Apps Actually Means**

It simply means:

‚û°Ô∏è The parent Argo CD Application points to a **Git directory**  
‚û°Ô∏è That directory contains **child Application YAML files**  
‚û°Ô∏è Argo CD applies those child Applications  
‚û°Ô∏è Each child Application then deploys its own app

### Visualized:

```mermaid
graph TD
   A[Parent App <br> root-application] --> B[App: networking]
   A --> C[App: monitoring]
   A --> D[App: redis]
   A --> E[App: backend]
   A --> F[App: frontend]
```

---

## üì¶ **App of Apps Directory Structure Example**

```text
environments/
  prod/
    apps/
      ingress.yaml
      cert-manager.yaml
      monitoring.yaml
      backend.yaml
      frontend.yaml
  dev/
    apps/
      redis.yaml
      backend.yaml
      frontend.yaml
```

Each file above is **a full Argo CD Application object**.

---

## üü¶ **The Parent Application**

A simple example of the parent App:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-root
spec:
  project: default
  source:
    repoURL: https://github.com/company/platform-config
    path: environments/prod/apps # üî• contains all child apps
    targetRevision: main
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

This parent app does **not** deploy workloads directly.  
It only deploys **child Applications**.

---

## üü• **5. Child Application Example**

Inside `environments/prod/apps/backend.yaml`:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: backend
spec:
  project: default
  source:
    repoURL: https://github.com/company/backend
    path: k8s/overlays/prod
    targetRevision: main
  destination:
    server: https://prod.eks.amazonaws.com
    namespace: backend
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

Argo CD will:

- Sync the parent ‚Üí create `backend` Application
- Then sync the child ‚Üí deploy actual backend resources

---

## üß® **Why App of Apps Is Amazing**

### ‚úî Declarative bootstrapping

You can bootstrap a new cluster by applying **one** Application:

```bash
kubectl apply -f platform-root.yaml
```

Argo CD does the rest:

- Installs ingress
- Installs monitoring
- Installs apps
- Installs security stack
- Installs platform tools

### ‚úî GitOps for Argo CD itself

- Even the Applications in Argo CD are managed by Git.
- No UI-clicking.

### ‚úî Modular + Scalable

- Each component is its own Application = perfect isolation.

### ‚úî Environment separation

- dev, stage, prod ‚Üí each has its own root application.

### ‚úî Team separation

- each team owns their Application
- platform team owns the parent folder.

---

## üü© **App of Apps + Multi-Cluster**

Very common real-world pattern:

```ini
cluster-bootstrap/
  dev/
    apps/*.yaml
  stage/
    apps/*.yaml
  prod/
    apps/*.yaml
```

Each cluster has a root app using its own folder.  
This is used heavily in:

- multi-cluster EKS platforms
- multi-team Kubernetes environments
- platform engineering "Golden Path" setups

---

## üß™ **App of Apps + ApplicationSet**

You can combine both patterns:

**Parent Application** ‚Üí manages an **ApplicationSet** ‚Üí generates **many Applications**

Example structure:

```text
platform/
  apps/
    applicationset.yaml
    networking/
    monitoring/
    redis/
    backend/
    frontend/
```

This is great when you want:

- Many microservices
- Many clusters
- Dynamic environment injection
- Auto-scaling deployments

---

## üî¥ **Common Pitfalls (And How to Avoid)**

### ‚ùå Pitfall: Argo CD out-of-sync when child apps change

- **Fix:** Always manage child Apps in Git, not manually.

### ‚ùå Pitfall: Parent app overwrites manually edited children

- **Fix:** Never modify Application CRs directly after sync.

### ‚ùå Pitfall: Using same namespace for parent and child apps

- **Fix:** Put parent apps in `argocd` namespace
  (other apps in their own namespaces)

### ‚ùå Pitfall: Child apps pointing to the same folder as the parent

- **Fix:** Ensure each child points to **its own repo path**.

---

## üîö **Summary**

‚úî **App of Apps = One application that manages many other applications**  
‚úî **Parent app points to a directory of Application YAMLs**  
‚úî **Child applications each deploy a specific microservice or stack**  
‚úî **Used for large-scale GitOps platforms**  
‚úî **Crucial for multi-cluster and environment bootstrapping**  
‚úî **Fully declarative cluster/platform configuration**  
‚úî **Combine with ApplicationSet for dynamic scalable GitOps**
