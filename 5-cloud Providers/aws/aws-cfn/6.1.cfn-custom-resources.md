# ğŸŒŸ **AWS CloudFormation Custom Resources â€“ The Complete Guide**

You're absolutely right to question this! **A pre-signed S3 URL normally provides temporary access to an object in an S3 bucket**, but **CloudFormationâ€™s â€œResponseURLâ€ is different**â€”even though it looks like an S3 URL.

Letâ€™s break it down properly. ğŸ”

---

## ğŸš€ **Understanding CloudFormation's ResponseURL**

### **1ï¸âƒ£ Normal Pre-Signed S3 URL (for file access)**

A typical **S3 pre-signed URL** is generated by **Amazon S3** to allow temporary access to an object **for downloading or uploading**. It acts as a **secure gateway** to a specific S3 file.

**Example:**

- A pre-signed URL for a file download might look like this:
  ```
  https://my-bucket.s3.amazonaws.com/myfile.txt?AWSAccessKeyId=XYZ&Signature=abc123&Expires=1670000000
  ```
- If you **open this URL in a browser**, you can **download the file** from S3.

âœ… **Used for:**

- Allowing a user to **upload or download** a file temporarily.
- Generated using **Boto3, AWS SDK, or AWS CLI**.

---

### **2ï¸âƒ£ CloudFormation's ResponseURL (Different from S3 Pre-Signed URLs!)**

Now, let's talk about **CloudFormation's ResponseURL**.

- CloudFormation **does NOT actually store responses in S3**.
- Instead, **it generates a temporary HTTPS endpoint that acts as a webhook**.
- This **URL is unique for each custom resource request**.
- Your Lambda function must **send an HTTP PUT request** to this URL to deliver the response.

ğŸ’¡ **So, even though the URL looks like an S3 pre-signed URL, it actually behaves like a temporary webhook**.

---

## ğŸ¯ **How CloudFormation's ResponseURL Works**

### ğŸ”„ **Step-by-Step Process**

1ï¸âƒ£ **CloudFormation starts processing a Custom Resource.**

- It generates a **temporary HTTPS endpoint (ResponseURL)** where the Lambda function must send a response.

2ï¸âƒ£ **CloudFormation passes the ResponseURL to Lambda** in the event data:

```json
{
  "RequestType": "Create",
  "ResponseURL": "https://cloudformation-custom-resource-response.s3.amazonaws.com/temporary-url",
  "StackId": "arn:aws:cloudformation:us-east-1:stack/my-stack/xyz",
  "RequestId": "unique-request-id",
  "LogicalResourceId": "MyCustomResource"
}
```

3ï¸âƒ£ **Lambda function processes the request (e.g., creates an S3 bucket).**

4ï¸âƒ£ **Lambda sends the response using an HTTP PUT request** to CloudFormation's temporary ResponseURL:

```python
import json
import requests

def handler(event, context):
    response_data = {
        "Status": "SUCCESS",
        "PhysicalResourceId": "custom-resource-123",
        "StackId": event["StackId"],
        "RequestId": event["RequestId"],
        "LogicalResourceId": event["LogicalResourceId"],
        "Data": {"Message": "Resource Created Successfully"}
    }

    response_url = event["ResponseURL"]

    # Send response to CloudFormation's temporary endpoint
    requests.put(response_url, data=json.dumps(response_data))

    print("Response sent to CloudFormation")
```

5ï¸âƒ£ **CloudFormation receives the response from the ResponseURL and proceeds with the stack deployment.**

---

## ğŸ”¥ **Why Is CloudFormation's ResponseURL Different?**

- It **looks like** a pre-signed S3 URL but does **not** behave like one.
- It does **not store files in an S3 bucket**.
- It is actually a **temporary HTTP endpoint** created by CloudFormation.
- It **automatically expires** after the stack operation completes.

---

## ğŸ— **Visualizing the Workflow (Mermaid Diagram)**

```mermaid
sequenceDiagram
    participant CFN as AWS CloudFormation
    participant Lambda as AWS Lambda (Custom Resource)
    participant CloudFormationService as CloudFormation Webhook (ResponseURL)

    CFN->>Lambda: Invoke Lambda with Event & ResponseURL
    Lambda->>Lambda: Execute Custom Logic (Create S3, IAM, etc.)
    Lambda->>CloudFormationService: Send Success/Failure Response via HTTP PUT
    CloudFormationService->>CFN: CloudFormation Receives Response
    CFN->>CFN: Continue or Rollback Deployment
```

---

## ğŸ“Œ **Key Takeaways**

âœ… **CloudFormation's ResponseURL is NOT a normal pre-signed S3 URL.**  
âœ… It is a **temporary HTTPS endpoint**, not an actual S3 bucket location.  
âœ… Your Lambda function must **send an HTTP PUT request** to it, not store files in S3.  
âœ… CloudFormation **listens for the response** at this endpoint and then proceeds with the stack deployment.  
âœ… Once CloudFormation finishes processing, **the URL expires** and can no longer be used.

---

ğŸ’¡ **Now you fully understand why CloudFormation's ResponseURL behaves differently!** ğŸš€ Let me know if you need further clarification! ğŸ˜Š

## ğŸ“Œ **Introduction to AWS CloudFormation Custom Resources**

AWS **CloudFormation** allows you to **define and manage infrastructure as code (IaC)**. However, sometimes you need to create **resources that CloudFormation doesnâ€™t support natively**. Thatâ€™s where **Custom Resources** come in!

Custom Resources allow you to **execute custom logic using AWS Lambda, SNS, or S3** during a CloudFormation deployment. They help you:  
âœ… **Create unsupported AWS resources**  
âœ… **Run additional setup scripts** (e.g., initializing databases, fetching external API data)  
âœ… **Trigger automation workflows**

---

## ğŸš€ **How AWS CloudFormation Custom Resources Work**

### ğŸ”„ **Custom Resource Lifecycle**

When CloudFormation encounters a **Custom Resource**, it:  
1ï¸âƒ£ **Sends an event request (Create, Update, Delete)** to an AWS **Lambda function or another AWS service**  
2ï¸âƒ£ The function **processes the request** and performs an action (e.g., creating a resource)  
3ï¸âƒ£ The function **returns a response to CloudFormation** via an S3 pre-signed URL  
4ï¸âƒ£ CloudFormation **continues deployment** based on the response

âœ… **Example Use Cases for Custom Resources:**

- Automatically creating **IAM roles, S3 buckets, or API Gateway settings**
- Fetching **external API data** during stack deployment
- Running **database migrations** on deployment

---

## ğŸ”§ **Step 1: Creating a Custom Resource Using AWS Lambda**

We will create a **Custom Resource** that automatically creates an **S3 Bucket** using a Lambda function.

---

## ğŸ“‚ **Step 2: Define the Custom Resource in CloudFormation**

Create a **CloudFormation YAML template (`custom-resource.yaml`)**:

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Resources:
  MyLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Runtime: python3.8
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse

          s3 = boto3.client('s3')

          def handler(event, context):
              request_type = event['RequestType']
              response_data = {}
              
              if request_type == 'Create':
                  bucket_name = "my-custom-bucket-" + event['RequestId']
                  s3.create_bucket(Bucket=bucket_name)
                  response_data['BucketName'] = bucket_name

              elif request_type == 'Delete':
                  bucket_name = event['ResourceProperties']['BucketName']
                  s3.delete_bucket(Bucket=bucket_name)

              cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaS3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:CreateBucket
                  - s3:DeleteBucket
                Resource: "*"

  MyCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt MyLambdaFunction.Arn
```

---

## ğŸ”„ **Step 3: Deploy the Custom Resource**

1ï¸âƒ£ **Create the CloudFormation stack:**

```sh
aws cloudformation create-stack --stack-name my-custom-resource --template-body file://custom-resource.yaml --capabilities CAPABILITY_NAMED_IAM
```

2ï¸âƒ£ **Check the deployment progress:**

```sh
aws cloudformation describe-stacks --stack-name my-custom-resource
```

3ï¸âƒ£ **Verify the S3 bucket was created:**

```sh
aws s3 ls
```

---

## ğŸ”¥ **Step 4: Handling Responses in AWS Lambda**

CloudFormation expects a **response** from the custom resource. The Lambda function must send a response to CloudFormation via **cfnresponse**:

### **Example of Sending a Success Response**

```python
import json
import boto3
import cfnresponse

def handler(event, context):
    response_data = {"Message": "Resource Created Successfully"}
    cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
```

### **Example of Sending a Failure Response**

```python
import json
import cfnresponse

def handler(event, context):
    cfnresponse.send(event, context, cfnresponse.FAILED, {"Message": "Something went wrong"})
```

---

## âš™ **Step 5: Managing Custom Resource Lifecycle**

âœ… **Create Event** â€“ AWS Lambda executes the logic when the CloudFormation stack is created.  
âœ… **Update Event** â€“ If you modify the stack, AWS Lambda re-runs the function.  
âœ… **Delete Event** â€“ AWS Lambda cleans up resources when the stack is deleted.

---

## ğŸ›‘ **Step 6: Deleting the Stack**

To remove the custom resource and its associated AWS resources:

```sh
aws cloudformation delete-stack --stack-name my-custom-resource
```

This will trigger the **Delete event** in Lambda, allowing cleanup before the stack is destroyed.

---

## ğŸ¯ **Best Practices for CloudFormation Custom Resources**

âœ… **Use minimal permissions** â€“ Assign only necessary IAM permissions to Lambda.  
âœ… **Handle all event types** â€“ Always check for `Create`, `Update`, and `Delete` events in Lambda.  
âœ… **Use retries and timeouts** â€“ AWS Lambda functions should be designed to handle failures gracefully.  
âœ… **Log everything** â€“ Use AWS **CloudWatch Logs** to debug Lambda execution issues.  
âœ… **Use built-in AWS resources when possible** â€“ Only use custom resources if **CloudFormation doesnâ€™t support the resource natively**.

---

## ğŸš€ **Conclusion**

AWS **CloudFormation Custom Resources** allow you to **extend AWS CloudFormation capabilities** by integrating **Lambda functions, external APIs, and more**. They are essential when you need automation beyond what CloudFormation natively offers.

### âœ… **What You Learned Today:**

âœ” What AWS Custom Resources are  
âœ” How to create a Custom Resource using AWS Lambda  
âœ” How to return responses to CloudFormation  
âœ” Best practices for managing lifecycle events

ğŸ”¥ **Next Steps:**  
ğŸ”¹ Try integrating **AWS SNS, DynamoDB, or API Gateway**  
ğŸ”¹ Use **AWS SDKs** in Lambda to interact with external services  
ğŸ”¹ Implement **error handling and monitoring** in your Lambda function

---

ğŸ’¡ **Do you want more real-world examples or an advanced tutorial? Let me know!** ğŸš€
