# ğŸ— **Understanding Global Secondary Indexes (GSI) in DynamoDB â€” For SQL Pros**

If you come from a SQL internals background, you're used to tight control over storage, partitioning, and indexes. Letâ€™s translate DynamoDBâ€™s **GSI (Global Secondary Index)** to SQL terms â€” with full internal layout breakdowns.

This guide mirrors our LSI deep-dive, but shows how GSIs differ:

- Separate physical storage
- Alternate partition and sort keys
- Asynchronous updates
- Separate read/write capacity

Letâ€™s break it all down!

---

## ğŸ“Œ **1. What is a GSI?**

A **Global Secondary Index (GSI)** is a fully **separate indexed table** in DynamoDB. It allows you to **query on a different partition key** (and optional sort key), which is **not possible with LSIs**.

### âœ… GSI Highlights

- â— **Can use different partition key** than the base table.
- âœ… **Can be added anytime** (not just at table creation).
- ğŸ§  **Exists as a separate index table**, **not in same partition** like LSI.
- ğŸ” **Updated asynchronously**, not immediately on write.
- âš–ï¸ **Own read/write capacity**, not shared with base table.

> ğŸ“ Think of a GSI as a **materialized, query-optimized table**, created from selected fields in the base table.

---

## ğŸ§© **2. Original Table Structure (No Index Yet)**

Letâ€™s say we have an `Orders` table:

- **Partition Key:** `OrderID`
- **Attributes:** `CustomerID`, `OrderStatus`, `OrderDate`

```text
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ Base Table View (sorted by OrderID)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[ORD-001] â†’ {
    OrderID: ORD-001,
    CustomerID: User123,
    OrderStatus: Completed,
    OrderDate: 2024-03-09
}

[ORD-002] â†’ {
    OrderID: ORD-002,
    CustomerID: User456,
    OrderStatus: Pending,
    OrderDate: 2024-03-08
}

[ORD-003] â†’ {
    OrderID: ORD-003,
    CustomerID: User123,
    OrderStatus: Completed,
    OrderDate: 2024-03-07
}
```

With only this structure, you can **only query by `OrderID`**, not by `OrderStatus`.

---

## ğŸ”„ **3. Adding a GSI on `OrderStatus`**

Letâ€™s create a **Global Secondary Index**:

- **GSI Name:** `OrderStatusIndex`
- **Partition Key:** `OrderStatus`
- **Sort Key:** `OrderID`

---

## ğŸ“¦ **GSI Partition Structure (ProjectionType: ALL)**

### ğŸ”¹ Data Stored in GSI

- `OrderStatus` (Partition Key)
- `OrderID` (Sort Key)
- All other attributes (e.g., `CustomerID`, `OrderDate`, etc.)

```text
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ GSI: OrderStatusIndex (Projection: ALL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Partition: Completed
  â”œâ”€â”€ ORD-001 â†’ { OrderID, OrderStatus, CustomerID, OrderDate }
  â””â”€â”€ ORD-003 â†’ { OrderID, OrderStatus, CustomerID, OrderDate }

Partition: Pending
  â””â”€â”€ ORD-002 â†’ { OrderID, OrderStatus, CustomerID, OrderDate }
```

ğŸ§  This GSI is a separate DynamoDB structure with its own storage and capacity.

---

## ğŸ” **4. Projection Types in GSIs**

| Projection Type | GSI Contains                   | Base Table Read Needed? | Use Case                                      |
| --------------- | ------------------------------ | ----------------------- | --------------------------------------------- |
| `KEYS_ONLY`     | Only GSI PK + SK               | âœ… Yes                  | Minimal storage                               |
| `INCLUDE`       | Keys + selected attributes     | âŒ No (partial)         | Save space + avoid extra read for some fields |
| `ALL`           | Full item copy from base table | âŒ No                   | Fastest reads, highest storage overhead       |

### âœ… KEYS_ONLY View

```text
Partition: Completed
  â”œâ”€â”€ ORD-001 â†’ { OrderStatus, OrderID }
  â””â”€â”€ ORD-003 â†’ { OrderStatus, OrderID }

Partition: Pending
  â””â”€â”€ ORD-002 â†’ { OrderStatus, OrderID }
```

ğŸ“Œ Query returns just keys. Use returned keys to fetch from base table.

### âœ… INCLUDE View (e.g., `CustomerID` only)

```text
Partition: Completed
  â”œâ”€â”€ ORD-001 â†’ { OrderStatus, OrderID, CustomerID }
  â””â”€â”€ ORD-003 â†’ { OrderStatus, OrderID, CustomerID }

Partition: Pending
  â””â”€â”€ ORD-002 â†’ { OrderStatus, OrderID, CustomerID }
```

### âœ… ALL View (Full Record Copy)

```text
Partition: Completed
  â”œâ”€â”€ ORD-001 â†’ { OrderStatus, OrderID, CustomerID, OrderDate }
  â””â”€â”€ ORD-003 â†’ { OrderStatus, OrderID, CustomerID, OrderDate }
```

---

## ğŸ› ï¸ **5. Creating a GSI via AWS CLI**

```sh
aws dynamodb update-table \
  --table-name Orders \
  --attribute-definitions '[
    { "AttributeName": "OrderStatus", "AttributeType": "S" },
    { "AttributeName": "OrderID", "AttributeType": "S" }
  ]' \
  --global-secondary-index-updates '[
    { "Create": {
      "IndexName": "OrderStatusIndex",
      "KeySchema": [
        { "AttributeName": "OrderStatus", "KeyType": "HASH" },
        { "AttributeName": "OrderID", "KeyType": "RANGE" }
      ],
      "Projection": { "ProjectionType": "ALL" },
      "ProvisionedThroughput": { "ReadCapacityUnits": 5, "WriteCapacityUnits": 5 }
    }}
  ]'
```

---

## ğŸ” **6. Querying the GSI**

### ğŸ”¹ Query Base Table

```sh
aws dynamodb query \
  --table-name Orders \
  --key-condition-expression "OrderID = :id" \
  --expression-attribute-values '{":id": {"S": "ORD-001"}}'
```

### ğŸ”¹ Query GSI by `OrderStatus`

```sh
aws dynamodb query \
  --table-name Orders \
  --index-name OrderStatusIndex \
  --key-condition-expression "OrderStatus = :status" \
  --expression-attribute-values '{":status": {"S": "Completed"}}'
```

ğŸ“Œ **GSI enables new access patterns** without touching the base table directly!

---

## ğŸ¯ **7. GSI vs. LSI Summary Table**

| Feature               | LSI                          | GSI                       |
| --------------------- | ---------------------------- | ------------------------- |
| Partition Key         | Same as base table           | Different from base table |
| Sort Key              | Different                    | Optional                  |
| Storage Location      | Same partition as base table | Separate partitions       |
| Write Behavior        | Synchronous                  | Asynchronous              |
| Query Scope           | Single partition             | Across all partitions     |
| Can add after create? | âŒ No                        | âœ… Yes                    |
| Read/Write Capacity   | Shared with base table       | Separate provisioning     |

---

## ğŸ§  Final Thoughts for SQL Pros

âœ” Think of a GSI as a **replicated, query-optimized table**. Itâ€™s like a **materialized view** indexed by another key.

âœ” Unlike LSI (non-clustered within same partition), a GSI is its own indexed storage layout with performance tradeoffs:

- Fast query access
- Eventual consistency
- Separate cost management

ğŸ’¡ Plan GSIs when you know your read patterns! Want analytics by `CustomerID` or reports by `OrderStatus`? GSIs are your DynamoDB-side optimization weapon.
