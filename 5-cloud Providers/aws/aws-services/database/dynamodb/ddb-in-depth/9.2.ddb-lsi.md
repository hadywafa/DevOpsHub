# ğŸ— **Understanding Local Secondary Indexes (LSI) in DynamoDB**

As a SQL veteran, you're used to index pages, clustered/non-clustered layouts, and precise I/O control. DynamoDB takes a different approach but offers indexing superpowers if you understand the internal layout.

This guide walks through the full data layout for a table using **LSI** â€” starting from the original item layout, then showing how the partition data looks when using each `ProjectionType`: `KEYS_ONLY`, `INCLUDE`, and `ALL`.

## ğŸ“Œ **1. What is an LSI?**

A **Local Secondary Index (LSI)** in DynamoDB is an **alternate sorted view of the same partitioned data**, enabling efficient querying based on a **different sort key**.

ğŸ”¹ **Key Points:**

- **LSI does NOT create a separate table.**
- **It is stored within the same partition** as the base table.
- **It allows sorting by a different attribute** while keeping the same **partition key**.
- **Updates are synchronous**â€”when data changes in the base table, the LSI updates instantly.
- **LSI improves query efficiency** by avoiding full table scans.

âœ… **Think of LSI like an SQL non-clustered index**â€”a data structure that **reorders the same partitioned records** based on an alternate key.

---

## ğŸ” **5. Whatâ€™s Actually Stored in an LSI?**

LSI **does NOT store the full table**â€”it only stores **certain attributes** based on **projection settings**.

| **Projection Type** | **Data Stored in LSI?**                                |
| ------------------- | ------------------------------------------------------ |
| **KEYS_ONLY**       | Only **Partition Key + LSI Sort Key**                  |
| **INCLUDE**         | Partition Key + LSI Sort Key + **selected attributes** |
| **ALL**             | A copy of **all attributes from the base table**       |

ğŸ’¡ **This means that LSI is a "sorted view" of data within a partition rather than a full duplicate of the table.**

---

## ğŸ—‚ï¸ Original Base Table Layout (No Index Yet)

We'll use a sample `Orders` table:

### ğŸ”¹ Table Schema

- **Partition Key:** `CustomerID`
- **Sort Key:** `OrderID`
- **Attributes:** `OrderDate`, `TotalAmount`

### ğŸ”¢ Sample Items

```txt
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ Base Table View (sorted by OrderID)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[ORD-001] â†’ {
    CustomerID: User123,
    OrderID: ORD-001,
    OrderDate: 2024-03-09,
    TotalAmount: $250
}

[ORD-002] â†’ {
    CustomerID: User123,
    OrderID: ORD-002,
    OrderDate: 2024-03-08,
    TotalAmount: $120
}

[ORD-003] â†’ {
    CustomerID: User123,
    OrderID: ORD-003,
    OrderDate: 2024-03-07,
    TotalAmount: $300
}
```

ğŸ§  Without any LSI, you can only **query using the base sort key** `OrderID`. Sorting/filtering by `OrderDate` requires a **full table scan**.

---

## ğŸ”„ Adding an LSI: Sorted by `OrderDate`

All LSIs:

- Must be defined at table creation
- Share the same **partition key** (`CustomerID`)
- Use a different **sort key** (here: `OrderDate`)
- Are stored **in the same partition**, but with different internal layouts based on projection

---

## ğŸ” Partition View: `ProjectionType: KEYS_ONLY`

### ğŸ”¹ Whatâ€™s stored?

- `CustomerID` (PK)
- `OrderDate` (alternate sort key)

```text
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ Base Table View (sorted by OrderID)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
....etc
....etc
....etc
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ LSI: OrderDateIndex (KEYS_ONLY)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Partition: User123
  â”œâ”€â”€ 2024-03-07 â†’ { CustomerID: User123, OrderDate: 2024-03-07 }
  â”œâ”€â”€ 2024-03-08 â†’ { CustomerID: User123, OrderDate: 2024-03-08 }
  â””â”€â”€ 2024-03-09 â†’ { CustomerID: User123, OrderDate: 2024-03-09 }
```

ğŸ“Œ Youâ€™ll **need to read from base table** to fetch other fields like `OrderID`, `TotalAmount`.

---

## ğŸ” Partition View: `ProjectionType: INCLUDE`

### ğŸ”¹ Whatâ€™s stored?

- `CustomerID`, `OrderDate`
- Only selected fields (e.g., `TotalAmount`)

```json
"Projection": {
  "ProjectionType": "INCLUDE",
  "NonKeyAttributes": ["TotalAmount"]
}
```

```text
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ Base Table View (sorted by OrderID)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
....etc
....etc
....etc
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ LSI: OrderDateIndex (INCLUDE: TotalAmount)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Partition: User123
  â”œâ”€â”€ 2024-03-07 â†’ { CustomerID: User123, OrderDate: 2024-03-07, TotalAmount: 300 }
  â”œâ”€â”€ 2024-03-08 â†’ { CustomerID: User123, OrderDate: 2024-03-08, TotalAmount: 120 }
  â””â”€â”€ 2024-03-09 â†’ { CustomerID: User123, OrderDate: 2024-03-09, TotalAmount: 250 }
```

ğŸ“Œ You can get `TotalAmount` **from the index**, but still need a **second read** if you want `OrderID`.

---

## ğŸ” Partition View: `ProjectionType: ALL`

### ğŸ”¹ Whatâ€™s stored?

- **Everything**: Full item copy from base table

```text
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ Base Table View (sorted by OrderID)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
....etc
....etc
....etc
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‚ LSI: OrderDateIndex (ALL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Partition: User123
  â”œâ”€â”€ 2024-03-07 â†’ {
        CustomerID: User123,
        OrderID: ORD-003,
        OrderDate: 2024-03-07,
        TotalAmount: 300
      }
  â”œâ”€â”€ 2024-03-08 â†’ {
        CustomerID: User123,
        OrderID: ORD-002,
        OrderDate: 2024-03-08,
        TotalAmount: 120
      }
  â””â”€â”€ 2024-03-09 â†’ {
        CustomerID: User123,
        OrderID: ORD-001,
        OrderDate: 2024-03-09,
        TotalAmount: 250
      }
```

ğŸ“Œ Everything you need is **available directly from the LSI**. No extra read required â€” but you're storing more.

---

## ğŸ”„ **6. What Happens During Reads & Writes?**

### âœ… **Insert New Order for `User123`**

```sh
aws dynamodb put-item \
    --table-name Orders \
    --item '{
        "CustomerID": {"S": "User123"},
        "OrderID": {"S": "ORD-004"},
        "OrderDate": {"S": "2024-03-06"},
        "TotalAmount": {"N": "200"}
    }'
```

ğŸ”¹ **Internally:**
1ï¸âƒ£ **DynamoDB writes the item to the base table** (sorted by `OrderID`).  
2ï¸âƒ£ **DynamoDB also updates the LSI (`OrderDateIndex`)** (sorted by `OrderDate`).

ğŸ“Œ **Now, the LSI structure becomes:**

| **CustomerID (PK)** | **OrderDate (Sort Key - LSI)** | **OrderID** | **TotalAmount** |
| ------------------- | ------------------------------ | ----------- | --------------- |
| `User123`           | `2024-03-06`                   | `ORD-004`   | `$200`          |
| `User123`           | `2024-03-07`                   | `ORD-003`   | `$300`          |
| `User123`           | `2024-03-08`                   | `ORD-002`   | `$120`          |
| `User123`           | `2024-03-09`                   | `ORD-001`   | `$250`          |

âœ… **LSI was updated automatically!**

---

## ğŸ”¥ **7. Querying LSI vs. Base Table**

### âœ… **Query the Base Table (Sorted by `OrderID`)**

```sh
aws dynamodb query \
    --table-name Orders \
    --key-condition-expression "CustomerID = :cust" \
    --expression-attribute-values '{":cust": {"S": "User123"}}'
```

ğŸ”¹ **Returns results sorted by `OrderID`.**

---

### âœ… **Query the LSI (`OrderDateIndex`, Sorted by `OrderDate`)**

```sh
aws dynamodb query \
    --table-name Orders \
    --index-name OrderDateIndex \
    --key-condition-expression "CustomerID = :cust" \
    --expression-attribute-values '{":cust": {"S": "User123"}}'
```

ğŸ”¹ **Returns results sorted by `OrderDate`.**

ğŸ“Œ **Querying an LSI lets us efficiently retrieve data in a different order, WITHOUT scanning the full table!** ğŸš€

---

## ğŸ— **8. Creating a Local Secondary Index (LSI) in DynamoDB**

### ğŸ“Œ **1. Key Rules Before Creating an LSI**

ğŸ”¹ **LSI must be created at the same time as the table**â€”you **cannot add an LSI to an existing table**.  
ğŸ”¹ **You must define an alternate Sort Key for the LSI** while keeping the **same Partition Key**.  
ğŸ”¹ **LSI resides in the same partition as the base table** and **shares the tableâ€™s read/write capacity**.  
ğŸ”¹ **LSI supports three projection types:**

- `KEYS_ONLY`: Stores only Partition Key + Sort Key.
- `INCLUDE`: Stores additional attributes.
- `ALL`: Stores all attributes from the base table.

---

### ğŸ”„ **2. How to Create an LSI Using AWS CLI**

ğŸ“Œ **Example: Creating an `Orders` Table with an LSI (`OrderDateIndex`)**

```sh
aws dynamodb create-table \
    --table-name Orders \
    --attribute-definitions '[
        {
            "AttributeName": "CustomerID",
            "AttributeType": "S"
        },
        {
            "AttributeName": "OrderID",
            "AttributeType": "S"
        },
        {
            "AttributeName": "OrderDate",
            "AttributeType": "S"
        }
    ]' \
    --key-schema '[
        {
            "AttributeName": "CustomerID",
            "KeyType": "HASH"
        },
        {
            "AttributeName": "OrderID",
            "KeyType": "RANGE"
        }
    ]' \
    --local-secondary-indexes '[
        {
            "IndexName": "OrderDateIndex",
            "KeySchema": [
                {
                    "AttributeName": "CustomerID",
                    "KeyType": "HASH"
                },
                {
                    "AttributeName": "OrderDate",
                    "KeyType": "RANGE"
                }
            ],
            "Projection": {
                "ProjectionType": "ALL"
            }
        }
    ]' \
    --provisioned-throughput '{
        "ReadCapacityUnits": 5,
        "WriteCapacityUnits": 5
    }'
```

---

## ğŸ¯ **9. Key Takeaways**

âœ” **LSI is NOT a separate table but a separate indexed structure within the same partition.**  
âœ” **It allows querying using an alternate sort key without modifying the base table.**  
âœ” **LSI data is stored differently but still refers to the same records.**  
âœ” **It shares the same read/write capacity as the base table.**  
âœ” **LSI updates are synchronousâ€”changes in the base table are immediately reflected.**

---

## ğŸ§  Summary Table: LSI Projection Options

| Projection Type | Whatâ€™s Stored in Index            | Need Base Table Read?     | Ideal For...                       |
| --------------- | --------------------------------- | ------------------------- | ---------------------------------- |
| `KEYS_ONLY`     | Only PK + LSI Sort Key            | âœ… Yes                    | Minimal storage                    |
| `INCLUDE`       | Keys + selected attributes        | âŒ No (if attrs included) | Filtering with limited fields      |
| `ALL`           | Full copy of item from base table | âŒ No                     | Fast reads at cost of more storage |

---

## ğŸ§¬ Internals for SQL Folks (ğŸ‘€ Real Talk)

ğŸ”¸ Think of LSI as **non-clustered indexes** in SQL â€” **copying key columns and optionally data columns**, but not the entire table.

ğŸ”¸ Difference: LSI lives **inside the partition** of the base table â€” itâ€™s not a separate index file like SQL.

ğŸ”¸ Yes, in `ALL` projection, **Dynamo duplicates data inside the same partition** â€” itâ€™s a tradeoff between speed and space.
