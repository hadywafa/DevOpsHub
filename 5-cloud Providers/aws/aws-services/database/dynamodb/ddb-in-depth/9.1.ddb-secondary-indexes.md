# ğŸ” **DynamoDB Secondary Indexes: From Basics to Internal Mechanisms**

A **secondary index** is a separate data structure in DynamoDB that allows querying data using an **alternative key** instead of the **primary key**.

ğŸ“Œ **Why Use a Secondary Index?**

- DynamoDB tables have a **primary key** (either a **partition key** or a **partition key + sort key**).
- Without a secondary index, queries can **only retrieve data based on the primary key**.
- Secondary indexes **allow queries based on non-primary attributes**, improving flexibility and performance.

ğŸ‘‰ **Key Question:** Does a secondary index **store a full copy of the table?**  
ğŸ”¹ **No!** Instead, it **duplicates only specific attributes**, depending on the **projection settings** you choose.

---

## ğŸ“Œ **Types of Secondary Indexes**

DynamoDB supports two types of secondary indexes:

| Feature                 | **Global Secondary Index (GSI)**     | **Local Secondary Index (LSI)**               |
| ----------------------- | ------------------------------------ | --------------------------------------------- |
| **Partition Key**       | âœ… Can be different from base table  | âŒ Must match base table                      |
| **Sort Key**            | âœ… Optional                          | âœ… Required                                   |
| **Data Storage**        | âœ… Stored separately from base table | âŒ Stored in the same partition as base table |
| **Query Scope**         | âœ… Queries across partitions         | âœ… Queries only within a partition            |
| **Update Latency**      | âŒ Eventually consistent             | âœ… Strongly consistent                        |
| **Read/Write Capacity** | âœ… Uses separate RCUs/WCUs           | âŒ Shares capacity with base table            |

---

## ğŸ—ï¸ **How Does a Global Secondary Index (GSI) Work Internally?**

### âœ… **3.1 What is a GSI?**

A **Global Secondary Index (GSI)** allows **querying across all partitions** using an alternative **partition key and optional sort key**.

ğŸ“Œ **Key Features of GSI:**

- âœ… **Partition Key can be different** from the base table.
- âœ… Stored **separately** from the base table.
- âœ… Can **span across all partitions**, allowing for **global queries**.
- âœ… Requires **separate read and write capacity units (RCUs/WCUs)**.
- âŒ **Does not support strongly consistent reads** (only eventually consistent reads).

---

### ğŸ”„ **3.2 How GSIs Store Data?**

ğŸ”¹ **GSIs Do NOT Use Pointers**

- Unlike **relational database indexes**, DynamoDB **duplicates** some data into the GSI instead of just storing a pointer to the base table.
- This **avoids additional lookup overhead** and speeds up queries.

ğŸ“Œ **Example Table (Orders Table)**

| **OrderID (PK)** | **CustomerID** | **Status**  | **OrderDate** | **TotalAmount** |
| ---------------- | -------------- | ----------- | ------------- | --------------- |
| `12345`          | `User123`      | `Completed` | `2024-03-09`  | `$250`          |
| `67890`          | `User456`      | `Pending`   | `2024-03-08`  | `$120`          |

ğŸ“Œ **GSI Schema (`StatusIndex`)**

| **GSI Partition Key (`Status`)** | **GSI Sort Key (`OrderDate`)** | **OrderID (PK)** | **CustomerID** | **TotalAmount** |
| -------------------------------- | ------------------------------ | ---------------- | -------------- | --------------- |
| `Completed`                      | `2024-03-09`                   | `12345`          | `User123`      | `$250`          |
| `Pending`                        | `2024-03-08`                   | `67890`          | `User456`      | `$120`          |

ğŸ”¹ **This means:**

- The **GSI stores a copy of the attributes** needed for indexing.
- The base tableâ€™s **OrderID** and other attributes **are stored in the index, but the partitioning is now based on `Status` instead of `OrderID`**.

---

### ğŸ”„ **3.3 How GSIs Handle Writes & Updates?**

ğŸ”¹ **Data Duplication:**  
When an item is added to the base table, DynamoDB **automatically adds an entry to the GSI**.

ğŸ“Œ **GSI Update Scenarios**

| Scenario                          | **GSI Behavior**                                               |
| --------------------------------- | -------------------------------------------------------------- |
| **New item inserted**             | âœ… If indexed attributes exist, a copy is inserted in the GSI. |
| **Indexed attribute updated**     | âœ… Old entry removed, new entry inserted.                      |
| **Indexed attribute removed**     | âŒ Entry removed from GSI (if key attributes are missing).     |
| **Non-indexed attribute updated** | âŒ No impact on GSI.                                           |

ğŸ”¹ **Replication is Asynchronous:**

- Writes to a GSI **do not happen instantly**â€”they propagate **eventually**.
- This is why **strongly consistent reads are not supported** on GSIs.

---

## ğŸ—ï¸ **How Does a Local Secondary Index (LSI) Work Internally?**

### âœ… **4.1 What is an LSI?**

A **Local Secondary Index (LSI)** allows **sorting within the same partition** using an alternative **sort key**.

ğŸ“Œ **Key Features of LSI:**

- âœ… Uses **the same partition key** as the base table.
- âœ… Allows a **different sort key** for querying.
- âœ… **Stored within the same partition** as the base table.
- âœ… **Supports strongly consistent reads**.
- âŒ Shares **RCUs & WCUs** with the base table.

---

### ğŸ”„ **4.2 How LSIs Store Data?**

ğŸ“Œ **Example: LSI for Sorting Orders by Date**

| **CustomerID (PK)** | **OrderID (Sort Key)** | **OrderDate** |
| ------------------- | ---------------------- | ------------- |
| `User123`           | `Order#1`              | `2024-03-09`  |
| `User123`           | `Order#2`              | `2024-03-07`  |

ğŸ”¹ **Since LSIs share the same partition, queries are much faster than GSIs**.  
ğŸ”¹ **The index data is colocated with the main table data**, reducing storage overhead.

---

### ğŸ”„ **4.3 How LSIs Handle Writes & Updates?**

ğŸ”¹ **Data Storage:**

- LSIs **do not create separate partitions**â€”instead, they **store extra data inside the existing partition**.
- Writes to LSIs **happen synchronously** with the main table.

ğŸ“Œ **LSI Update Scenarios**

| Scenario                          | **LSI Behavior**                                                   |
| --------------------------------- | ------------------------------------------------------------------ |
| **New item inserted**             | âœ… If indexed attributes exist, a copy is stored in the partition. |
| **Indexed attribute updated**     | âœ… The index is updated **immediately**.                           |
| **Indexed attribute removed**     | âŒ Entry removed from LSI (if key attributes are missing).         |
| **Non-indexed attribute updated** | âŒ No impact on LSI.                                               |

ğŸ”¹ **Replication is Synchronous:**

- LSIs **update at the same time as the base table**, which allows **strongly consistent reads**.

---

## ğŸ”„ **Key Differences: GSI vs. LSI**

| Feature                 | **Global Secondary Index (GSI)**    | **Local Secondary Index (LSI)**    |
| ----------------------- | ----------------------------------- | ---------------------------------- |
| **Partition Key**       | âœ… Can be different from base table | âŒ Must match base table           |
| **Sort Key**            | âœ… Optional                         | âœ… Required                        |
| **Data Storage**        | âœ… Stored separately                | âŒ Stored in the same partition    |
| **Query Scope**         | âœ… Queries across partitions        | âœ… Queries within a partition      |
| **Update Latency**      | âŒ Eventually consistent            | âœ… Strongly consistent             |
| **Read/Write Capacity** | âœ… Uses separate RCUs/WCUs          | âŒ Shares capacity with base table |

---

## ğŸ¯ **When to Use GSI vs. LSI?**

| **Use Case**                                                   | **Best Choice** |
| -------------------------------------------------------------- | --------------- |
| Query across **multiple partitions** using a non-key attribute | âœ… **GSI**      |
| Query within the **same partition** using a different sort key | âœ… **LSI**      |
| Reduce read costs for non-key attribute queries                | âœ… **GSI**      |
| Need strongly consistent reads                                 | âœ… **LSI**      |

---

## ğŸš€ **Key Takeaways**

âœ” **GSIs allow querying across partitions but require additional capacity.**  
âœ” **LSIs are faster but can only be used within the same partition.**  
âœ” **GSIs update asynchronously, while LSIs update synchronously.**  
âœ” **Choose GSIs for flexibility and LSIs for speed.**

Now, you **fully understand** how **GSIs & LSIs work internally!** ğŸš€
