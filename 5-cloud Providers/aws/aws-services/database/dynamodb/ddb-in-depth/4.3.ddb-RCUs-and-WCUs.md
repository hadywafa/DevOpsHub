# ğŸ”¥ **AWS DynamoDB: RCUs, WCUs**

Unlike traditional databases that charge based on **CPU, RAM, or storage**, DynamoDB **charges based on read and write operations** using:
âœ… **RCUs (Read Capacity Units)** â†’ Control read operations.  
âœ… **WCUs (Write Capacity Units)** â†’ Control write operations.

---

## ğŸ”¥ **Why Do RCUs & WCUs Exist?**

DynamoDB is a fully managed database, meaning **AWS must control resource allocation** across millions of customers. Instead of charging for hardware usage like traditional databases, DynamoDB uses **RCUs & WCUs as prepaid "credits"** for managing database performance and cost.

ğŸ‘‰ **RCUs & WCUs exist to**:

- âœ… **Prevent overloading AWS infrastructure with unlimited queries.**
- âœ… **Allow customers to pay only for what they need.**
- âœ… **Help AWS efficiently scale resources for all users.**

DynamoDB offers two pricing models:

- **1ï¸âƒ£ Provisioned Mode** â†’ Pre-allocate RCUs & WCUs to control cost.
- **2ï¸âƒ£ On-Demand Mode** â†’ Auto-scales but is more expensive.

Now, let's break down **how RCUs & WCUs work** in detail.

---

## ğŸ§ **Understanding Read Capacity Units (RCUs)**

RCUs define **how much read throughput** a DynamoDB table can handle per second.

### **ğŸ“Œ 1 RCU Allows**

âœ” **1 strongly consistent read per second** for an **item up to 4KB**.  
âœ” **2 eventually consistent reads per second** for an **item up to 4KB**.  
âœ” **1 transactional read per second** for an **item up to 4KB**.

> ğŸ¯ **Strongly consistent read** = Always fetches the latest data (uses 1 RCU per 4KB).  
> ğŸ¯ **Eventually consistent read** = May return slightly outdated data (uses 0.5 RCUs per 4KB).  
> ğŸ¯ **Transactional read** = Ensures atomicity but costs more (same as strongly consistent).

### ğŸ›  **Example: Reading 100 Items Per Second (Each Item = 4KB)**

- **Strongly Consistent Reads**:

  ```ini
  100 items / 1 read per RCU = 100 RCUs
  ```

- **Eventually Consistent Reads**:

  ```ini
  100 items / 2 reads per RCU = 50 RCUs
  ```

### ğŸ›  **Example: Reading 100 Items Per Second (Each Item = 8KB)**

- Since **8KB is twice the 4KB limit**, each read requires **2 RCUs**:

  ```ini
  100 items Ã— 2 RCUs = 200 RCUs
  ```

- For **eventually consistent reads**, the cost is **half**:

  ```ini
  100 items Ã— (2 / 2) = 100 RCUs
  ```

---

## âœï¸ **Understanding Write Capacity Units (WCUs)**

WCUs define **how much write throughput** a DynamoDB table can handle per second.

### **ğŸ“Œ 1 WCU Allows**

âœ” **1 standard write per second** for an **item up to 1KB**.  
âœ” **1 transactional write per second** for an **item up to 1KB**.

> ğŸ’¡ **Transactional writes** ensure atomicity but require **double the WCUs**.

### ğŸ›  **Example: Writing 100 Items Per Second (Each Item = 1KB)**

```ini
100 items = 100 WCUs
```

### ğŸ›  **Example: Writing 100 Items Per Second (Each Item = 2KB)**

Since **2KB is twice the 1KB limit**, each write requires **2 WCUs**:

```ini
100 items Ã— 2 WCUs = 200 WCUs
```

---

## âš  **What Happens If You Exceed RCUs or WCUs?**

DynamoDB **does not slow down queries** when RCUs/WCUs are exceeded. Instead, **it outright rejects them** with an error! ğŸš¨

ğŸ’¥ **Error message:**

```ini
ProvisionedThroughputExceededException
```

This means:

- **1ï¸âƒ£** **Your request is immediately rejected** (not delayed or queued).
- **2ï¸âƒ£** **Your application must retry later** using **Exponential Backoff**.
- **3ï¸âƒ£** If retries **fail repeatedly**, the **user sees an error instead of getting data**.

---

## ğŸ”„ **How to Prevent Throttling & Failures**

### âœ… **1ï¸âƒ£ Enable Auto Scaling**

DynamoDB **automatically adjusts capacity** if traffic spikes.  
ğŸ‘‰ **AWS CLI Example: Enable Auto Scaling**

```sh
aws application-autoscaling register-scalable-target \
    --service-namespace dynamodb \
    --resource-id table/MyTable \
    --scalable-dimension dynamodb:table:ReadCapacityUnits \
    --min-capacity 5 \
    --max-capacity 50
```

âœ… **Now, your table will scale up if needed.**

---

### âœ… **2ï¸âƒ£ Use On-Demand Mode to Avoid Failures**

- On-Demand Mode **never throttles requests**â€”it scales dynamically.
- It **costs more per request** but ensures **zero failures**.

ğŸ‘‰ **AWS CLI Example: Switch to On-Demand Mode**

```sh
aws dynamodb update-table \
    --table-name MyTable \
    --billing-mode PAY_PER_REQUEST
```

âœ… **Now, DynamoDB will automatically handle any traffic spikes.**

---

## ğŸ” **Handling Throttling with Exponential Backoff**

If a query is rejected, you should **retry with an increasing delay** (Exponential Backoff).

### âœ… **Solution: Exponential Backoff**

AWS recommends retrying **with an increasing wait time** to reduce server overload.

### **Example (Python Pseudocode)**

```python
import time
import random

def retry_request():
    for attempt in range(5):  # Retry up to 5 times
        try:
            response = dynamodb.get_item(TableName="Users", Key={"UserID": "123"})
            return response  # Success!
        except ProvisionedThroughputExceededException:
            wait_time = (2 ** attempt) + random.uniform(0, 1)  # Exponential wait
            time.sleep(wait_time)

retry_request()
```

### **How It Works:**

- The first retry waits **2 seconds**, the second retry **4 seconds**, the third **8 seconds**, etc.
- This **prevents overwhelming DynamoDB** instead of retrying too fast.

---

## ğŸ **Final Takeaways**

âœ… **RCUs & WCUs are prepaid "credits" that control DynamoDB performance & cost**  
âœ… **Provisioned Mode fails queries when limits are exceeded (`ProvisionedThroughputExceededException`)**  
âœ… **On-Demand Mode prevents failures but costs more**  
âœ… **Auto Scaling helps manage traffic spikes in Provisioned Mode**  
âœ… **Use Exponential Backoff to handle throttling effectively**
