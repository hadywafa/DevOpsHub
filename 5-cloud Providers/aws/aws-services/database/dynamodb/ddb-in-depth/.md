# 🧱 DynamoDB Local Secondary Index (LSI) – SQL-Friendly Deep Dive

As a SQL veteran, you're used to index pages, clustered/non-clustered layouts, and precise I/O control. DynamoDB takes a different approach but offers indexing superpowers if you understand the internal layout.

This guide walks through the full data layout for a table using **LSI** — starting from the original item layout, then showing how the partition data looks when using each `ProjectionType`: `KEYS_ONLY`, `INCLUDE`, and `ALL`.

---

## 🗂️ Original Base Table Layout (No Index Yet)

We'll use a sample `Orders` table:

### 🔹 Table Schema

- **Partition Key:** `CustomerID`
- **Sort Key:** `OrderID`
- **Attributes:** `OrderDate`, `TotalAmount`

### 🔢 Sample Items

```txt
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 Base Table View (sorted by OrderID)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[ORD-001] → {
    CustomerID: User123,
    OrderID: ORD-001,
    OrderDate: 2024-03-09,
    TotalAmount: $250
}

[ORD-002] → {
    CustomerID: User123,
    OrderID: ORD-002,
    OrderDate: 2024-03-08,
    TotalAmount: $120
}

[ORD-003] → {
    CustomerID: User123,
    OrderID: ORD-003,
    OrderDate: 2024-03-07,
    TotalAmount: $300
}
```

🧠 Without any LSI, you can only **query using the base sort key** `OrderID`. Sorting/filtering by `OrderDate` requires a **full table scan**.

---

## 🔄 Adding an LSI: Sorted by `OrderDate`

All LSIs:

- Must be defined at table creation
- Share the same **partition key** (`CustomerID`)
- Use a different **sort key** (here: `OrderDate`)
- Are stored **in the same partition**, but with different internal layouts based on projection

---

## 🔍 Partition View: `ProjectionType: KEYS_ONLY`

### 🔹 What’s stored?

- `CustomerID` (PK)
- `OrderDate` (alternate sort key)

```text
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 Base Table View (sorted by OrderID)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
....etc
....etc
....etc
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 LSI: OrderDateIndex (KEYS_ONLY)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Partition: User123
  ├── 2024-03-07 → { CustomerID: User123, OrderDate: 2024-03-07 }
  ├── 2024-03-08 → { CustomerID: User123, OrderDate: 2024-03-08 }
  └── 2024-03-09 → { CustomerID: User123, OrderDate: 2024-03-09 }
```

📌 You’ll **need to read from base table** to fetch other fields like `OrderID`, `TotalAmount`.

---

## 🔍 Partition View: `ProjectionType: INCLUDE`

### 🔹 What’s stored?

- `CustomerID`, `OrderDate`
- Only selected fields (e.g., `TotalAmount`)

```json
"Projection": {
  "ProjectionType": "INCLUDE",
  "NonKeyAttributes": ["TotalAmount"]
}
```

```text
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 Base Table View (sorted by OrderID)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
....etc
....etc
....etc
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 LSI: OrderDateIndex (INCLUDE: TotalAmount)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Partition: User123
  ├── 2024-03-07 → { CustomerID: User123, OrderDate: 2024-03-07, TotalAmount: 300 }
  ├── 2024-03-08 → { CustomerID: User123, OrderDate: 2024-03-08, TotalAmount: 120 }
  └── 2024-03-09 → { CustomerID: User123, OrderDate: 2024-03-09, TotalAmount: 250 }
```

📌 You can get `TotalAmount` **from the index**, but still need a **second read** if you want `OrderID`.

---

## 🔍 Partition View: `ProjectionType: ALL`

### 🔹 What’s stored?

- **Everything**: Full item copy from base table

```text
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 Base Table View (sorted by OrderID)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
....etc
....etc
....etc
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗂 LSI: OrderDateIndex (ALL)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Partition: User123
  ├── 2024-03-07 → {
        CustomerID: User123,
        OrderID: ORD-003,
        OrderDate: 2024-03-07,
        TotalAmount: 300
      }
  ├── 2024-03-08 → {
        CustomerID: User123,
        OrderID: ORD-002,
        OrderDate: 2024-03-08,
        TotalAmount: 120
      }
  └── 2024-03-09 → {
        CustomerID: User123,
        OrderID: ORD-001,
        OrderDate: 2024-03-09,
        TotalAmount: 250
      }
```

📌 Everything you need is **available directly from the LSI**. No extra read required — but you're storing more.

---

## 🧠 Summary Table: LSI Projection Options

| Projection Type | What’s Stored in Index            | Need Base Table Read?     | Ideal For...                       |
| --------------- | --------------------------------- | ------------------------- | ---------------------------------- |
| `KEYS_ONLY`     | Only PK + LSI Sort Key            | ✅ Yes                    | Minimal storage                    |
| `INCLUDE`       | Keys + selected attributes        | ❌ No (if attrs included) | Filtering with limited fields      |
| `ALL`           | Full copy of item from base table | ❌ No                     | Fast reads at cost of more storage |

---

## 🧬 Internals for SQL Folks (👀 Real Talk)

🔸 Think of LSI as **non-clustered indexes** in SQL — **copying key columns and optionally data columns**, but not the entire table.

🔸 Difference: LSI lives **inside the partition** of the base table — it’s not a separate index file like SQL.

🔸 Yes, in `ALL` projection, **Dynamo duplicates data inside the same partition** — it’s a tradeoff between speed and space.
