# ğŸ”¥ **DynamoDB Data Model: No Relationships, No Joins, and How to Design Tables**

AWS DynamoDB is a **serverless NoSQL database** optimized for **scalability, performance, and low latency**. Unlike SQL databases, **DynamoDB does not have relationships between tables**â€”instead, data is structured for **fast key-value lookups and denormalized storage**.

---

<div style="text-align: center;">
  <img src="images/dynamodb-data-model.png" alt="DynamoDB Data Model: No Relationships, No Joins, and How to Design Tables" />
</div>

---

## ğŸ— **DynamoDB vs. SQL vs. Document Databases**

| Feature                   | DynamoDB (NoSQL)                      | SQL Databases (PostgreSQL, MySQL) | Document Databases (MongoDB)  |
| ------------------------- | ------------------------------------- | --------------------------------- | ----------------------------- |
| **Storage Model**         | Key-Value & Wide-Column Tables        | Full Relational Database          | Collections & Documents       |
| **Joins Between Tables?** | âŒ No built-in joins                  | âœ… Supports `JOIN` queries        | âŒ No built-in joins          |
| **Data Structure**        | Items (Rows) with flexible attributes | Tables with rows & columns        | JSON-like flexible schema     |
| **Relationship Support**  | âŒ No foreign keys                    | âœ… Foreign keys & constraints     | âŒ No foreign keys            |
| **Best Use Case**         | Fast, scalable key-value lookups      | Complex queries, transactions     | Flexible semi-structured data |

---

## ğŸ¢ **How DynamoDB Stores Data**

DynamoDB **only provides tables**â€”there are no databases with relationships like SQL.  
Each table consists of **items (rows)** with flexible **attributes (columns)**.

### **ğŸ“Œ Data Structure**

- **Table** = Collection of items (like a SQL table).
- **Item** = Single row in a table (flexible schema).
- **Attributes** = Columns in a row (can be different per item).

#### ğŸ›  **Example: Storing Users in DynamoDB**

| **UserID (Partition Key)** | **Name** | **Email**         | **Orders**           |
| -------------------------- | -------- | ----------------- | -------------------- |
| `USR001`                   | Alice    | <alice@email.com> | `[ORD1001, ORD1002]` |
| `USR002`                   | Bob      | <bob@email.com>   | `[ORD1003]`          |

- âœ”ï¸ **DynamoDB does not support `JOINs`**, so related data **must be stored in the same item** (denormalization).
- âœ”ï¸ Instead of a separate **Users** and **Orders** table, the orders are **stored as an array inside the user record**.

---

## âŒ **Why DynamoDB Has No Relationships or Joins**

DynamoDB is **designed for speed and scalability**â€”not complex queries. SQL databases use **`JOINs`**, but DynamoDB avoids them because:

**1ï¸âƒ£ SQL joins require scanning multiple tables, slowing down performance.**  
**2ï¸âƒ£ DynamoDB scales horizontally, and relationships create partitioning issues.**  
**3ï¸âƒ£ Joins require relational integrity, which DynamoDB does not enforce.**

---

## ğŸ”„ **How to Model Relationships in DynamoDB**

Since **DynamoDB does not support joins**, you must **design tables based on access patterns**.

### âœ… **1ï¸âƒ£ Store Related Data in a Single Item (Denormalization)**

- **Best for:** Fast queries with minimal lookups.
- **Example:** Instead of a separate `Orders` table, store order details inside the `Users` table.

| **UserID** | **Name** | **Orders (Embedded List)**                                                     |
| ---------- | -------- | ------------------------------------------------------------------------------ |
| `USR001`   | Alice    | `[{"OrderID": "ORD1001", "Amount": 50}, {"OrderID": "ORD1002", "Amount": 30}]` |

ğŸ”¹ **Pros:** Faster lookups, fewer queries.  
ğŸ”¹ **Cons:** Data duplication if order details change frequently.

---

### âœ… **2ï¸âƒ£ Use Global Secondary Indexes (GSI) for Lookup**

If you need to **query related data efficiently**, use **Global Secondary Indexes (GSI)**.

#### **Example: Orders Table with a GSI on `UserID`**

| **OrderID (Primary Key)** | **UserID (GSI)** | **Amount** |
| ------------------------- | ---------------- | ---------- |
| `ORD1001`                 | `USR001`         | `$50`      |
| `ORD1002`                 | `USR001`         | `$30`      |

Now, you can **query all orders for a specific user** by using the `UserID` index.

ğŸ”¹ **Pros:** Supports fast queries without scanning the entire table.  
ğŸ”¹ **Cons:** More expensive than single-table queries.

---

### ğŸ“œ **DynamoDB Relationship Modeling Workflow (Mermaid Diagram)**

```mermaid
graph TD
    A[User Table] -- Stores UserID & Basic Info --> B[User Record]
    B -- Denormalized Data --> C[Embedded Orders List]
    B -- Uses GSI to Query Orders --> D[Orders Table]
    D -- OrderID Lookup --> E[Specific Order Details]
```

---

## ğŸš€ **Performance Best Practices**

### âœ… **1ï¸âƒ£ Use Single-Table Design for Speed**

- Instead of **multiple tables**, store everything in **one table** with different item types.
- Example: A table with **Users, Orders, and Products**, each using a **different partition key structure**.

### âœ… **2ï¸âƒ£ Avoid Scans, Use Query Instead**

- Scans **read the entire table** and are slow.
- Queries use **partition keys and indexes** for **faster lookups**.

### âœ… **3ï¸âƒ£ Use Composite Keys for Related Data**

- **Partition Key:** `UserID`
- **Sort Key:** `#Order#ORD1001`
- This allows queries like:

  ```sh
  Get all orders where UserID = 'USR001'
  ```

---

## ğŸ **Final Takeaways**

âœ… **DynamoDB does not have full database relationshipsâ€”only isolated tables.**  
âœ… **There are no joins, no foreign keys, and no relational integrity.**  
âœ… **Denormalization (storing related data together) is key for fast lookups.**  
âœ… **GSIs can help query related data without table joins.**  
âœ… **Use single-table design and composite keys for efficient queries.**

ğŸ”¥ **Want a real-world example with AWS SDK or CLI? Let me know!** ğŸš€
