# ğŸ” **DynamoDB Filters**

When retrieving data in DynamoDB, there are **two main ways** to apply filters:  
âœ… **KeyConditionExpression** (Efficient, applies **before reading data**)  
âœ… **FilterExpression** (Less efficient, applies **after reading data**)

This guide explains **how both work**, their **differences**, and how to use them effectively.

---

## ğŸ“Œ **How Filtering Works in DynamoDB?**

### ğŸ”¹ **KeyConditionExpression (Efficient Filtering)**

- **Filters items before retrieval** â†’ **reduces read costs (RCUs)**.
- Works **only with primary key attributes** (Partition Key & Sort Key).
- **Does not support non-key attributes** (e.g., filtering by `Status`).
- Faster because it retrieves **only relevant data**.

### ğŸ”¹ **FilterExpression (Post-Read Filtering)**

- **Filters items after they are read** from storage.
- Works with **any attribute** (key and non-key attributes).
- **Does not reduce RCUs** (because all items are loaded first).
- Can be expensive for large datasets.

---

## ğŸ”„ **How They Work: Step-by-Step Comparison**

### âœ… **Using `KeyConditionExpression`**

1ï¸âƒ£ DynamoDB retrieves **only the items that match the key condition**.  
2ï¸âƒ£ It **does not read unnecessary data** (saving RCUs).  
3ï¸âƒ£ The final result is returned to the client.

### âŒ **Using `FilterExpression`**

1ï¸âƒ£ DynamoDB **retrieves all matching items based on the key condition** (or scans the table).  
2ï¸âƒ£ It **loads the full dataset into memory** (consuming RCUs).  
3ï¸âƒ£ The filter is **applied after retrieval**, removing unwanted items.

ğŸ“Œ **Key takeaway:** **Use `KeyConditionExpression` whenever possible!**

---

## ğŸ”¹ **Comparison: KeyConditionExpression vs. FilterExpression**

| Feature                            | **KeyConditionExpression** âœ… | **FilterExpression** âŒ   |
| ---------------------------------- | ----------------------------- | ------------------------- |
| **When is it applied?**            | Before retrieving data        | After retrieving data     |
| **Reduces RCU usage?**             | âœ… Yes                        | âŒ No                     |
| **Works with non-key attributes?** | âŒ No                         | âœ… Yes                    |
| **Supports comparisons?**          | âœ… Yes (on Sort Key)          | âœ… Yes (on any attribute) |
| **Can be used with Query?**        | âœ… Yes                        | âœ… Yes                    |
| **Can be used with Scan?**         | âŒ No                         | âœ… Yes                    |

---

## ğŸ“ **Examples of KeyConditionExpression & FilterExpression**

### âœ… **Example 1: Query Orders Using `KeyConditionExpression` (Efficient)**

```sh
aws dynamodb query \
    --table-name Orders \
    --key-condition-expression "CustomerID = :cust" \
    --expression-attribute-values '{ ":cust": {"S": "User123"} }'
```

ğŸ“Œ **Behavior:**

- Retrieves **only orders for `CustomerID = User123`**.
- Uses **partition key efficiently** â†’ **RCU usage is minimal**.

---

### âŒ **Example 2: Query Orders Using `FilterExpression` (Inefficient)**

```sh
aws dynamodb query \
    --table-name Orders \
    --key-condition-expression "CustomerID = :cust" \
    --filter-expression "Status = :status" \
    --expression-attribute-values '{
        ":cust": {"S": "User123"},
        ":status": {"S": "Completed"}
    }'
```

ğŸ“Œ **Issues:**

- Retrieves **all orders** for `User123` into memory (**high RCU usage**).
- Then **filters out non-matching orders** (wasted RCUs).

ğŸ’¡ **Optimization Tip:** If you need to filter by `Status`, use a **Global Secondary Index (GSI)** instead!

---

## ğŸ“Œ **How `FilterExpression` Works**

<div style="text-align: center;">
  <img src="images/ddb-read-filters.png" alt="DynamoDB FilterExpression" />
</div>

---

1ï¸âƒ£ **Query or Scan fetches all matching items based on key conditions.**  
2ï¸âƒ£ **DynamoDB loads the full dataset into memory** (this is what consumes RCUs).  
3ï¸âƒ£ **FilterExpression is applied to the retrieved dataset**.  
4ï¸âƒ£ **Only items that match the filter are returned to the client**.

ğŸ“Œ **Key takeaway:** **Filter expressions do not reduce read costs because they are applied after items are read from storage.**

---

## ğŸ”¹ **Comparison: Query vs. FilterExpression**

| **Scenario**                             | **Uses Indexes?** | **Applies Before Reading Data?** | **Reduces RCU Usage?** |
| ---------------------------------------- | ----------------- | -------------------------------- | ---------------------- |
| **Query with KeyConditionExpression** âœ… | **Yes**           | **Before** retrieving items      | âœ… **Yes**             |
| **FilterExpression on Query/Scan** âŒ    | **No**            | **After** retrieving items       | âŒ **No**              |

---

## ğŸ”¹ **How `FilterExpression` Affects RCUs?**

- **Query operations** **only consume RCUs for items that match the key condition**, but applying a `FilterExpression` on non-key attributes **does not reduce the RCUs used**.
- **Scan operations** consume **RCUs for all items scanned**, even if the filter eliminates many of them.

ğŸ“Œ **Formula for RCUs Used:**

```plaintext
Total RCUs Used = (All Retrieved Item Size / 4 KB) * Consistency Factor
```

- **Strongly Consistent Reads**: Consistency Factor = **1**
- **Eventually Consistent Reads**: Consistency Factor = **0.5**

---

## ğŸ“ **Using `FilterExpression` in Queries**

### âœ… **Example 1: Query Orders with a Filter on `TotalAmount`**

```sh
aws dynamodb query \
    --table-name Orders \
    --key-condition-expression "CustomerID = :cust" \
    --filter-expression "TotalAmount > :amount" \
    --expression-attribute-values '{
        ":cust": {"S": "User123"},
        ":amount": {"N": "100"}
    }'
```

ğŸ“Œ **Explanation:**

- Queries **all orders** for `CustomerID = "User123"`.
- **Retrieves all orders into memory** (costing RCUs).
- **Filters out orders where `TotalAmount <= 100`**.
- **Returned dataset is smaller, but RCUs are still charged for all retrieved items**.

---

### âœ… **Example 2: Query Employees with a Filter on Department**

```sh
aws dynamodb query \
    --table-name Employee \
    --key-condition-expression "ManagerID = :mgr" \
    --filter-expression "Department = :dept" \
    --expression-attribute-values '{
        ":mgr": {"S": "MGR123"},
        ":dept": {"S": "Engineering"}
    }'
```

ğŸ“Œ **Explanation:**

- Queries **all employees** who report to `MGR123`.
- **Retrieves all direct reports** into memory.
- **Filters only employees in `Engineering`**.

---

## ğŸ“ **Using `FilterExpression` in Scans**

### âœ… **Example 3: Scan Employees and Filter by Job Title**

```sh
aws dynamodb scan \
    --table-name Employee \
    --filter-expression "JobTitle = :title" \
    --expression-attribute-values '{":title": {"S": "Software Engineer"}}'
```

ğŸ“Œ **Explanation:**

- Reads **every item in the table**, consuming **RCUs for all scanned items**.
- **Filters out non-matching items only after retrieval**.

ğŸ“Œ **Expensive!** Consider using **GSIs (Global Secondary Indexes)** instead of scanning.

---

## ğŸ”¹ **Optimizing Read Costs: Alternatives to `FilterExpression`**

Instead of using `FilterExpression`, **optimize queries using the following:**

| **Optimization**                                               | **Method**                                     | **Effect on RCU Costs**                      |
| -------------------------------------------------------------- | ---------------------------------------------- | -------------------------------------------- |
| **Use `KeyConditionExpression` instead of `FilterExpression`** | Query based on **Partition Key + Sort Key**    | âœ… **Lowers RCUs by retrieving fewer items** |
| **Use Global Secondary Indexes (GSIs)**                        | Create an index on non-key attributes          | âœ… **Retrieves fewer items, reducing RCUs**  |
| **Use `ProjectionExpression`**                                 | Retrieve only needed attributes                | âœ… **Reduces data transfer costs**           |
| **Use `Limit` parameter**                                      | Restrict the number of items returned per call | âœ… **Prevents excessive reads per request**  |

---

## ğŸ”¥ **FilterExpression vs. GSI: Which One is Better?**

ğŸ“Œ **Using `FilterExpression` (Bad for Performance)**

```sh
aws dynamodb query \
    --table-name Orders \
    --key-condition-expression "CustomerID = :cust" \
    --filter-expression "Status = :status" \
    --expression-attribute-values '{
        ":cust": {"S": "User123"},
        ":status": {"S": "Completed"}
    }'
```

ğŸ”´ **Issues:**

- Reads **all orders** for `User123` before filtering.
- **Consumes RCUs for all retrieved items** (even if most are filtered out).

ğŸ“Œ **Using GSI Instead (Better Performance)**

```sh
aws dynamodb query \
    --table-name Orders \
    --index-name StatusIndex \
    --key-condition-expression "Status = :status" \
    --expression-attribute-values '{":status": {"S": "Completed"}}'
```

âœ… **Advantages of GSI:**

- Queries **only "Completed" orders**, reducing RCUs.
- More efficient than scanning and filtering after retrieval.

---

## ğŸ† **Key Takeaways**

âœ” **`FilterExpression` does not reduce RCU consumption because it is applied after retrieving items.**  
âœ” **For optimal performance, always use `KeyConditionExpression` instead of `FilterExpression` where possible.**  
âœ” **Scans are costly; avoid using `FilterExpression` with `Scan` unless necessary.**  
âœ” **Use GSIs to query non-key attributes efficiently.**  
âœ” **Use `ProjectionExpression` to retrieve only required attributes, reducing data transfer costs.**

By **avoiding unnecessary filters and using indexes**, you can **reduce read costs and improve query performance** in DynamoDB! ğŸš€
