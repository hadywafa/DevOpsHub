# **üß† Aurora's Log-Based Storage**

Amazon Aurora is a high-performance, cloud-native relational database service that **reimagines traditional database architectures** by leveraging a **log-based storage system**. This architecture ensures **high availability, low replication lag (<100ms), and seamless failover** for read replicas.

In this guide, we will explore **how Aurora writes and reads data, how its read replicas stay in sync, and what happens when replicas fail before the storage layer fully flushes data pages**.

---

## **1Ô∏è‚É£ Aurora Transaction Commit & Read Replica Synchronization: Workflow üîÑ**

The following sequence diagram illustrates **how a write transaction is processed in Aurora**, how redo logs are used instead of traditional page flushing, and how read replicas apply changes.

```mermaid
sequenceDiagram
    participant Client
    participant Primary as Aurora Primary Instance (Writer)
    participant Storage as Aurora Storage Layer
    participant Replica as Aurora Read Replica
    Client->>Primary: 1. Write transaction
    Primary->>Primary: 2. Process transaction & generate redo log records
    Primary->>Storage: 3. Send redo log records
    Storage->>Storage: 4. Durably store redo logs across multiple nodes
    Storage-->>Storage: 5. **Async:** Apply redo logs to data pages in background
    Storage-->>Replica: 6. Stream redo logs to read replicas (real-time)
    Replica->>Replica: 7. Apply redo logs to update in-memory cache (stay in sync)
    Replica-->>Client: 8. Serve updated reads (minimal lag)
```

---

## **2Ô∏è‚É£ How Amazon Aurora's Log-Based Storage Works üîç**

### **1. How does Aurora handle writes?**

‚úÖ **Aurora does NOT write full data pages to disk immediately** like traditional databases. Instead, it:

- Writes only **redo log records** (which describe changes, not entire data pages).
- Sends these redo logs to the **Aurora storage layer**, which distributes them across multiple storage nodes.
- The storage layer later **assembles full data pages** from the redo logs **when needed**.

### **2. When do data pages get updated in storage nodes?**

‚úÖ **Redo logs are written first**, and **data pages are updated asynchronously** in the background.

- This **avoids write amplification** and improves **commit performance** significantly.
- If a query requests data, the storage layer **reconstructs the page from redo logs** dynamically.

---

## **3Ô∏è‚É£ How Read Replicas Stay in Sync üìñ**

Unlike traditional replication, Aurora read replicas **don‚Äôt rely on full-page flushes**. Instead, they:

1Ô∏è‚É£ Receive **redo logs in real-time from the storage layer**.  
2Ô∏è‚É£ Apply the logs **in memory** to keep up with the primary database.  
3Ô∏è‚É£ Serve updated reads **with minimal replication lag (<100ms)**.

### **Q: Do read replicas wait for the storage layer to flush data pages?**

‚ùå **No! Read replicas don‚Äôt need to wait for flushed pages.**  
‚úî Instead, they **immediately apply redo logs in memory**, staying **almost in sync with the primary**.

### **Q: Does Aurora use eventual consistency for read replicas?**

‚ùå **No! Aurora avoids eventual consistency.**  
‚úî Since redo logs are streamed **continuously** to read replicas, they reflect **committed transactions in real time**.

---

## **4Ô∏è‚É£ What Happens If a Read Replica Fails Before Storage Nodes Flush Data Pages? ‚ö†Ô∏è**

If a read replica **fails and a new one is created**, but storage nodes **haven‚Äôt flushed data pages yet**, will the new replica have outdated data? **No. Aurora ensures consistency.**

1Ô∏è‚É£ The **new read replica does NOT rely on existing data pages**.  
2Ô∏è‚É£ Instead, it **fetches all redo logs from the storage layer**.  
3Ô∏è‚É£ The **redo logs are applied in memory**, keeping the replica **up to date** even if data pages weren‚Äôt flushed.

‚úî **Storage nodes store redo logs across multiple AZs**, ensuring zero data loss.  
‚úî The new replica reconstructs data pages dynamically **from logs, not from stale pages**.

### **Q: What if the primary instance fails before storage nodes flush pages?**

1Ô∏è‚É£ Aurora **selects the best read replica as the new primary**.  
2Ô∏è‚É£ It applies **all unprocessed redo logs** before accepting writes.  
3Ô∏è‚É£ Since redo logs are always **persisted before commit acknowledgment**, **no transactions are lost**.

---

## **5Ô∏è‚É£ Aurora's Log-Based Architecture vs Traditional Replication üìä**

| Feature              | **Traditional RDS (PostgreSQL/MySQL)** | **Aurora (PostgreSQL/MySQL-Compatible)** |
| -------------------- | -------------------------------------- | ---------------------------------------- |
| **Storage Model**    | Full-page writes on commit             | Log-based redo record storage            |
| **Read Replica Lag** | Seconds to minutes                     | **< 100ms (real-time log streaming)**    |
| **Replica Updates**  | Applies full page updates              | **Applies redo logs dynamically**        |
| **Failover Time**    | **60-120s**                            | **~30s** (fastest in AWS)                |
| **Cross-Region DR**  | Read replicas only                     | **Aurora Global Database**               |
| **Performance**      | Standard                               | **3-5x Faster**                          |
| **Write Latency**    | High (full pages written on commit)    | **Low (log-based commits only)**         |

---

## **6Ô∏è‚É£ Key Takeaways üéØ**

‚úî **Writes:** Aurora **only writes redo logs** to storage first, avoiding full-page writes.  
‚úî **Storage Layer:** Pages are **updated asynchronously**, reducing write amplification.  
‚úî **Read Replicas:** Apply redo logs **in real-time**‚Äîthey don't wait for flushed pages.  
‚úî **Failover Handling:** If a replica fails before pages are flushed, **redo logs restore the latest state**.  
‚úî **Consistency:** Replicas are **near real-time**, avoiding traditional replication lag.

üöÄ **Amazon Aurora‚Äôs log-based storage model ensures fast writes, minimal replication lag, and seamless failovers‚Äîmaking it one of the most advanced cloud databases available today!** üéØ
