# ‚öôÔ∏è **How AWS AppSync Handles Logic for Data Retrieval and Mutations**

AWS **AppSync** is a **managed GraphQL API service** that automatically **handles** CRUD operations if you use **DynamoDB as a data source**. However, for **custom business logic**, you need to use **AWS Lambda** or another backend service.

---

## üî• **Who Handles Data Fetching & Mutations in AppSync?**

AppSync itself does **not execute business logic** like a traditional backend. Instead, it acts as a **GraphQL Gateway** that routes requests to **data sources**, such as:

| **Data Source**                       | **Who Handles Logic?**                                                               |
| ------------------------------------- | ------------------------------------------------------------------------------------ |
| **Amazon DynamoDB**                   | AppSync auto-generates CRUD operations (No need to write backend code).              |
| **Amazon RDS (Aurora)**               | Requires a Lambda function as a resolver to interact with the SQL database.          |
| **AWS Lambda**                        | You write your custom logic inside Lambda, and AppSync routes GraphQL queries to it. |
| **Amazon OpenSearch (Elasticsearch)** | Used for complex searches & analytics, AppSync queries OpenSearch.                   |
| **HTTP Endpoints**                    | Calls external REST APIs (e.g., another backend service).                            |

‚úîÔ∏è If you **use DynamoDB**, AppSync **automatically** generates resolvers for basic CRUD operations.  
‚úîÔ∏è If you **need custom logic**, AppSync **routes requests to AWS Lambda**, where you implement your own logic.

---

## üõ† **1. Using DynamoDB (No Custom Logic Needed)**

If you connect **AppSync directly to DynamoDB**, it **automatically** handles:
‚úîÔ∏è **Creating** new records.  
‚úîÔ∏è **Reading** records by ID or scanning the table.  
‚úîÔ∏è **Updating** specific fields in a record.  
‚úîÔ∏è **Deleting** records by ID.

### **Example: GraphQL Query (Get a Todo by ID)**

```graphql
query GetTodo {
  getTodo(id: "123") {
    id
    title
    completed
  }
}
```

‚úîÔ∏è AppSync **automatically fetches** the record from DynamoDB using the resolver.  
‚úîÔ∏è You **don‚Äôt need to write custom backend code** for simple operations.

---

## üèó **2. Using AWS Lambda for Custom Business Logic**

If you need **custom validation, business rules, or complex database queries**, you must **use AWS Lambda** as a resolver.

### **Step 1: Create a Lambda Function**

1Ô∏è‚É£ Go to **AWS Lambda** ‚Üí Click **Create Function** ‚Üí Select **Node.js/Python**.  
2Ô∏è‚É£ Name it **appsyncTodoHandler**.  
3Ô∏è‚É£ Paste this **Lambda function for custom logic**:

```javascript
const AWS = require("aws-sdk");
const dynamoDB = new AWS.DynamoDB.DocumentClient();
const TABLE_NAME = "TodosTable";

exports.handler = async (event) => {
  console.log("Received event:", JSON.stringify(event, null, 2));
  const { fieldName, arguments } = event;

  switch (fieldName) {
    case "getTodo":
      return await getTodo(arguments.id);
    case "listTodos":
      return await listTodos();
    case "createTodo":
      return await createTodo(arguments.input);
    case "deleteTodo":
      return await deleteTodo(arguments.id);
    default:
      throw new Error(`Unsupported query: ${fieldName}`);
  }
};

async function getTodo(id) {
  const params = { TableName: TABLE_NAME, Key: { id } };
  const result = await dynamoDB.get(params).promise();
  return result.Item;
}

async function listTodos() {
  const params = { TableName: TABLE_NAME };
  const result = await dynamoDB.scan(params).promise();
  return result.Items;
}

async function createTodo(input) {
  const params = {
    TableName: TABLE_NAME,
    Item: { id: AWS.util.uuid.v4(), ...input },
  };
  await dynamoDB.put(params).promise();
  return params.Item;
}

async function deleteTodo(id) {
  const params = { TableName: TABLE_NAME, Key: { id } };
  await dynamoDB.delete(params).promise();
  return { id };
}
```

‚úîÔ∏è This function **implements CRUD logic manually** using **DynamoDB SDK** inside Lambda.

---

### **Step 2: Connect Lambda to AppSync**

1Ô∏è‚É£ In **AWS AppSync**, go to **Data Sources** ‚Üí Click **Create Data Source**.  
2Ô∏è‚É£ Choose **AWS Lambda** as the data source.  
3Ô∏è‚É£ Select the **Lambda function (appsyncTodoHandler)**.  
4Ô∏è‚É£ Click **Save**.

---

### **Step 3: Attach Lambda to Resolvers**

1Ô∏è‚É£ Go to **Schema ‚Üí Resolvers**.  
2Ô∏è‚É£ Attach **getTodo, listTodos, createTodo, deleteTodo** to **Lambda** instead of DynamoDB.

---

### **Step 4: Run GraphQL Queries**

#### **Fetch a Todo**

```graphql
query {
  getTodo(id: "123") {
    id
    title
    completed
  }
}
```

‚úîÔ∏è AppSync **routes the request to Lambda** ‚Üí Lambda fetches the **record from DynamoDB**.

#### **Create a New Todo**

```graphql
mutation {
  createTodo(input: { title: "Learn AWS AppSync", completed: false }) {
    id
    title
    completed
  }
}
```

‚úîÔ∏è AppSync **calls Lambda** ‚Üí Lambda **inserts a new record into DynamoDB**.

---

## üì° **3. Calling an External REST API with AppSync**

If your data **is stored outside AWS**, you can **call an external REST API** instead.

### **Step 1: Create a Data Source**

1Ô∏è‚É£ In **AppSync**, go to **Data Sources** ‚Üí Click **Create Data Source**.  
2Ô∏è‚É£ Choose **HTTP Endpoint**.  
3Ô∏è‚É£ Enter **URL**: `https://api.example.com/todos`.  
4Ô∏è‚É£ Click **Save**.

### **Step 2: Attach Resolvers to Queries**

Use the following resolver mapping template for **listTodos**:

```json
{
  "version": "2018-05-29",
  "method": "GET",
  "resourcePath": "/todos",
  "params": {
    "headers": {
      "Authorization": "Bearer <API_KEY>"
    }
  }
}
```

‚úîÔ∏è Now, when you run:

```graphql
query {
  listTodos {
    id
    title
    completed
  }
}
```

‚úîÔ∏è AppSync **calls the external REST API** and returns results.

---

## üöÄ **Final Summary ‚Äì Choosing the Right Backend for AppSync**

| **Data Source**                    | **Who Handles Logic?**                     | **Best Use Case**                                   |
| ---------------------------------- | ------------------------------------------ | --------------------------------------------------- |
| **DynamoDB**                       | AppSync handles CRUD automatically         | Simple data storage with auto-scaled NoSQL          |
| **Lambda (Node.js, Python, etc.)** | You write business logic inside Lambda     | Custom validation, workflows, external integrations |
| **RDS (SQL Database)**             | Lambda interacts with RDS via queries      | Complex SQL-based applications                      |
| **OpenSearch (Elasticsearch)**     | AppSync directly queries OpenSearch        | Full-text search, analytics                         |
| **HTTP API (External REST APIs)**  | AppSync routes requests to an external API | Calling third-party services                        |

‚úîÔ∏è **For simple CRUD, use DynamoDB (No backend code needed).**  
‚úîÔ∏è **For custom logic, use Lambda (Node.js, Python, Java).**  
‚úîÔ∏è **For SQL databases, use Lambda with RDS.**  
‚úîÔ∏è **For external APIs, use HTTP data sources.**

---

## üéØ **Next Steps ‚Äì What Do You Need Help With?**

- Do you want to **optimize Lambda performance for AppSync?**
- Need help **securing AppSync with IAM & Cognito?**
- Want to **connect AppSync to a PostgreSQL/MySQL database?**

Let me know, and I‚Äôll guide you! üöÄüòÉ
