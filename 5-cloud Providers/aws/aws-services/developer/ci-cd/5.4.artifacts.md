# ğŸ¯ Full Guide: Understanding `artifacts` in `buildspec.yml` for AWS CodeDeploy

## ğŸ—ï¸ What Are Artifacts in CodeBuild?

In AWS CodeBuild, **artifacts** represent the final output files generated after the build process.  
These are the files that will later be deployed by **AWS CodeDeploy** or stored somewhere like **S3** for distribution.

âœ… Artifacts could include:

- Compiled binaries (`.dll`, `.exe`, etc.)
- Bundled frontend apps (`index.html`, `bundle.js`, etc.)
- ZIP packages
- Configuration files
- Any other important outputs

> ğŸ‘‰ The artifact definition **controls what files CodeBuild sends** to the next stage (for example, to CodeDeploy or to a manual download).

---

## ğŸ› ï¸ Artifact Section in `buildspec.yml`

Inside your `buildspec.yml`, you define artifacts using the `artifacts` section.

Here's the basic syntax:

```yaml
artifacts:
  files:
    - <patterns to include>
  base-directory: <path to start from>
  discard-paths: <yes|no>
```

| Field            | Description                                                               |
| ---------------- | ------------------------------------------------------------------------- |
| `files`          | Patterns of files you want to package (e.g., `**/*`, `app/**/*`, `*.zip`) |
| `base-directory` | Directory where those files are located (relative to the build root)      |
| `discard-paths`  | Whether to flatten the folder structure (`yes`) or preserve it (`no`)     |

---

## ğŸ”¥ Detailed Attribute Breakdown

### ğŸ“‚ `files`

- Defines **which files** you want to include in the artifact.
- Supports wildcards (`*` and `**`).
- Example:

  ```yaml
  files:
    - "**/*" # (this includes everything)
  ```

---

### ğŸ  `base-directory`

- Tells CodeBuild where to **start looking** for the files you want to package.
- If you just built your app and the output is inside `publish/`, you can set:

  ```yaml
  base-directory: publish
  ```

---

### ğŸ§¹ `discard-paths`

- **`yes`**: Flatten all files into a **single folder** â€” no subdirectories.
- **`no`**: Keep the **original directory structure**.

âœ… `discard-paths: yes` is super helpful when:

- Deploying simple websites.
- Uploading flat ZIP packages.
- Sending all files directly to the root of an S3 bucket.

---

## ğŸ“¦ Artifact + CodeDeploy Relationship

When CodeBuild finishes, it uploads the artifacts (e.g., to an S3 bucket).  
Then, **AWS CodeDeploy** picks up those artifacts and **deploys them** to your target environment (EC2, Lambda, ECS).

So, if your artifact is messed up (wrong files, missing files, broken structure), the deployment will **fail**.

That's why **setting up artifacts correctly in `buildspec.yml` is critical**!

---

## ğŸ§© Examples of Artifact Configurations

---

### ğŸ§± Example 1: Preserving Directory Structure

```yaml
artifacts:
  files:
    - "**/*"
  base-directory: publish
  discard-paths: no
```

#### âœ… Behavior

- All files inside `publish/` are included.
- The subfolder structure (e.g., `assets/`, `config/`) is **preserved**.

#### ğŸ§  Common Use Case

- .NET Core APIs or apps
- Node.js apps with build folders
- Java apps after Maven/Gradle builds

---

### ğŸ“‚ Example 2: Flattening the Artifact (Using `discard-paths`)

```yaml
artifacts:
  files:
    - "**/*"
  base-directory: dist/my-angular-app
  discard-paths: yes
```

#### âœ… Behavior

- All files inside `dist/my-angular-app` are included.
- The directory structure is **flattened**.
- No folders â€” just pure files at the root.

#### ğŸ§  Common Use Case

- Frontend Angular/React apps being deployed to S3 buckets
- Websites for CDNs

---

## ğŸ” Visual Difference: `discard-paths` On vs Off

Imagine the following files in your build folder:

```plaintext
dist/my-angular-app/
â”œâ”€â”€ css/
â”‚   â”œâ”€â”€ style.css
â”‚   â””â”€â”€ theme.css
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ app.js
â”‚   â””â”€â”€ vendor.js
â””â”€â”€ index.html
```

---

### Without `discard-paths` (`no`)

- Result:

```plaintext
css/style.css
css/theme.css
js/app.js
js/vendor.js
index.html
```

- Structure preserved inside the artifact.

---

### With `discard-paths` (`yes`)

- Result:

```plaintext
style.css
theme.css
app.js
vendor.js
index.html
```

- Everything dumped in one flat folder!

---

## ğŸ§  Best Practices for Artifacts in CodeDeploy Pipelines

| Best Practice                        | Why                                                                |
| ------------------------------------ | ------------------------------------------------------------------ |
| Set `base-directory` smartly         | Avoid uploading unnecessary temp folders.                          |
| Use `discard-paths: yes` when needed | Especially when simple flat deployment is better (like websites).  |
| Always validate your artifacts       | Download the artifact manually to verify it has the correct files. |
| Secure artifacts in S3               | Use proper S3 bucket policies and encryption.                      |
| Zip artifacts if huge                | Save transfer and storage time (can be automated inside build).    |

---

## ğŸ“‹ Mini Checklist Before Deploying Artifacts

âœ… Confirm the build output is correct.  
âœ… Check if you want directory structure preserved or flattened.  
âœ… Match the structure to CodeDeploy's expectations (especially if you're using `appspec.yml`).  
âœ… Manually test deployment once after major changes.

---

## ğŸš€ Final Notes

- If you're building a **backend API (.NET, Node, Java)** â†’ Preserve paths.
- If you're building a **frontend web app (Angular, React, Vue)** â†’ Consider flattening paths.
- Always verify what your CodeDeploy setup expects (especially if using hooks or lifecycle events).

---

## ğŸ“ˆ Quick Full Example `buildspec.yml`

Here's a small complete sample you can use:

```yaml
version: 0.2

phases:
  install:
    commands:
      - npm install
  build:
    commands:
      - npm run build

artifacts:
  files:
    - "**/*"
  base-directory: dist
  discard-paths: yes
```

âœ… This builds a frontend app, then prepares the dist/ folder content flattened for CodeDeploy to pick it up!
