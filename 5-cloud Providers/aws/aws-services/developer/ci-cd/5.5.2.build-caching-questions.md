# ğŸš€ Deep Dive: How Caching Works in AWS CodeBuild

Letâ€™s focus on the meaning of this line:

```yaml
key: npm-cache-$(codebuild-hash-files package-lock.json)
```

And what _actually happens_ step by step inside CodeBuild ğŸ”¬.

---

## ğŸ“Œ Part 1: What Does This Cache Key Mean?

```yaml
key: npm-cache-$(codebuild-hash-files package-lock.json)
```

It creates a **dynamic, fingerprinted cache key**.

### ğŸ§  What is `$(codebuild-hash-files ...)`?

Itâ€™s a special CodeBuild function that:

- Calculates a **hash** (e.g., SHA256) of the given file(s)
- The hash is **used as a version tag** for the cache

So this line:

```yaml
key: npm-cache-$(codebuild-hash-files package-lock.json)
```

Might resolve at runtime to something like:

```yaml
key: npm-cache-a4e57c9d843f98fa1e94b16fcf8b2784cbb2a3a8
```

If you change anything in `package-lock.json`, the hash changes.

> âœ… So this avoids **stale caches** by invalidating the cache **only when your actual dependencies change**.

---

## ğŸ§ª Part 2: How CodeBuild Uses This Key (Internals)

Hereâ€™s what happens _behind the scenes_, **step-by-step** ğŸ”:

### ğŸ› ï¸ Internal Caching Lifecycle

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant CodeBuild as CodeBuild
    participant S3 as AWS S3 Cache Bucket

    Dev->>CodeBuild: Trigger Build
    CodeBuild->>CodeBuild: Run `codebuild-hash-files package-lock.json`
    CodeBuild->>CodeBuild: Generate key `npm-cache-<hash>`
    CodeBuild->>S3: Check if cache with this key exists

    alt Cache HIT
        S3->>CodeBuild: Return and restore `node_modules`
        CodeBuild->>CodeBuild: Use local files (no re-download)
    else Cache MISS
        CodeBuild->>NPM: Run `npm ci` (full dependency install)
    end

    CodeBuild->>S3: Push updated `node_modules` with key
```

---

## ğŸ§ª Real-Time Step-by-Step Breakdown

| ğŸ“ƒ Step | What Happens                                                                    |
| ------- | ------------------------------------------------------------------------------- |
| 1ï¸âƒ£      | CodeBuild starts the build                                                      |
| 2ï¸âƒ£      | It evaluates your cache `key:` value                                            |
| 3ï¸âƒ£      | Runs `codebuild-hash-files package-lock.json` to generate a **unique hash**     |
| 4ï¸âƒ£      | Builds the **final key**, e.g. `npm-cache-abc123`                               |
| 5ï¸âƒ£      | Checks S3 to see if a **cache with this key exists**                            |
| 6ï¸âƒ£      | If **yes** â†’ downloads & restores the cache folder (`node_modules`)             |
| 7ï¸âƒ£      | If **no** â†’ runs `npm ci`, installs everything from scratch                     |
| 8ï¸âƒ£      | After the build â†’ CodeBuild **uploads `node_modules` to S3** using the same key |

---

## ğŸ” What If the Key Doesnâ€™t Match?

Thatâ€™s where `fallback-keys` come in:

```yaml
fallback-keys:
  - npm-cache-
  - npm-
```

ğŸ“¦ CodeBuild tries these **less-specific keys** in order:

- `npm-cache-` â†’ grabs any older matching key
- `npm-` â†’ even more generic fallback

Your build doesnâ€™t fail â€” it might use an older cache if available.

---

## ğŸ’¡ Pro Tip: Why Not Just Use `key: npm-cache`?

Because then:

- It will **never bust the cache**
- If your dependencies change, it **wonâ€™t reflect the changes**
- You risk **dependency mismatches, broken builds, bugs**

Thatâ€™s why `codebuild-hash-files` is the **correct, automated way** to ensure **safe and versioned caching**.

---

## ğŸ—“ï¸ Recap Table: What Each Part Does

| Element                        | Purpose                                                  |
| ------------------------------ | -------------------------------------------------------- |
| `key:`                         | Primary identifier for the cache                         |
| `$(codebuild-hash-files file)` | Dynamically generates a hash to create a unique key      |
| `paths:`                       | Files/folders to restore before build & save after build |
| `fallback-keys:`               | Tries other fallback caches if main key isnâ€™t found      |
| `S3 Bucket (backend)`          | Stores & retrieves cache automatically                   |

---

## ğŸ“Œ Summary: What Youâ€™re Really Saying with This Block

```yaml
cache:
  paths:
    - "node_modules/**/*"
  key: npm-cache-$(codebuild-hash-files package-lock.json)
  fallback-keys:
    - npm-cache-
    - npm-
```

> ğŸ”¥ "Dear CodeBuild, please cache my `node_modules` folder unless my `package-lock.json` changes.  
> If thereâ€™s no exact match, try any similar npm cache instead. Thanks!"

---

## ğŸ”¹ How is the Cache Key Created?

CodeBuild internally:

1. ğŸ” Reads `package-lock.json` as plain text
2. ğŸ“Š Runs SHA-256 hashing on it
3. ğŸ“„ Generates a hash like `a4e57c...`
4. ğŸ“ Combines with prefix to get: `npm-cache-a4e57c...`
5. âœ”ï¸ Uses this as the cache key

Even small changes cause a new key (new version). This enables:

> ğŸ§  **Content-Based Cache Invalidation**

---

## ğŸ“ What Is Actually Stored in the Cache?

Anything under this `paths:` setting:

```yaml
paths:
  - "node_modules/**/*"
```

The whole directory gets zipped and stored in S3.

---

## ğŸ” Next Build: What Happens?

1. Same hash? âœ… Match found â†’ download zip â†’ restore
2. Different hash? âŒ Miss â†’ fallback check â†’ install fresh
3. At the end, save new cache zip in S3

---

## ğŸ§ª Real Cache Folder in S3

Stored like:

```ini
s3://codebuild-cache/project-name/
  â””â”€â”€ npm-cache-a4e57c9d84...zip
```

Inside:

```ini
node_modules/
â”œâ”€â”€ angular/
â”œâ”€â”€ rxjs/
â””â”€â”€ zone.js/
```

---

## ğŸ”¥ TL;DR: Whatâ€™s Going On

| Step | Action                             |
| ---- | ---------------------------------- |
| 1ï¸âƒ£   | Hash `package-lock.json`           |
| 2ï¸âƒ£   | Generate `npm-cache-<hash>` key    |
| 3ï¸âƒ£   | Lookup cache in S3                 |
| 4ï¸âƒ£   | Restore if hit â†’ otherwise install |
| 5ï¸âƒ£   | Push updated cache to S3           |

---

## ğŸ§  Why `fallback-keys` Are Smart

If current key has no match, try these:

```yaml
fallback-keys:
  - npm-cache-
  - npm-
```

Works _only if_ past caches exist with those prefixes.

---

## ğŸ’ª Real-World Use Case

### Day 1: First build

```yaml
key: npm-cache-abc123
```

- No cache yet â†’ full install
- Saves zip to S3

### Day 2: Lock file change

```yaml
key: npm-cache-def456
```

- Cache miss â†’ fallback key `npm-cache-` matches previous
- Uses it, installs delta, and saves new zip

---

## ğŸŒŸ Final Thoughts: Should You Use `fallback-keys`?

| Scenario       | Use `fallback-keys`? | Why                         |
| -------------- | -------------------- | --------------------------- |
| Initial build  | âŒ No                | Nothing to fall back on     |
| Ongoing builds | âœ… Yes               | Reuse older partial matches |
| Monorepos      | âœ… Yes               | Share base layers           |

---

## âœ… TL;DR Summary

| Concept                | Explanation                           |
| ---------------------- | ------------------------------------- |
| `codebuild-hash-files` | Creates dynamic cache keys            |
| Fallbacks              | Optional prefixes to reuse old caches |
| No match               | Fresh install, save zip for future    |
| S3 Cache               | Stores zip named with cache key       |

---

> Want the .NET version of this example too? Let me know and Iâ€™ll break it down for `dotnet restore` with NuGet caching too!
