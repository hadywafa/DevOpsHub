# âš™ï¸ **AWS Lambda Additional Configurations**

AWS Lambda provides additional configurations to **secure, optimize, and enhance** the functionality of your Lambda functions. These configurations include **code signing, encryption, function URLs, VPC access**, and more.

---

## ğŸ” **1. Enable Code Signing â€“ Protect Your Code from Tampering**

Code signing ensures that the **Lambda deployment package has not been altered** and comes from a **trusted source**. This protects against unauthorized changes and ensures code integrity.

### ğŸ›  **How Code Signing Works**

âœ”ï¸ You create a **Code Signing Configuration (CSC)** in AWS.  
âœ”ï¸ The configuration specifies **allowed signing profiles** and a **signature validation policy**.  
âœ”ï¸ When you deploy a Lambda function, AWS **verifies the code signature** before execution.  
âœ”ï¸ If the signature **fails validation**, Lambda **rejects the deployment**.

### ğŸ“Œ **Benefits of Code Signing**

âœ”ï¸ Prevents unauthorized modifications to your code.  
âœ”ï¸ Ensures that only trusted developers can deploy updates.  
âœ”ï¸ Helps meet compliance & security requirements.

### ğŸ”§ **How to Enable Code Signing**

1. Create a **Signing Profile** using AWS Signer.
2. Associate it with a **Code Signing Configuration (CSC)**.
3. Attach the CSC to your Lambda function.

**AWS CLI Example:**

```sh
aws lambda update-function-configuration \
  --function-name myFunction \
  --code-signing-config-arn arn:aws:lambda:region:account-id:code-signing-config:your-csc-id
```

---

## ğŸ” **2. Enable Encryption with AWS KMS â€“ Secure Deployment Packages**

By default, AWS Lambda **encrypts your code archive** with an **AWS-managed key**. However, you can use a **KMS Customer Managed Key (CMK)** for greater control.

### ğŸ“Œ **Why Use a Customer Managed Key (CMK)?**

âœ”ï¸ **Full control** over key rotation and permissions.  
âœ”ï¸ **Restrict access**â€”only authorized users can view or update function code.  
âœ”ï¸ **Meet compliance** and security policies.

### ğŸ”§ **How to Use KMS Encryption**

1. **Create a KMS Key** in AWS Key Management Service (KMS).
2. **Attach the KMS key to the Lambda function** to encrypt the deployment package.

**AWS CLI Example:**

```sh
aws lambda update-function-configuration \
  --function-name myFunction \
  --kms-key-arn arn:aws:kms:region:account-id:key/your-key-id
```

ğŸ’¡ **Best Practice:** Store secrets (e.g., database credentials, API keys) in **AWS Secrets Manager**, not in environment variables.

---

## ğŸŒ **3. Enable Function URL â€“ Expose Your Lambda via HTTPS**

A **Function URL** is a dedicated HTTPS endpoint that **allows direct invocation of your Lambda function**.

### ğŸ“Œ **Why Use Function URLs?**

âœ”ï¸ Invoke Lambda **without needing API Gateway** (simplifies architecture).  
âœ”ï¸ Call the function from **browsers, curl, Postman, or any HTTP client**.  
âœ”ï¸ Secure access with **IAM authentication** or make it **public**.

### ğŸ”§ **How to Create a Function URL**

1. Enable Function URL for your Lambda function.
2. Choose an **auth type** (`AWS_IAM` or `NONE`).
3. (Optional) Configure **CORS** for cross-origin access.

**AWS CLI Example:**

```sh
aws lambda create-function-url-config \
  --function-name myFunction \
  --auth-type NONE
```

âœ”ï¸ AWS will return a **unique URL**, like:

```ini
https://<your-function-id>.lambda-url.<region>.on.aws
```

---

### ğŸ”’ **Function URL Authentication Types**

| **Auth Type** | **Description**                                                                                        |
| ------------- | ------------------------------------------------------------------------------------------------------ |
| `AWS_IAM`     | Requires IAM authentication. Only authorized IAM users & roles can invoke the function.                |
| `NONE`        | Public URLâ€”anyone on the internet can access it. You must handle security manually (JWT, OIDC, OAuth). |

ğŸ’¡ **Best Practice:** Use `AWS_IAM` for sensitive data. If using `NONE`, implement **custom authentication inside your function**.

---

### âš¡ **Invoke Modes for Function URL**

| **Mode**             | **Behavior**                                                                        |
| -------------------- | ----------------------------------------------------------------------------------- |
| `BUFFERED` (default) | Returns a response only after the **entire payload is processed**. (Max size: 6 MB) |
| `RESPONSE_STREAM`    | Streams results **as they are processed** (useful for large payloads).              |

---

### ğŸŒ **Cross-Origin Resource Sharing (CORS)**

âœ”ï¸ Allows access to the function URL from external domains.  
âœ”ï¸ You can control **allowed origins, headers, and methods**.

Example of enabling CORS:

```sh
aws lambda update-function-url-config \
  --function-name myFunction \
  --cors "AllowOrigins=['*'],AllowMethods=['GET','POST']"
```

---

## ğŸ¢ **4. Enable VPC Access â€“ Connect to Private Resources**

By default, AWS Lambda **runs inside an AWS-managed VPC**, **isolated from your private resources**. If your function **needs access to a database, cache, or private API**, you must connect it to a **custom VPC**.

### ğŸ“Œ **Why Use a Custom VPC?**

âœ”ï¸ Access **private RDS databases, ElastiCache, or internal APIs**.  
âœ”ï¸ Restrict access using **Security Groups & Network ACLs**.  
âœ”ï¸ Use **VPC Endpoints** for secure access to AWS services **without internet access**.

### ğŸ”§ **How to Enable VPC Access**

1. Create a **VPC, Subnets, and Security Groups** in AWS.
2. Attach the **VPC configuration** to your Lambda function.

**AWS CLI Example:**

```sh
aws lambda update-function-configuration \
  --function-name myFunction \
  --vpc-config SubnetIds=subnet-123,SecurityGroupIds=sg-456
```

ğŸ’¡ **Best Practice:**  
âœ”ï¸ Use **at least 2 subnets** across different **Availability Zones** for **high availability**.  
âœ”ï¸ If your function needs **internet access**, add a **NAT Gateway** in the VPC.

---

## ğŸ¯ **Final Summary â€“ AWS Lambda Additional Configurations**

| **Feature**           | **Purpose**                  | **Key Benefit**                          |
| --------------------- | ---------------------------- | ---------------------------------------- |
| **Code Signing** ğŸ”   | Ensures code integrity       | Blocks unauthorized deployments          |
| **KMS Encryption** ğŸ” | Encrypts function code       | Full control over key management         |
| **Function URL** ğŸŒ   | Expose Lambda over HTTPS     | Direct invocation without API Gateway    |
| **VPC Access** ğŸ¢     | Connect to private resources | Access RDS, ElastiCache, or private APIs |

---

## ğŸš€ **Final Takeaways**

âœ”ï¸ **Use Code Signing** to protect function code from unauthorized modifications.  
âœ”ï¸ **Enable KMS Encryption** to secure sensitive deployment packages.  
âœ”ï¸ **Use Function URLs** for a simple HTTP endpoint (but secure it properly!).  
âœ”ï¸ **Connect to a VPC** when accessing databases, caches, or private APIs.
