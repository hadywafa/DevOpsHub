# ⚙️ **AWS Lambda Additional Configurations**

AWS Lambda provides additional configurations to **secure, optimize, and enhance** the functionality of your Lambda functions. These configurations include **code signing, encryption, function URLs, VPC access**, and more.

---

## 🔏 **1. Enable Code Signing – Protect Your Code from Tampering**

Code signing ensures that the **Lambda deployment package has not been altered** and comes from a **trusted source**. This protects against unauthorized changes and ensures code integrity.

### 🛠 **How Code Signing Works**

✔️ You create a **Code Signing Configuration (CSC)** in AWS.  
✔️ The configuration specifies **allowed signing profiles** and a **signature validation policy**.  
✔️ When you deploy a Lambda function, AWS **verifies the code signature** before execution.  
✔️ If the signature **fails validation**, Lambda **rejects the deployment**.

### 📌 **Benefits of Code Signing**

✔️ Prevents unauthorized modifications to your code.  
✔️ Ensures that only trusted developers can deploy updates.  
✔️ Helps meet compliance & security requirements.

### 🔧 **How to Enable Code Signing**

1. Create a **Signing Profile** using AWS Signer.
2. Associate it with a **Code Signing Configuration (CSC)**.
3. Attach the CSC to your Lambda function.

**AWS CLI Example:**

```sh
aws lambda update-function-configuration \
  --function-name myFunction \
  --code-signing-config-arn arn:aws:lambda:region:account-id:code-signing-config:your-csc-id
```

---

## 🔐 **2. Enable Encryption with AWS KMS – Secure Deployment Packages**

By default, AWS Lambda **encrypts your code archive** with an **AWS-managed key**. However, you can use a **KMS Customer Managed Key (CMK)** for greater control.

### 📌 **Why Use a Customer Managed Key (CMK)?**

✔️ **Full control** over key rotation and permissions.  
✔️ **Restrict access**—only authorized users can view or update function code.  
✔️ **Meet compliance** and security policies.

### 🔧 **How to Use KMS Encryption**

1. **Create a KMS Key** in AWS Key Management Service (KMS).
2. **Attach the KMS key to the Lambda function** to encrypt the deployment package.

**AWS CLI Example:**

```sh
aws lambda update-function-configuration \
  --function-name myFunction \
  --kms-key-arn arn:aws:kms:region:account-id:key/your-key-id
```

💡 **Best Practice:** Store secrets (e.g., database credentials, API keys) in **AWS Secrets Manager**, not in environment variables.

---

## 🌐 **3. Enable Function URL – Expose Your Lambda via HTTPS**

A **Function URL** is a dedicated HTTPS endpoint that **allows direct invocation of your Lambda function**.

### 📌 **Why Use Function URLs?**

✔️ Invoke Lambda **without needing API Gateway** (simplifies architecture).  
✔️ Call the function from **browsers, curl, Postman, or any HTTP client**.  
✔️ Secure access with **IAM authentication** or make it **public**.

### 🔧 **How to Create a Function URL**

1. Enable Function URL for your Lambda function.
2. Choose an **auth type** (`AWS_IAM` or `NONE`).
3. (Optional) Configure **CORS** for cross-origin access.

**AWS CLI Example:**

```sh
aws lambda create-function-url-config \
  --function-name myFunction \
  --auth-type NONE
```

✔️ AWS will return a **unique URL**, like:

```ini
https://<your-function-id>.lambda-url.<region>.on.aws
```

---

### 🔒 **Function URL Authentication Types**

| **Auth Type** | **Description**                                                                                        |
| ------------- | ------------------------------------------------------------------------------------------------------ |
| `AWS_IAM`     | Requires IAM authentication. Only authorized IAM users & roles can invoke the function.                |
| `NONE`        | Public URL—anyone on the internet can access it. You must handle security manually (JWT, OIDC, OAuth). |

💡 **Best Practice:** Use `AWS_IAM` for sensitive data. If using `NONE`, implement **custom authentication inside your function**.

---

### ⚡ **Invoke Modes for Function URL**

| **Mode**             | **Behavior**                                                                        |
| -------------------- | ----------------------------------------------------------------------------------- |
| `BUFFERED` (default) | Returns a response only after the **entire payload is processed**. (Max size: 6 MB) |
| `RESPONSE_STREAM`    | Streams results **as they are processed** (useful for large payloads).              |

---

### 🌍 **Cross-Origin Resource Sharing (CORS)**

✔️ Allows access to the function URL from external domains.  
✔️ You can control **allowed origins, headers, and methods**.

Example of enabling CORS:

```sh
aws lambda update-function-url-config \
  --function-name myFunction \
  --cors "AllowOrigins=['*'],AllowMethods=['GET','POST']"
```

---

## 🏢 **4. Enable VPC Access – Connect to Private Resources**

By default, AWS Lambda **runs inside an AWS-managed VPC**, **isolated from your private resources**. If your function **needs access to a database, cache, or private API**, you must connect it to a **custom VPC**.

### 📌 **Why Use a Custom VPC?**

✔️ Access **private RDS databases, ElastiCache, or internal APIs**.  
✔️ Restrict access using **Security Groups & Network ACLs**.  
✔️ Use **VPC Endpoints** for secure access to AWS services **without internet access**.

### 🔧 **How to Enable VPC Access**

1. Create a **VPC, Subnets, and Security Groups** in AWS.
2. Attach the **VPC configuration** to your Lambda function.

**AWS CLI Example:**

```sh
aws lambda update-function-configuration \
  --function-name myFunction \
  --vpc-config SubnetIds=subnet-123,SecurityGroupIds=sg-456
```

💡 **Best Practice:**  
✔️ Use **at least 2 subnets** across different **Availability Zones** for **high availability**.  
✔️ If your function needs **internet access**, add a **NAT Gateway** in the VPC.

---

## 🎯 **Final Summary – AWS Lambda Additional Configurations**

| **Feature**           | **Purpose**                  | **Key Benefit**                          |
| --------------------- | ---------------------------- | ---------------------------------------- |
| **Code Signing** 🔏   | Ensures code integrity       | Blocks unauthorized deployments          |
| **KMS Encryption** 🔐 | Encrypts function code       | Full control over key management         |
| **Function URL** 🌐   | Expose Lambda over HTTPS     | Direct invocation without API Gateway    |
| **VPC Access** 🏢     | Connect to private resources | Access RDS, ElastiCache, or private APIs |

---

## 🚀 **Final Takeaways**

✔️ **Use Code Signing** to protect function code from unauthorized modifications.  
✔️ **Enable KMS Encryption** to secure sensitive deployment packages.  
✔️ **Use Function URLs** for a simple HTTP endpoint (but secure it properly!).  
✔️ **Connect to a VPC** when accessing databases, caches, or private APIs.
