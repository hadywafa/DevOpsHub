# ğŸ§° ELB Core Components â€“ Explained Like a Human ğŸ¤“

Elastic Load Balancing (ELB) is like a smart traffic cop for your application. It decides **where requests go**, checks **whoâ€™s healthy**, and makes sure **no one gets overwhelmed**. Letâ€™s break down the core components of ELB in a way thatâ€™s clear, detailed, and just a bit fun.

<div style="text-align: center">
  <img src="images/elb-core-components.png" style="border-radius: 10px" alt="ELB Core Components">
</div>

---

## ğŸ¯ 1. Target Groups â€“ The Backend Squad

A **Target Group** is a team of servers (EC2 instances, ECS containers, IP addresses, or Lambda functions) that actually do the work when a request comes in.

### ğŸ§  What Happens Internally

- You define which targets belong to a group.
- ELB keeps an eye on their health.
- When a request comes in, the listener uses **rules** to forward it to the appropriate target group.

### âœ… Use Cases

- `/api` goes to Target Group A (EC2 backend)
- `/media` goes to Target Group B (ECS containers)

---

## ğŸ§ 2. Listeners â€“ The Gatekeepers ğŸ›ï¸

A **Listener** is the first thing that receives incoming traffic on the load balancer. Think of it as a receptionist that answers the phone and knows who to connect you to based on your request.

### ğŸ“¦ What a Listener Does

- **Listens** on a port (like 80 or 443) using a protocol (HTTP, HTTPS, TCP, etc.)
- **Evaluates rules** to decide which target group to send the request to
- **Supports multiple listeners** (one ELB can listen on multiple ports)

### ğŸ§ª Real-World Example

- HTTP listener on port 80 â†’ forwards to Target Group A
- HTTPS listener on port 443 â†’ forwards to Target Group B

---

## ğŸ§¾ 3. Listener Rules â€“ The Routing Brain ğŸ§ 

Once a listener receives the traffic, **rules** kick in. These rules are like if-else statements:

### ğŸ§© Conditions It Can Use

- **Host-based**: `api.example.com`
- **Path-based**: `/login`, `/products`, `/cart`
- **Header/query strings** (only on ALB)

### ğŸ¬ What Rules Can Do

- **Forward** traffic to a target group
- **Redirect** the request to a different URL
- **Return** a fixed response (like a 404 page)
- **Authenticate** the request (via Cognito or OIDC)

### ğŸ… Rule Priority

- Rules are evaluated **in order**. First match wins.
- If nothing matches, ELB uses the **default rule**.

### âœ… Example Rules

- If path = `/admin` â†’ forward to Admin Target Group
- If host = `api.example.com` â†’ forward to API Target Group
- Default â†’ fixed response: `404 Not Found`

---

## ğŸ”„ 4. Actions â€“ What Happens When Rules Match ğŸ¯

Once a rule matches, ELB needs to know **what to do**. Thatâ€™s where **Actions** come in.

### ğŸš¦ Types of Actions

- **Forward**: Send to a target group
- **Redirect**: Change URL, port, or protocol (e.g., HTTP â†’ HTTPS)
- **Fixed Response**: Return a message without hitting a backend (e.g., `503: Service Unavailable`)
- **Authenticate**: Let users log in before accessing your app (ALB only)

---

## ğŸ©º 5. Health Checks â€“ Quality Control Doctor ğŸ‘©â€âš•ï¸

Before ELB sends traffic to a target, it checks: â€œHey, are you alive and healthy?â€

### ğŸ” How It Works

- ELB sends periodic requests to a specified path (e.g., `/health`)
- If a target **fails repeatedly**, it is marked **unhealthy** and ELB stops sending traffic to it
- Once it **passes health checks again**, ELB resumes routing to it

### ğŸ› ï¸ Configurable Settings

- Path (e.g., `/health`)
- Port (can be fixed or dynamic)
- Success/failure thresholds

---

## ğŸ›°ï¸ How It All Works Together â€“ Traffic Flow ğŸ‘‡

Letâ€™s walk through a typical journey of a request from a user to your backend:

### ğŸ§µ Sequence Flow

```mermaid
sequenceDiagram
  participant User
  participant Route53
  participant ELB
  participant Listener
  participant Rule Engine
  participant Target Group
  participant EC2/ECS

  User->>Route53: Lookup domain (e.g., www.example.com)
  Route53->>User: Returns ELB DNS name
  User->>ELB: Sends HTTP/HTTPS request
  ELB->>Listener: Accepts request on port 80/443
  Listener->>Rule Engine: Match conditions (host/path)
  Rule Engine->>Target Group: Route to appropriate target group
  Target Group->>EC2/ECS: Forward request
  EC2/ECS->>User: Return response
```

### ğŸ”„ Health Check Monitoring

<div style="display: flex; justify-content: center; align-items: center;">

```mermaid
sequenceDiagram
  participant ELB
  participant Target

  loop Every X seconds
    ELB->>Target: Ping /health
    alt Healthy
      Target->>ELB: 200 OK
    else Unhealthy
      Target->>ELB: 500 Error
      ELB-->>Target: Mark as unhealthy
    end
  end
```

</div>

---

## ğŸ§  Recap â€“ What Did We Learn?

| Component         | Role                                                                   |
| ----------------- | ---------------------------------------------------------------------- |
| **Target Group**  | Backend pool of targets that serve your app                            |
| **Listener**      | Entry point that listens on port/protocol and triggers rule evaluation |
| **Rules**         | Logic to route traffic based on conditions (host/path/etc.)            |
| **Actions**       | What to do when a rule matches (forward/redirect/fixed/auth)           |
| **Health Checks** | Keeps traffic away from unhealthy targets                              |

---

## ğŸ Final Thoughts

An ELB is like a super organized air traffic controller that:

- Welcomes every request (Listener)
- Evaluates where it needs to go (Rules)
- Makes decisions (Actions)
- Sends it to the right team (Target Group)
- Keeps watch on who's fit to work (Health Checks)
