# ☸️ EKS **Access Entries**

> 💡 _Access Entry = AWS’s way of connecting IAM to Kubernetes RBAC without manual mapping._

---

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
    <img src="image/1761546372088.png" alt="EKS Access Policy" style="width: 60%">
</div>

---

## 📖 **What Is an Access Entry?**

An **Access Entry** in Amazon EKS is a new, managed resource that defines **who (IAM identity)** can access **what (EKS cluster)** and **how (Access Policy)**.

It’s basically the **bridge** between:

- 🟦 AWS IAM identities (roles, users, federated users)
- 🟧 Kubernetes RBAC (roles, bindings, permissions)

---

### 🔍 Think of It Like:

> “The `aws-auth` ConfigMap — but automated, centralized, and safely managed by AWS.”

Old world:

```yaml
mapRoles:
  - rolearn: arn:aws:iam::1234567890:role/devops
    username: devops
    groups:
      - system:masters
```

New world:

```bash
aws eks create-access-entry \
  --cluster-name my-cluster \
  --principal-arn arn:aws:iam::1234567890:role/devops
```

✅ No YAML editing  
✅ No risk of locking yourself out  
✅ No `kubectl` access required

---

## 🧩 The Core Purpose of Access Entries

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Goal                                  | Description                                                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Replace aws-auth ConfigMap**        | The `aws-auth` ConfigMap was fragile, manual, and cluster-local. Access Entries replace it with a managed API. |
| **Connect IAM to Kubernetes**         | Lets AWS understand which IAM identity maps to which Kubernetes “user/group”.                                  |
| **Enable Access Policies**            | Serves as a _mounting point_ for AWS-managed access policies (Admin, Edit, View, etc.).                        |
| **Centralize Cluster Access Control** | Makes access visible and auditable in AWS Console & CloudTrail.                                                |
| **Allow Namespace Scoping**           | You can now assign access to only specific namespaces (was impossible before).                                 |
| **Support Multi-User Governance**     | Different IAM users/roles can have different access levels without editing Kubernetes RBAC directly.           |

</div>

---

## 🧠 **Why AWS Introduced Access Entries**

### 💥 Before:

- You needed admin privileges to modify `aws-auth` ConfigMap.
- Misconfigurations easily locked out everyone.
- No audit trail in AWS.
- No namespace or per-user granularity.

### 🚀 After (With Access Entries):

- AWS manages mappings via API and console.
- You can assign access like IAM policies.
- Immediate effect (no YAML reload delay).
- Visibility across accounts, clusters, and identities.

---

## 🏗️ **The Three Parts of an Access Entry**

Each Access Entry is composed of 3 key components:

| Component           | Purpose                                                                | Example                                       |
| ------------------- | ---------------------------------------------------------------------- | --------------------------------------------- |
| **Principal ARN**   | The AWS IAM identity allowed to access the cluster                     | `arn:aws:iam::1234567890:role/eks-admin`      |
| **Group Names**     | Mapped Kubernetes groups (used in RoleBindings or ClusterRoleBindings) | `system:masters` / `my-admin`                 |
| **Access Policies** | AWS-managed permission sets defining what that user/role can do        | `AmazonEKSAdminPolicy`, `AmazonEKSViewPolicy` |

---

### 🧩 Structure Example

A full Access Entry might look like this:

```json
{
  "principalArn": "arn:aws:iam::065656773845:role/orchida-tax-eks-admin",
  "type": "Standard",
  "groups": ["my-admin"],
  "accessPolicies": [
    {
      "policyName": "AmazonEKSAdminPolicy",
      "accessScope": {
        "type": "cluster"
      }
    }
  ]
}
```

📘 Meaning:

- The IAM role `orchida-tax-eks-admin` can access the cluster.
- It is recognized inside K8s as belonging to group `my-admin`.
- It has `AdminPolicy` permissions (broad control across the cluster).

---

## 🔐 5️⃣ Where It Lives

Access Entries are **stored and managed by AWS EKS control plane**, not inside Kubernetes.

| Storage                        | Control Plane |
| ------------------------------ | ------------- |
| AWS-managed                    | ✅ Yes        |
| In your EKS cluster            | ❌ No         |
| In ConfigMap                   | ❌ No         |
| Accessible via AWS CLI/Console | ✅ Yes        |

That means:

- It’s **global** for the cluster (not namespace-specific).
- AWS enforces it _before_ the Kubernetes API sees your request.

---

## 🧭 6️⃣ How It Fits in the Big Picture

```mermaid
graph TD
A[AWS IAM User/Role] -->|STS Token| B[EKS Access Entry]
B --> C[Access Policy (Admin/Edit/View)]
C --> D[Kubernetes API Server]
D --> E[RBAC Engine]
E --> F[Pods, Nodes, Services...]
```

🟢 IAM authenticates →
🟣 Access Entry maps the user →
🟦 Access Policy grants logical rights →
🟧 Kubernetes RBAC enforces action

---

## 📜 7️⃣ Access Entry Types

| Type                               | Description                              | Example Use Case             |
| ---------------------------------- | ---------------------------------------- | ---------------------------- |
| **Standard**                       | Default type for IAM roles/users         | Developers, admins, DevOps   |
| **Node**                           | Automatically created for node IAM roles | Worker node auth for kubelet |
| **ServiceAccount** _(coming soon)_ | For IRSA-linked identities               | App pods assuming roles      |

---

## 🧭 8️⃣ Example — Real-World Case

**Scenario:**
You want your DevOps engineer (IAM role `orchida-tax-eks-admin`) to have cluster admin privileges.

**Steps:**
1️⃣ Create IAM role `orchida-tax-eks-admin`.
2️⃣ Add it as an Access Entry in your EKS cluster:

```bash
aws eks create-access-entry \
  --cluster-name orchida-tax-eks \
  --principal-arn arn:aws:iam::065656773845:role/orchida-tax-eks-admin
```

3️⃣ Attach a policy:

```bash
aws eks associate-access-policy \
  --cluster-name orchida-tax-eks \
  --principal-arn arn:aws:iam::065656773845:role/orchida-tax-eks-admin \
  --policy-arn arn:aws:eks::aws:access-policy/AmazonEKSAdminPolicy \
  --access-scope type=cluster
```

✅ Now this IAM role can authenticate and execute `kubectl` commands based on the policy permissions.

---

## 🧠 9️⃣ Summary Table

| Feature               | aws-auth ConfigMap | Access Entry        |
| --------------------- | ------------------ | ------------------- |
| Storage               | Inside cluster     | AWS-managed         |
| Management            | Manual YAML        | Console / CLI / IaC |
| Namespace Scoping     | ❌                 | ✅                  |
| IAM Integration       | Partial            | Full                |
| Auditing (CloudTrail) | ❌                 | ✅                  |
| Risk of lockout       | High               | Very Low            |
| Dynamic updates       | Slow               | Immediate           |

---

## ⚡ TL;DR

> 🔹 **Access Entry = IAM → EKS Bridge**
> 🔹 Replaces `aws-auth` ConfigMap with managed, auditable AWS-native API
> 🔹 Defines who (principal), which groups, and what permissions (via Access Policy)
> 🔹 Centralizes cluster access control under AWS governance
> 🔹 Still works hand-in-hand with Kubernetes RBAC

---

Would you like me to continue with **Part 2: Access Entry Internals** next — where we’ll dissect what happens _inside_ EKS when an Access Entry is created, how it’s stored, resolved, and linked to Access Policies and RBAC?
