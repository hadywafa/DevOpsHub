# â˜¸ï¸ EKS **Access Entries**

> ğŸ’¡ _Access Entry = AWSâ€™s way of connecting IAM to Kubernetes RBAC without manual mapping._

---

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
    <img src="image/1761546372088.png" alt="EKS Access Policy" style="width: 60%">
</div>

---

## ğŸ“– **What Is an Access Entry?**

An **Access Entry** in Amazon EKS is a new, managed resource that defines **who (IAM identity)** can access **what (EKS cluster)** and **how (Access Policy)**.

Itâ€™s basically the **bridge** between:

- ğŸŸ¦ AWS IAM identities (roles, users, federated users)
- ğŸŸ§ Kubernetes RBAC (roles, bindings, permissions)

---

### ğŸ” Think of It Like:

> â€œThe `aws-auth` ConfigMap â€” but automated, centralized, and safely managed by AWS.â€

Old world:

```yaml
mapRoles:
  - rolearn: arn:aws:iam::1234567890:role/devops
    username: devops
    groups:
      - system:masters
```

New world:

```bash
aws eks create-access-entry \
  --cluster-name my-cluster \
  --principal-arn arn:aws:iam::1234567890:role/devops
```

âœ… No YAML editing  
âœ… No risk of locking yourself out  
âœ… No `kubectl` access required

---

## ğŸ§© The Core Purpose of Access Entries

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Goal                                  | Description                                                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Replace aws-auth ConfigMap**        | The `aws-auth` ConfigMap was fragile, manual, and cluster-local. Access Entries replace it with a managed API. |
| **Connect IAM to Kubernetes**         | Lets AWS understand which IAM identity maps to which Kubernetes â€œuser/groupâ€.                                  |
| **Enable Access Policies**            | Serves as a _mounting point_ for AWS-managed access policies (Admin, Edit, View, etc.).                        |
| **Centralize Cluster Access Control** | Makes access visible and auditable in AWS Console & CloudTrail.                                                |
| **Allow Namespace Scoping**           | You can now assign access to only specific namespaces (was impossible before).                                 |
| **Support Multi-User Governance**     | Different IAM users/roles can have different access levels without editing Kubernetes RBAC directly.           |

</div>

---

## ğŸ§  **Why AWS Introduced Access Entries**

### ğŸ’¥ Before:

- You needed admin privileges to modify `aws-auth` ConfigMap.
- Misconfigurations easily locked out everyone.
- No audit trail in AWS.
- No namespace or per-user granularity.

### ğŸš€ After (With Access Entries):

- AWS manages mappings via API and console.
- You can assign access like IAM policies.
- Immediate effect (no YAML reload delay).
- Visibility across accounts, clusters, and identities.

---

## ğŸ—ï¸ **The Three Parts of an Access Entry**

Each Access Entry is composed of 3 key components:

| Component           | Purpose                                                                | Example                                       |
| ------------------- | ---------------------------------------------------------------------- | --------------------------------------------- |
| **Principal ARN**   | The AWS IAM identity allowed to access the cluster                     | `arn:aws:iam::1234567890:role/eks-admin`      |
| **Group Names**     | Mapped Kubernetes groups (used in RoleBindings or ClusterRoleBindings) | `system:masters` / `my-admin`                 |
| **Access Policies** | AWS-managed permission sets defining what that user/role can do        | `AmazonEKSAdminPolicy`, `AmazonEKSViewPolicy` |

---

### ğŸ§© Structure Example

A full Access Entry might look like this:

```json
{
  "principalArn": "arn:aws:iam::065656773845:role/orchida-tax-eks-admin",
  "type": "Standard",
  "groups": ["my-admin"],
  "accessPolicies": [
    {
      "policyName": "AmazonEKSAdminPolicy",
      "accessScope": {
        "type": "cluster"
      }
    }
  ]
}
```

ğŸ“˜ Meaning:

- The IAM role `orchida-tax-eks-admin` can access the cluster.
- It is recognized inside K8s as belonging to group `my-admin`.
- It has `AdminPolicy` permissions (broad control across the cluster).

---

## ğŸ” 5ï¸âƒ£ Where It Lives

Access Entries are **stored and managed by AWS EKS control plane**, not inside Kubernetes.

| Storage                        | Control Plane |
| ------------------------------ | ------------- |
| AWS-managed                    | âœ… Yes        |
| In your EKS cluster            | âŒ No         |
| In ConfigMap                   | âŒ No         |
| Accessible via AWS CLI/Console | âœ… Yes        |

That means:

- Itâ€™s **global** for the cluster (not namespace-specific).
- AWS enforces it _before_ the Kubernetes API sees your request.

---

## ğŸ§­ 6ï¸âƒ£ How It Fits in the Big Picture

```mermaid
graph TD
A[AWS IAM User/Role] -->|STS Token| B[EKS Access Entry]
B --> C[Access Policy (Admin/Edit/View)]
C --> D[Kubernetes API Server]
D --> E[RBAC Engine]
E --> F[Pods, Nodes, Services...]
```

ğŸŸ¢ IAM authenticates â†’
ğŸŸ£ Access Entry maps the user â†’
ğŸŸ¦ Access Policy grants logical rights â†’
ğŸŸ§ Kubernetes RBAC enforces action

---

## ğŸ“œ 7ï¸âƒ£ Access Entry Types

| Type                               | Description                              | Example Use Case             |
| ---------------------------------- | ---------------------------------------- | ---------------------------- |
| **Standard**                       | Default type for IAM roles/users         | Developers, admins, DevOps   |
| **Node**                           | Automatically created for node IAM roles | Worker node auth for kubelet |
| **ServiceAccount** _(coming soon)_ | For IRSA-linked identities               | App pods assuming roles      |

---

## ğŸ§­ 8ï¸âƒ£ Example â€” Real-World Case

**Scenario:**
You want your DevOps engineer (IAM role `orchida-tax-eks-admin`) to have cluster admin privileges.

**Steps:**
1ï¸âƒ£ Create IAM role `orchida-tax-eks-admin`.
2ï¸âƒ£ Add it as an Access Entry in your EKS cluster:

```bash
aws eks create-access-entry \
  --cluster-name orchida-tax-eks \
  --principal-arn arn:aws:iam::065656773845:role/orchida-tax-eks-admin
```

3ï¸âƒ£ Attach a policy:

```bash
aws eks associate-access-policy \
  --cluster-name orchida-tax-eks \
  --principal-arn arn:aws:iam::065656773845:role/orchida-tax-eks-admin \
  --policy-arn arn:aws:eks::aws:access-policy/AmazonEKSAdminPolicy \
  --access-scope type=cluster
```

âœ… Now this IAM role can authenticate and execute `kubectl` commands based on the policy permissions.

---

## ğŸ§  9ï¸âƒ£ Summary Table

| Feature               | aws-auth ConfigMap | Access Entry        |
| --------------------- | ------------------ | ------------------- |
| Storage               | Inside cluster     | AWS-managed         |
| Management            | Manual YAML        | Console / CLI / IaC |
| Namespace Scoping     | âŒ                 | âœ…                  |
| IAM Integration       | Partial            | Full                |
| Auditing (CloudTrail) | âŒ                 | âœ…                  |
| Risk of lockout       | High               | Very Low            |
| Dynamic updates       | Slow               | Immediate           |

---

## âš¡ TL;DR

> ğŸ”¹ **Access Entry = IAM â†’ EKS Bridge**
> ğŸ”¹ Replaces `aws-auth` ConfigMap with managed, auditable AWS-native API
> ğŸ”¹ Defines who (principal), which groups, and what permissions (via Access Policy)
> ğŸ”¹ Centralizes cluster access control under AWS governance
> ğŸ”¹ Still works hand-in-hand with Kubernetes RBAC

---

Would you like me to continue with **Part 2: Access Entry Internals** next â€” where weâ€™ll dissect what happens _inside_ EKS when an Access Entry is created, how itâ€™s stored, resolved, and linked to Access Policies and RBAC?
