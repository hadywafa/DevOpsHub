# â˜¸ï¸ **Why AWS Introduced EKS Access Policies**

> _A tale of two worlds: IAM (AWS) ğŸ†š RBAC (Kubernetes)_

---

## ğŸ•°ï¸ **Background â€” The Pain Before Access Entries**

Traditionally, **Kubernetes RBAC** controls â€œwho can do whatâ€ inside the cluster.
Butâ€¦ when you run EKS, you face **two distinct identity worlds**:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Layer              | System          | Identity Type                          | Problem                                                 |
| ------------------ | --------------- | -------------------------------------- | ------------------------------------------------------- |
| **Authentication** | AWS IAM         | IAM users, roles, federated identities | AWS knows who you are                                   |
| **Authorization**  | Kubernetes RBAC | ServiceAccounts, Users, Groups         | K8s doesnâ€™t know who you are unless you manually map it |

</div>

Before Access Policies existed, you had to manually edit a ConfigMap called `aws-auth`:

```yaml
mapRoles:
  - rolearn: arn:aws:iam::1234567890:role/Admin
    username: admin
    groups:
      - system:masters
```

That mapping was **manual, brittle, and dangerous**:

- Editing the `aws-auth` ConfigMap incorrectly could **lock everyone out** ğŸ˜±
- You had no central audit or IAM integration.
- No namespace-level granularity (you had to manage RBAC by hand).

So AWS asked:

> â€œWhat if we could bring Kubernetes authorization closer to AWS IAM principles â€” without replacing RBAC entirely?â€

Thatâ€™s where **Access Entries** and **Access Policies** came in.

---

## ğŸ” **EKS Access Policies** â€” The AWS-Layer RBAC Bridge

Think of **EKS Access Policies** as _prebuilt, AWS-managed RBAC bundles_ that live on the **authentication side** of EKS, not _inside_ Kubernetes directly.

Hereâ€™s the flow:

<div align="center" style="background-color: #2b3436ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
participant IAM Role
participant EKS Access Entry
participant EKS Access Policy
participant Kubernetes API Server
participant RBAC Rules

IAM Role->>EKS Access Entry: Authenticates (AWS STS token)
EKS Access Entry->>EKS Access Policy: Looks up mapped policy
EKS Access Policy->>Kubernetes API Server: Translates policy to RBAC verbs
Kubernetes API Server->>RBAC Rules: Enforces final access (allow/deny)
```

</div>

â¡ï¸ The Access Policy **translates AWS policy â†’ Kubernetes verbs (get/list/create/etc.)**  
â¡ï¸ Then Kubernetes still **enforces** those verbs with its internal RBAC engine.

---

## ğŸ§¬ **Relationship Between IAM, EKS Access Policy, and K8s RBAC**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Layer                 | Who It Belongs To | Controls                       | Managed By    | Example                  |
| --------------------- | ----------------- | ------------------------------ | ------------- | ------------------------ |
| **IAM**               | AWS               | Auth (who are you)             | AWS IAM       | AssumeRole / STS         |
| **EKS Access Policy** | AWS               | Simplified K8s permission sets | AWS-managed   | AmazonEKSAdminPolicy     |
| **K8s RBAC**          | Kubernetes        | Fine-grained resource actions  | Cluster Admin | ClusterRole, RoleBinding |

</div>

So EKS Access Policies are **an optional, managed layer** between IAM and RBAC â€” you can still use pure RBAC if you prefer.

---

## ğŸ¤” **Why AWS Did This?**

### ğŸ§  Motivation Summary

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Reason                              | Explanation                                                                                                                            |
| ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| **ğŸ§© Simplify onboarding**          | Instead of editing `aws-auth` ConfigMap or manually binding ClusterRoles, you attach a predefined access policy in the console or CLI. |
| **ğŸ›¡ï¸ Improve security**             | AWS owns and audits these policies â€” theyâ€™re tested and restricted by default (e.g., `Admin` doesnâ€™t equal full `cluster-admin`).      |
| **âš™ï¸ Centralized management**       | Access entries appear in AWS Console, CloudTrail, and can be versioned/audited like IAM resources.                                     |
| **ğŸš€ Namespace granularity**        | You can assign policies scoped to certain namespaces directly, no YAML needed.                                                         |
| **ğŸ“œ Declarative IAM-like control** | Everything (AccessEntry + Policy) can be managed via IaC tools (Terraform, CloudFormation, etc.)                                       |

</div>

---

## âš–ï¸ **Coexistence Model â€” Both Still Matter**

You can think of it like **two layers of a firewall**:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Layer                       | Role                                                               |
| --------------------------- | ------------------------------------------------------------------ |
| **AWS Access Policy Layer** | Who is allowed to _enter_ and which broad actions they can perform |
| **K8s RBAC Layer**          | What the authenticated identity can do _once inside the cluster_   |

</div>

Example:

- You attach `AmazonEKSEditPolicy` to an IAM Role.
- That maps to RBAC verbs like `create/update/delete` on Deployments and Services.
- Inside Kubernetes, RBAC still enforces namespaces, RoleBindings, and group rules.

You can **stack both** for precision control.

---

## â‰ï¸ **Soâ€¦ Should We Still Use RBAC?**

âœ… **Yes, absolutely.**  
EKS Access Policies are great for:

- Centralized access management
- Quick role assignment (e.g., â€œGive Dev team view-only accessâ€)
- Namespace-level boundaries

But for:

- Custom CRDs (Custom Resources)
- Fine-grained role separation (e.g., â€œcan patch ConfigMaps but not deleteâ€)
- ServiceAccount permissions inside the cluster

ğŸ‘‰ You **still need native RBAC**.

---

## ğŸ **Summary: Why AWS Created Access Policies**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Problem                             | Traditional EKS                  | Solution (Access Policy)         |
| ----------------------------------- | -------------------------------- | -------------------------------- |
| Hard to manage `aws-auth` ConfigMap | Manual YAML edits                | Automatic Access Entry API       |
| No visibility in IAM                | Cluster-local only               | IAM + CloudTrail integration     |
| No namespace scoping                | All-or-nothing RBAC              | Policy scopes (`type=namespace`) |
| No standardized roles               | You had to define your own Roles | AWS provides managed policies    |
| Risk of misconfig                   | Misbinding RBAC can lock you out | Pretested safe defaults          |

</div>

---

## ğŸ§­ **Visual Summary**

<div align="center" style="background-color: #2b3436ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
A[AWS IAM Role/User] --> B[EKS Access Entry]
B --> C["EKS Access Policy (AWS-managed)"]
C --> D[Kubernetes RBAC Layer]
D --> E["Kubernetes Resources (Pods, Nodes, etc.)"]
```

</div>

ğŸŸ¢ **IAM** â†’ Authenticates  
ğŸ”µ **EKS Access Policy** â†’ Broad authorization mapping  
ğŸŸ£ **RBAC** â†’ Enforces detailed permissions

---

### âš¡ **TL;DR**

> AWS didnâ€™t _replace_ Kubernetes RBAC â€” they **wrapped it with an IAM-native control layer** for simplicity, auditability, and enterprise management.  
> You can still use RBAC directly, but AWSâ€™s layer saves you from touching that fragile `aws-auth` ConfigMap ever again.
