# 🔐 Access to Sensitive Data in Kubernetes: How Attackers Steal Secrets (and How to Stop Them)

This guide explains how attackers gain unauthorized access to sensitive data inside a Kubernetes cluster — and how to defend against it using **RBAC hardening**, **secure logging**, and **network encryption**.

---

## 🧠 What Counts as Sensitive Data?

In Kubernetes, sensitive data includes:

- Kubernetes Secrets (e.g., API keys, DB credentials)
- ConfigMaps with internal settings
- Application logs containing passwords or PII
- Mounted volumes with unencrypted files
- Network traffic with credentials in transit
- Cluster encryption keys

If an attacker gets access to any of these, they can:

- Steal user data
- Escalate privileges
- Move laterally across the cluster

---

## 🔍 Common Attack Vectors

| Attack Vector           | Description                                                            | Mitigation                                                     |
| ----------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------- |
| etcd Access             | Direct access to etcd exposes Secrets and cluster state                | Enable TLS, use RBAC, rotate encryption keys                   |
| Kubelet API             | Exposed endpoints leak logs, pod specs, or allow exec access           | Use TLS client certs, restrict with network policies           |
| Application Logs        | Logs with passwords or tokens become high-value targets                | Redact sensitive fields, centralize logs securely              |
| Persistent Volumes      | Mounted volumes reused by other pods can leak data                     | Use accessModes, encryption at rest, and Pod Security Policies |
| Network Shares (NFS)    | Unprotected NFS/SMB shares can be read by unauthorized pods or clients | Enforce mount restrictions and authentication                  |
| Cluster Encryption Keys | If compromised, all encrypted data at rest becomes readable            | Store keys in HSMs, rotate regularly                           |

---

## 🧪 Example: Over-Permissive RBAC in a Node.js Backend

Let’s say you have a Node.js app running in the `backend` namespace. Its service account (`backend-sa`) has this Role:

```yaml
rules:
  - resources: ["configmaps", "secrets"]
    verbs: ["get", "list"]
  - resources: ["pods"]
    verbs: ["get", "list", "watch"]
```

This means any pod using `backend-sa` can:

- List all Secrets in the namespace
- Read database credentials, API tokens, etc.

### Secret Example

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
  namespace: backend
type: Opaque
data:
  DB_USERNAME: dXNlcm5hbWU= # "username"
  DB_PASSWORD: cGFzc3dvcmQ= # "password"
```

> ⚠️ _Warning_: If an attacker compromises the pod, they can run `kubectl get secrets` and extract everything.

---

## 🔐 Hardened RBAC: Least Privilege in Action

Instead of giving access to Secrets, limit the Role to only what’s needed:

```yaml
rules:
  - resources: ["configmaps"]
    verbs: ["get", "list"]
  - resources: ["pods"]
    verbs: ["get", "list"]
```

> _Tip_: Always follow the **principle of least privilege** — only grant access to what’s absolutely necessary.

---

## 🧾 Securing Application Logs

Logs often leak sensitive data. Here’s what **not** to do:

### ❌ Risky Logging

```text
[INFO] Executing query: SELECT * FROM users WHERE email='user@example.com' AND password='superSecretPassword123'
[DEBUG] Payload: {"creditCardNumber":"4111111111111111","cvv":"123"}
```

### ✅ Redacted Logging

```text
[INFO] Executing query: SELECT * FROM users WHERE email='**********' AND password='**********'
[DEBUG] Payload: {"creditCardNumber":"************","cvv":"***"}
```

### Best Practices

- Never log passwords, tokens, or PII
- Use structured logging with redaction filters
- Centralize logs in a secure system (e.g., Elasticsearch with RBAC)
- Monitor log access and alert on anomalies

---

## 🔒 Encrypting Network Traffic

All inter-service communication should use **TLS** or **mTLS** to prevent sniffing.

### ❌ Unencrypted HTTP

```http
POST /api/login
{
  "username": "john_doe",
  "password": "superSecret123"
}
```

### ✅ Encrypted HTTPS

```http
POST /api/login
Authorization: Bearer <token>
TLS: true
```

> _Tip_: Use **mTLS** between pods and enforce HTTPS for all internal and external traffic.

---

## 🔁 Summary & Best Practices

✅ Apply **least-privilege RBAC** — don’t let pods read Secrets unless absolutely necessary  
✅ **Redact logs** and avoid logging sensitive data  
✅ Use **TLS/mTLS** for all network communication  
✅ **Rotate encryption keys and Secrets** regularly  
✅ **Audit access** to etcd, kubelet, and logs  
✅ **Secure volumes and network shares** with access controls and encryption
