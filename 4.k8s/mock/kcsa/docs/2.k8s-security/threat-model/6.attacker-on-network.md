# ðŸŒ Network-Level Attacks in Kubernetes: How Adversaries Disrupt Your Cluster

This guide explains how attackers operating at the **network layer** can launch Denial-of-Service (DoS) attacks against Kubernetes clusters. Weâ€™ll walk through how they target compute resources, control-plane services, and pod networking â€” and how to stop them.

---

## ðŸ§  What Is a Network-Level Attacker?

A network-level attacker doesnâ€™t need to compromise your application directly. Instead, they:

- Overload nodes and kubelets
- Disrupt control-plane communication
- Break pod-to-pod networking
- Exploit open ports and misconfigured firewalls

These attacks can cause **cluster-wide outages**, even if your workloads are secure.

---

## ðŸ”¥ Attack Vector 1: Exhausting Compute Resources

Attackers target **worker nodes and kubelets** to reduce cluster capacity:

### ðŸ§¨ Techniques

- **Flood kubelet endpoints** like `/healthz` or `/metrics`
- **Corrupt node files** to make nodes report `NotReady`
- **Block health checks**, causing nodes to be marked unschedulable
- **Deploy malicious pods** that consume excessive CPU or memory

> _Note_: If autoscaling is enabled, this can trigger **automatic node replacement**, adding cost and instability.

---

## ðŸ”¥ Attack Vector 2: Disrupting the Control Plane

The control plane runs Kubernetes itself. Attacking it can bring the entire cluster down.

| Component          | Ports        | Impact of Attack                                |
| ------------------ | ------------ | ----------------------------------------------- |
| etcd               | 2379, 2380   | Break quorum, corrupt cluster state, block sync |
| API Server         | 6443, 8080   | Deny API calls from kubectl and controllers     |
| Scheduler          | 10251, 10259 | Prevent new pods from being scheduled           |
| Controller Manager | 10252, 10257 | Halt replica loops, scaling, and control tasks  |

> âš ï¸ _Warning_: Disrupting etcd or the API server can cause a **full cluster outage**. Always secure these ports.

---

## ðŸ”¥ Attack Vector 3: Disrupting Networking

Attackers can break internal and external communication by targeting key networking components.

| Component           | Ports        | Attack Effects                                   |
| ------------------- | ------------ | ------------------------------------------------ |
| kube-proxy          | 10256, 10249 | Freeze Service-to-Pod traffic                    |
| DNS                 | 53           | Block DNS resolution, causing service failures   |
| CNI Overlay Network | (varies)     | Flood overlays, slow or sever Pod-to-Pod traffic |
| PXE / Network Boot  | (varies)     | Prevent new nodes from joining the cluster       |

> _Visual_: Diagram showing attacker flooding kube-proxy, DNS, and CNI overlays to break traffic flow.

---

## ðŸ›¡ï¸ Mitigation Strategies

### 1ï¸âƒ£ ðŸ”¥ Firewall Configuration

- Limit API server ports (6443, 8080) to **trusted IPs** only
- Block unused Kubernetes ports at the perimeter
- Use cloud-native firewalls:
  - **AWS Security Groups**
  - **GCP Firewall Rules**

> _Tip_: Validate firewall rules regularly to avoid accidental lockouts.

---

### 2ï¸âƒ£ ðŸ§± Securing Nodes

- Patch host OS and Kubernetes components to the **latest stable versions**
- Apply **CIS Benchmarks** or node hardening guides
- Monitor runtime vulnerabilities with:
  - **Falco**
  - **Sysdig Secure**

> _Visual_: Flow from users â†’ NGINX â†’ Node.js â†’ MySQL, with hardened nodes underneath

---

### 3ï¸âƒ£ ðŸ” Network Policies

Use Kubernetes `NetworkPolicy` to control pod-level traffic:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: frontend
spec:
  podSelector: {}
  policyTypes:
    - Egress
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: backend
          podSelector: {}
```

> _Note_: Define both **Ingress** and **Egress** policies for full segmentation.

---

### 4ï¸âƒ£ ðŸ”’ Strong Authentication and Authorization

- Enforce **multi-factor authentication (MFA)** for:
  - API server
  - etcd
  - SSH access
- Use **RBAC** to grant least-privilege permissions
- Rotate service account tokens and certificates regularly

---

### 5ï¸âƒ£ ðŸ“ˆ Monitoring and Logging

Use **Prometheus + Alertmanager** to detect network anomalies:

```yaml
- alert: HighAPIRequests
  expr: sum(rate(apiserver_request_total[5m])) by (client) > 100
  labels:
    severity: warning
  annotations:
    summary: "High rate of API server requests detected"
    description: "Client {{ $labels.client }} exceeds 100 requests/sec."

- alert: HighNetworkTraffic
  expr: |
    sum(
      rate(container_network_receive_bytes_total[5m]) +
      rate(container_network_transmit_bytes_total[5m])
    ) by (pod) > 10000000
  for: 5m
  labels:
    severity: critical
  annotations:
    summary: "High network traffic detected"
    description: "Possible DoS or data exfiltration from pod {{ $labels.pod }}."
```

> _Tip_: Monitor for spikes in API calls and network traffic to catch attacks early.

---

## âœ… Final Checklist

- [x] Enforce strict firewall rules around control-plane ports
- [x] Keep nodes and cluster components up to date
- [x] Apply NetworkPolicy for granular traffic control
- [x] Use MFA and RBAC to secure API access
- [x] Monitor API calls and network metrics to detect and respond rapidly
