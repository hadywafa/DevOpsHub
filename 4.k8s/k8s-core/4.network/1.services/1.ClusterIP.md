# üåê **Kubernetes Services & Networking ‚Äì Core Concepts & ClusterIP**

## ‚ÅâÔ∏è **Why We Need Services**

Pods are **ephemeral**:

- Their IPs change whenever they restart.
- They can scale dynamically (1 ‚Üí 10 ‚Üí 0 replicas).
- They die and respawn frequently.

So how can other Pods, users, or applications **reliably connect** to them?

‚úÖ That‚Äôs why **Services** exist ‚Äî they provide a **stable virtual IP (ClusterIP)** and DNS name that always points to the **healthy Pods** behind it.

---

## üìñ **What is a Kubernetes Service?**

A **Service** is an abstraction that defines a **logical set of Pods** (usually matched by labels) and a policy to access them.

Think of it as:

> üè∑Ô∏è ‚ÄúPods with label `app=nginx` ‚Üí expose on port 80 ‚Üí stable IP and DNS.‚Äù

---

## ü§πüèª **Service Types Overview**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Type                  | Purpose                            | Accessible From | Example Use           |
| --------------------- | ---------------------------------- | --------------- | --------------------- |
| `ClusterIP` (default) | Internal-only access               | Inside cluster  | Backend microservices |
| `NodePort`            | Exposes service via node IP + port | Outside cluster | Testing/dev           |
| `LoadBalancer`        | Cloud-managed LB                   | Internet        | Public API endpoint   |
| `ExternalName`        | Maps to external DNS               | Cluster-only    | SaaS integrations     |

</div>

---

## üß± **Anatomy of a ClusterIP Service**

Let‚Äôs build a simple internal service that exposes a backend app.

### üß© Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: api
          image: nginx
          ports:
            - containerPort: 80
```

### üß© ClusterIP Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - port: 80
      targetPort: 80
  type: ClusterIP
```

Deploy:

```bash
kubectl apply -f backend.yaml
kubectl apply -f service.yaml
```

Check:

```bash
kubectl get svc
```

Output:

```ini
NAME              TYPE        CLUSTER-IP     PORT(S)   AGE
backend-service   ClusterIP   10.0.23.157    80/TCP    2m
```

---

## ‚öôÔ∏è **How ClusterIP Works Internally**

Here‚Äôs the magic üëá

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
---
config:
  theme: dark
  look: handDrawn
title: "2015 - Docker Donates to Create OCI"
---
flowchart LR
    B -->|ClusterIP=10.0.23.157| A
    A[Client Pod] -->|DNS Query| B[(CoreDNS)]
    A -->|HTTP 80| C[kube-proxy]
    C -->|iptables/IPVS| D["Pod 1 (10.244.1.10)"]
    C --> D2["Pod 2 (10.244.2.11)"]
    C --> D3["Pod 3 (10.244.3.12)"]
```

</div>

---

- **CoreDNS** resolves `backend-service.default.svc.cluster.local` to ClusterIP (10.0.23.157).
- **kube-proxy** (running on every node) intercepts connections to ClusterIP.
- It load-balances traffic to one of the backend Pods.

> ‚öôÔ∏è The load balancing is **round-robin** by default (via IPVS or iptables).

---

## üåê **Check DNS Resolution**

Run a test Pod:

```bash
kubectl run -it test --image=busybox --restart=Never -- sh
```

Then:

```bash
nslookup backend-service
curl backend-service
```

Output:

```ini
Server:    10.96.0.10
Name:      backend-service.default.svc.cluster.local
Address:   10.0.23.157
```

‚úÖ DNS resolves to ClusterIP successfully.

---

## üîç **Service Discovery in Kubernetes**

Each Service automatically gets:

- A **DNS entry**:
  `service-name.namespace.svc.cluster.local`
- A **ClusterIP** (virtual IP).
- A **port mapping** to containers.

Pods in the same namespace can reach each other by just `service-name`.
Pods in different namespaces use `service-name.namespace`.

Example:

```ini
curl backend-service.default
curl backend-service.dev
```

---

## üîê **TargetPort vs Port vs NodePort (explained visually)**

```yaml
ports:
  - name: http
    port: 80 # Service port (ClusterIP listener)
    targetPort: 8080 # Pod containerPort
    nodePort: 30080 # (optional for NodePort type)
```

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Field          | Description                                  |
| -------------- | -------------------------------------------- |
| **port**       | The port exposed by the Service              |
| **targetPort** | The port on the container                    |
| **nodePort**   | Port exposed on each node (if type=NodePort) |

</div>

---

## üß∞ **Verify Endpoint Bindings**

Check which Pods the service is sending traffic to:

```bash
kubectl get endpoints backend-service
```

Output:

```ini
NAME              ENDPOINTS                              AGE
backend-service   10.244.1.10:80,10.244.2.11:80,10.244.3.12:80   2m
```

> ‚úÖ These are the IPs of Pods matching the selector.

---

## üßæ **Troubleshooting ClusterIP**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Symptom                  | Likely Cause                   | Solution                                 |
| ------------------------ | ------------------------------ | ---------------------------------------- |
| `curl` times out         | No Endpoints registered        | Check labels on Pods vs Service selector |
| DNS fails                | CoreDNS issue                  | Restart CoreDNS Pod or check ConfigMap   |
| Only some Pods reachable | Pod readinessProbe failing     | Check `kubectl describe pod`             |
| Random Pod unreachable   | NetworkPolicy blocking traffic | Check `kubectl get netpol`               |

</div>

---

Debug tips:

```bash
kubectl get endpoints backend-service -o yaml
kubectl logs -n kube-system -l k8s-app=kube-proxy
kubectl logs -n kube-system -l k8s-app=coredns
```

---

## ‚úÖ **Best Practices for ClusterIP Services**

‚úÖ Always define **labels** and **selectors** clearly.  
‚úÖ Use **readinessProbes** to exclude unready Pods.  
‚úÖ Keep Service **names short and lowercase** (DNS-friendly).  
‚úÖ Avoid exposing unnecessary ports.  
‚úÖ Use **NetworkPolicies** for inter-service security.

---

## üèÅ **Summary**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept                 | Description                            |
| ----------------------- | -------------------------------------- |
| **ClusterIP**           | Internal-only service inside cluster   |
| **CoreDNS**             | Resolves service names to ClusterIP    |
| **kube-proxy**          | Routes packets to correct Pod          |
| **Endpoints**           | Dynamic list of Pod IPs behind Service |
| **Namespace isolation** | Service names scoped by namespace      |

</div>
