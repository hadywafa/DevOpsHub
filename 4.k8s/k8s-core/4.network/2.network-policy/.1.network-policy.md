# üëÆüèª **Kubernetes Network Policies ‚Äî Securing Pod-to-Pod Communication**

> _Network Policies act like a cluster-level firewall, defining who can talk to whom ‚Äî and on which ports._

---

## üìñ **What Is a Network Policy?**

A **NetworkPolicy** is a Kubernetes resource that defines **rules controlling ingress (incoming)** and **egress (outgoing)** traffic for Pods.

By default:

> üîì All Pods can talk to all other Pods and external endpoints.

Once you create a NetworkPolicy for a Pod:

> üîí The default changes ‚Äî **everything not explicitly allowed is denied.**

---

## üéØ **When Are Network Policies Enforced?**

A policy **does nothing** unless your cluster uses a **CNI (Container Network Interface)** plugin that supports them, such as:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| CNI Plugin    | NetworkPolicy Support |
| ------------- | --------------------- |
| **Calico**    | ‚úÖ Full               |
| **Cilium**    | ‚úÖ Full (L7-aware)    |
| **Weave Net** | ‚úÖ Partial            |
| **Flannel**   | ‚ùå No (needs add-ons) |

</div>

---

üëâ Always check:

```bash
kubectl get pods -n kube-system
```

If you see something like `calico-node` or `cilium-agent`, you‚Äôre good.

---

## üß© **Network Policy Structure**

Here‚Äôs the structure of a typical NetworkPolicy:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
    - Ingress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
      ports:
        - protocol: TCP
          port: 80
```

### üîç Breakdown

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Field                | Meaning                                                   |
| -------------------- | --------------------------------------------------------- |
| **podSelector**      | Which Pods this policy applies to                         |
| **policyTypes**      | Type of traffic controlled (`Ingress`, `Egress`, or both) |
| **ingress / egress** | Rules for allowed connections                             |
| **from / to**        | Who is allowed to connect (Pods, Namespaces, IPs)         |

</div>

---

## üîê **Default Behavior**

- Without any policy ‚Üí all traffic allowed
- With one policy (Ingress) ‚Üí only allowed Ingress traffic passes; Egress is open
- With both ‚Üí both directions restricted

Example timeline:

1. No policies ‚Üí all open
2. Add one Ingress policy ‚Üí only whitelisted inbound allowed
3. Add Egress policy ‚Üí outbound also restricted

---

## üí≠ **Common Examples**

### 1Ô∏è‚É£ Allow traffic from one app to another

```yaml
spec:
  podSelector:
    matchLabels:
      app: backend
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
```

‚úÖ Only Pods labeled `app=frontend` can reach `app=backend`.

---

### 2Ô∏è‚É£ Allow namespace-level access

```yaml
spec:
  podSelector:
    matchLabels:
      role: database
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              env: prod
```

‚úÖ All Pods in namespaces labeled `env=prod` can access these Pods.

---

### 3Ô∏è‚É£ Allow external CIDR range (like a monitoring agent)

```yaml
spec:
  ingress:
    - from:
        - ipBlock:
            cidr: 10.0.0.0/16
            except:
              - 10.0.5.0/24
```

‚úÖ Allows access from all IPs in `10.0.0.0/16`, except those in `10.0.5.0/24`.

---

### 4Ô∏è‚É£ Allow outgoing (Egress) DNS + API traffic

```yaml
spec:
  podSelector:
    matchLabels:
      app: web
  policyTypes:
    - Egress
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
      ports:
        - protocol: TCP
          port: 443
```

‚úÖ Web Pods can only talk to:

- DNS (`UDP 53`)
- External HTTPS endpoints

---

## üß™ **Testing Network Policies**

You can use `kubectl exec` to verify connections:

```bash
# From frontend pod, test backend access
kubectl exec -it frontend-pod -- curl -s backend:80
```

If the policy blocks it, you‚Äôll see:

```ini
curl: (7) Failed to connect to backend port 80: Connection timed out
```

---

## üßëüèª‚Äçüíª **Useful Admin Commands**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Command                                 | Description                          |
| --------------------------------------- | ------------------------------------ |
| `kubectl get networkpolicy -A`          | List all policies                    |
| `kubectl describe networkpolicy <name>` | Inspect one                          |
| `kubectl delete networkpolicy <name>`   | Remove a policy                      |
| `kubectl edit networkpolicy <name>`     | Modify live                          |
| `kubectl get pods --show-labels`        | Check labels (critical for matching) |

</div>

---

## ‚úçüèª **Real-World Example (Full Setup)**

### Scenario:

You have three Pods:

- **frontend**
- **backend**
- **database**

Goal:

- Frontend ‚Üí Backend ‚úÖ
- Backend ‚Üí Database ‚úÖ
- Frontend ‚ùå Database

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-to-backend
spec:
  podSelector:
    matchLabels:
      app: backend
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-to-database
spec:
  podSelector:
    matchLabels:
      app: database
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: backend
```

‚úÖ This enforces a ‚Äúchain‚Äù of communication ‚Äî only specific hops are allowed.

---

## üî¥ **Advanced: Combine with Namespaces**

Add labels to namespaces:

```bash
kubectl label namespace dev env=dev
kubectl label namespace prod env=prod
```

Then restrict by namespace:

```yaml
ingress:
  - from:
      - namespaceSelector:
          matchLabels:
            env: dev
```

‚úÖ Now only Pods from the `dev` namespace can talk to this Pod.

---

## ‚úÖ **Best Practices**

- ‚úÖ **Label Everything:** Pod and Namespace labels are the foundation of policies.
- ‚úÖ **Start Permissive, Then Restrict:** Begin with broad rules and tighten over time.
- ‚úÖ **Test with `curl` or `netcat`:** Always verify.
- ‚úÖ **Combine with RBAC:** Protect who can modify policies.
- ‚úÖ **Use Calico or Cilium:** Full enforcement and better visibility.
- ‚úÖ **Version Control Policies:** Keep YAMLs in Git for traceability.

---

## üß∞ **Debugging Network Policies**

When debugging blocked traffic:

1. **Check matching labels**

   ```bash
   kubectl get pod <pod> --show-labels
   ```

   If labels don‚Äôt match, the policy won‚Äôt apply.

2. **Describe the policy**

   ```bash
   kubectl describe networkpolicy mypolicy
   ```

3. **Check CNI plugin logs**

   ```bash
   kubectl logs -n kube-system <cni-pod>
   ```

4. **Use `netshoot` pod** (a debug pod with networking tools)

   ```bash
   kubectl run netshoot --rm -it --image=nicolaka/netshoot -- bash
   ```

---

## üßπ **Cleanup**

To remove a policy:

```bash
kubectl delete networkpolicy allow-frontend-to-backend
```

Traffic becomes **open again** for affected Pods.

---

## üèÅ **Summary**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept                 | Description                                     |
| ----------------------- | ----------------------------------------------- |
| **NetworkPolicy**       | Defines Pod-level firewall rules                |
| **Ingress Rules**       | Control incoming traffic                        |
| **Egress Rules**        | Control outgoing traffic                        |
| **Selectors**           | Match Pods, Namespaces, or IPs                  |
| **Default Behavior**    | All open ‚Üí restricted only after policies exist |
| **Requires CNI Plugin** | Must support NetworkPolicy                      |

</div>

---

## üß† Next Topics (You Can Dive Deeper Into)

If you want to continue strengthening your networking admin skills:

1. **Cilium Network Policies** (L7-aware, DNS-based rules)
2. **Calico NetworkPolicy vs GlobalNetworkPolicy**
3. **Egress Gateway / Egress Proxy**
4. **Network Policy Logging & Visibility**
