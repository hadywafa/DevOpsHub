# ‚öôÔ∏è **NGINX Ingress Controller ‚Äî Installation & Administration Guide**

> _The most popular and production-proven Ingress Controller for Kubernetes._

---

## üìñ **What Is the NGINX Ingress Controller?**

**NGINX Ingress Controller** is the engine that **implements** the rules defined in your `Ingress` resources.

When a request hits your cluster:

1. Kubernetes API provides the Ingress rules (host/path/TLS).
2. The NGINX Ingress Controller dynamically **reconfigures an internal NGINX reverse proxy**.
3. Requests are **load-balanced** to the correct backend Services.

---

## üß© **Core Components Installed**

When you deploy NGINX Ingress, it usually installs the following in the `ingress-nginx` namespace:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Component                                   | Purpose                                             |
| ------------------------------------------- | --------------------------------------------------- |
| **Deployment** (`ingress-nginx-controller`) | Runs NGINX as a reverse proxy                       |
| **Service (LoadBalancer)**                  | Exposes the controller to the Internet              |
| **ConfigMap**                               | Stores NGINX-level tuning options                   |
| **ServiceAccount / RBAC**                   | Grants permission to read Ingress objects           |
| **IngressClass**                            | Identifies which Ingress resources it should manage |

</div>

---

## ‚öôÔ∏è **Installation (Two Common Methods)**

### üß≠ Option 1 ‚Äî Official YAML (Cloud-Ready)

```bash
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
```

‚úÖ This method:

- Works in any managed Kubernetes cluster (EKS, AKS, GKE)
- Automatically creates a LoadBalancer Service
- Registers the IngressClass `nginx`

Check status:

```bash
kubectl get pods -n ingress-nginx
kubectl get svc -n ingress-nginx
```

You‚Äôll see something like:

```ini
NAME                                       READY   STATUS
ingress-nginx-controller-b7f99ddc8-nntrr   1/1     Running

NAME                       TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)
ingress-nginx-controller   LoadBalancer   10.0.25.97      52.14.90.101      80:32458/TCP,443:31843/TCP
```

That external IP is your **Ingress entry point**.

---

### üß≠ Option 2 ‚Äî Helm Chart (Recommended for Production)

```bash
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

helm install nginx-ingress ingress-nginx/ingress-nginx \
  --namespace ingress-nginx --create-namespace
```

Confirm:

```bash
kubectl get ingressclass
```

Output:

```ini
NAME      CONTROLLER
nginx     k8s.io/ingress-nginx
```

---

## üß© **Verifying the Deployment**

Check Pods and Service:

```bash
kubectl get all -n ingress-nginx
```

Test with a dummy Ingress:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress
spec:
  ingressClassName: nginx
  rules:
    - host: test.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp-svc
                port:
                  number: 80
```

Apply:

```bash
kubectl apply -f test-ingress.yaml
```

---

## ‚öôÔ∏è **Configuration (via ConfigMap)**

All global NGINX options are controlled by a ConfigMap, typically named `nginx-configuration`.

Example:

```bash
kubectl get configmap -n ingress-nginx nginx-configuration -o yaml
```

You can modify defaults like:

```yaml
data:
  proxy-body-size: "50m"
  proxy-connect-timeout: "10"
  proxy-read-timeout: "30"
  use-forwarded-headers: "true"
```

Apply changes:

```bash
kubectl apply -f nginx-config.yaml
kubectl rollout restart deployment ingress-nginx-controller -n ingress-nginx
```

---

## üéØ **Common Annotations for NGINX Ingress**

These override ConfigMap defaults at the per-Ingress level.

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Annotation                                           | Description               |
| ---------------------------------------------------- | ------------------------- |
| `nginx.ingress.kubernetes.io/rewrite-target`         | Rewrite incoming URL path |
| `nginx.ingress.kubernetes.io/ssl-redirect`           | Force HTTPS               |
| `nginx.ingress.kubernetes.io/proxy-body-size`        | Max upload size           |
| `nginx.ingress.kubernetes.io/limit-rps`              | Limit requests per second |
| `nginx.ingress.kubernetes.io/whitelist-source-range` | Restrict source IPs       |
| `nginx.ingress.kubernetes.io/auth-type: basic`       | Enable basic auth         |

</div>

---

Example:

```yaml
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
```

---

## üß™ **Canary & A/B Deployments**

You can do weighted routing using annotations ‚Äî no Service Mesh needed!

```yaml
metadata:
  name: app-stable
  annotations:
    nginx.ingress.kubernetes.io/canary: "true"
    nginx.ingress.kubernetes.io/canary-weight: "20"
```

> ‚úÖ This means: send **20%** of the traffic to this version, and **80%** to the default one.

---

## üîê **TLS & HTTPS Management**

You can use a Kubernetes Secret to terminate SSL directly in the controller:

```yaml
tls:
  - hosts:
      - secure.example.com
    secretName: tls-secret
```

You can combine it with Cert-Manager for auto-renewing Let‚Äôs Encrypt certificates.

---

## ‚öôÔ∏è **Advanced Features**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature                       | Description                             |
| ----------------------------- | --------------------------------------- |
| **Rewrite & Redirects**       | Modify URLs dynamically                 |
| **Rate Limiting**             | Control RPS (Requests per Second)       |
| **Custom Error Pages**        | Serve branded 404/500 pages             |
| **Load Balancing Algorithms** | Round Robin, Least Connections, IP Hash |
| **CORS Headers**              | Enable cross-origin requests            |
| **Access Logs & Metrics**     | Export via Prometheus or JSON logs      |

</div>

---

## ‚ù§Ô∏è‚Äçü©π **Health & Debug Commands**

Check Ingress config:

```bash
kubectl exec -it deploy/ingress-nginx-controller -n ingress-nginx -- cat /etc/nginx/nginx.conf
```

Check controller logs:

```bash
kubectl logs -n ingress-nginx deploy/ingress-nginx-controller
```

Verify which Ingress rules are active:

```bash
kubectl get ingress -A
```

---

## üî¥ **Troubleshooting Common Issues**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Issue                       | Likely Cause                    | Fix                                       |
| --------------------------- | ------------------------------- | ----------------------------------------- |
| `EXTERNAL-IP` = `<pending>` | No cloud load balancer          | Use MetalLB or install on supported cloud |
| 404 response                | Rule mismatch                   | Check `kubectl describe ingress`          |
| TLS not working             | Wrong secret or domain          | Verify secret and host name               |
| High latency                | Misconfigured probes / timeouts | Tune `proxy-read-timeout`                 |
| Controller crashlooping     | Invalid ConfigMap key           | `kubectl describe pod` for reason         |

</div>

---

## ‚öôÔ∏è **Rollout Management**

When updating ConfigMaps or Secrets:

```bash
kubectl rollout restart deployment ingress-nginx-controller -n ingress-nginx
```

Monitor rollout:

```bash
kubectl rollout status deployment ingress-nginx-controller -n ingress-nginx
```

---

## üìú **NGINX IngressClass Resource**

Each NGINX installation registers its own IngressClass:

```yaml
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: nginx
spec:
  controller: k8s.io/ingress-nginx
```

If you install multiple controllers (like Traefik + NGINX), this tells Kubernetes **which controller** owns which Ingress objects.

---

## ‚úÖ **Best Practices**

- ‚úÖ Use **Helm** for easy upgrades and rollback.
- ‚úÖ Manage sensitive values (like auth credentials) via **Secrets**.
- ‚úÖ Limit Ingress scope per namespace via RBAC.
- ‚úÖ Enable **Access Logs + Prometheus Metrics** for observability.
- ‚úÖ Always define `ingressClassName` to avoid ambiguity.
- ‚úÖ Combine with **Cert-Manager** for auto HTTPS.
