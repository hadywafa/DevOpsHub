# 🌐 Kubernetes Pods — **Networking** (**at Pod Level**)

> 🎯 **Goal:** Understand how Pods communicate (internally and externally), with real commands, troubleshooting flows, and admin tips.

---

## 📖 **Networking** 101 — The Kubernetes Model

Kubernetes uses a **flat network model**:

- Every **Pod gets its own IP address**.
- All Pods can communicate **without NAT**.
- Containers inside a Pod share the **same network namespace**.

**Key Principles:**

1️⃣ **Container-to-Container** — within same Pod  
2️⃣ **Pod-to-Pod** — same or different nodes  
3️⃣ **Pod-to-Service** — internal stable access

---

## 1️⃣ **Container-to-Container Communication**

Inside a single Pod, containers share:

- The same **network interface (eth0)**
- The same **IP address**
- The same **localhost**

Example:

```bash
# In container A
curl localhost:8080
```

✅ Reaches container B inside the same Pod if it’s listening on port 8080.

---

## 2️⃣ **Pod-to-Pod Communication**

Each Pod gets an IP from the cluster’s **CNI (Container Network Interface)** plugin — such as:

- **Calico**
- **Flannel**
- **Cilium**
- **Weave**

Example:

```bash
kubectl exec -it <test-pod> -- ping <P-O-D-I-P.default.pod>
```

✅ Works across nodes if CNI is properly configured.

**🧰 Admin Tip:**

To view Pod IPs:

```bash
kubectl get pods -o wide
```

If Pods on different nodes **can’t reach** each other:

- Check CNI pods in `kube-system` namespace

  ```bash
  kubectl get pods -n kube-system
  ```

- Inspect network plugin logs

  ```bash
  kubectl logs -n kube-system <cni-pod-name>
  ```

---

## 3️⃣ **Pod-to-Service Communication**

Services provide **stable DNS names** and **virtual IPs** (ClusterIP).
Pods access other Pods **via Service name** instead of IP.

Example:

```bash
curl http://nginx.default.svc.cluster.local
```

DNS structure:

```ini
<service>.<namespace>.svc.cluster.local
```

**🧪 Check Cluster DNS:**

```bash
kubectl exec -it <pod> -- nslookup kubernetes.default
# kubernetes.default -> DNS name of the Kubernetes API server
```

If DNS fails:

- Check CoreDNS pods:

  ```bash
  kubectl get pods -n kube-system -l k8s-app=kube-dns
  ```

- Restart if needed:

  ```bash
  kubectl delete pod -n kube-system -l k8s-app=kube-dns
  ```

---

## 🔌 **Exposing Pod Ports**

Expose port manually:

```bash
kubectl expose pod mypod --port=80 --target-port=8080 --name=mypod-svc
```

View service:

```bash
kubectl get svc mypod-svc
```

---

## 🧑🏻‍💻 **Pod Networking Commands Summary**

| Task                   | Command                                                 |
| ---------------------- | ------------------------------------------------------- |
| View Pod IPs           | `kubectl get pods -o wide`                              |
| Ping another pod       | `kubectl exec -it <pod> -- ping <pod-ip>`               |
| Test DNS               | `kubectl exec -it <pod> -- nslookup kubernetes.default` |
| Get service cluster IP | `kubectl get svc`                                       |
| Curl service           | `kubectl exec -it <pod> -- curl <svc-name>`             |

---

## 🧰 **Admin Networking Troubleshooting**

### 🔍 Check Network Policies

If Pods cannot reach each other:

```bash
kubectl get networkpolicy -A
```

Temporarily delete policy for debugging:

```bash
kubectl delete networkpolicy <policy>
```

---

### 🔍 Verify IP Tables Rules

```bash
iptables -t nat -L -n | grep KUBE
```

Look for `KUBE-SERVICES` and `KUBE-POSTROUTING`.

---

### 🔍 Debug Pod Network

Use **busybox** or **netshoot** Pod:

```bash
kubectl run netshoot --image=nicolaka/netshoot -it -- bash
```

Then run:

```bash
ping <pod-ip>
curl <svc-name>
traceroute <pod-ip>
```
