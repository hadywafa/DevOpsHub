# ğŸŒ Kubernetes Pods â€” **Networking** (**at Pod Level**)

> ğŸ¯ **Goal:** Understand how Pods communicate (internally and externally), with real commands, troubleshooting flows, and admin tips.

---

## ğŸ“– **Networking** 101 â€” The Kubernetes Model

Kubernetes uses a **flat network model**:

- Every **Pod gets its own IP address**.
- All Pods can communicate **without NAT**.
- Containers inside a Pod share the **same network namespace**.

**Key Principles:**

1ï¸âƒ£ **Container-to-Container** â€” within same Pod  
2ï¸âƒ£ **Pod-to-Pod** â€” same or different nodes  
3ï¸âƒ£ **Pod-to-Service** â€” internal stable access

---

## 1ï¸âƒ£ **Container-to-Container Communication**

Inside a single Pod, containers share:

- The same **network interface (eth0)**
- The same **IP address**
- The same **localhost**

Example:

```bash
# In container A
curl localhost:8080
```

âœ… Reaches container B inside the same Pod if itâ€™s listening on port 8080.

---

## 2ï¸âƒ£ **Pod-to-Pod Communication**

Each Pod gets an IP from the clusterâ€™s **CNI (Container Network Interface)** plugin â€” such as:

- **Calico**
- **Flannel**
- **Cilium**
- **Weave**

Example:

```bash
kubectl exec -it <test-pod> -- ping <P-O-D-I-P.default.pod>
```

âœ… Works across nodes if CNI is properly configured.

**ğŸ§° Admin Tip:**

To view Pod IPs:

```bash
kubectl get pods -o wide
```

If Pods on different nodes **canâ€™t reach** each other:

- Check CNI pods in `kube-system` namespace

  ```bash
  kubectl get pods -n kube-system
  ```

- Inspect network plugin logs

  ```bash
  kubectl logs -n kube-system <cni-pod-name>
  ```

---

## 3ï¸âƒ£ **Pod-to-Service Communication**

Services provide **stable DNS names** and **virtual IPs** (ClusterIP).
Pods access other Pods **via Service name** instead of IP.

Example:

```bash
curl http://nginx.default.svc.cluster.local
```

DNS structure:

```ini
<service>.<namespace>.svc.cluster.local
```

**ğŸ§ª Check Cluster DNS:**

```bash
kubectl exec -it <pod> -- nslookup kubernetes.default
# kubernetes.default -> DNS name of the Kubernetes API server
```

If DNS fails:

- Check CoreDNS pods:

  ```bash
  kubectl get pods -n kube-system -l k8s-app=kube-dns
  ```

- Restart if needed:

  ```bash
  kubectl delete pod -n kube-system -l k8s-app=kube-dns
  ```

---

## ğŸ”Œ **Exposing Pod Ports**

Expose port manually:

```bash
kubectl expose pod mypod --port=80 --target-port=8080 --name=mypod-svc
```

View service:

```bash
kubectl get svc mypod-svc
```

---

## ğŸ§‘ğŸ»â€ğŸ’» **Pod Networking Commands Summary**

| Task                   | Command                                                 |
| ---------------------- | ------------------------------------------------------- |
| View Pod IPs           | `kubectl get pods -o wide`                              |
| Ping another pod       | `kubectl exec -it <pod> -- ping <pod-ip>`               |
| Test DNS               | `kubectl exec -it <pod> -- nslookup kubernetes.default` |
| Get service cluster IP | `kubectl get svc`                                       |
| Curl service           | `kubectl exec -it <pod> -- curl <svc-name>`             |

---

## ğŸ§° **Admin Networking Troubleshooting**

### ğŸ” Check Network Policies

If Pods cannot reach each other:

```bash
kubectl get networkpolicy -A
```

Temporarily delete policy for debugging:

```bash
kubectl delete networkpolicy <policy>
```

---

### ğŸ” Verify IP Tables Rules

```bash
iptables -t nat -L -n | grep KUBE
```

Look for `KUBE-SERVICES` and `KUBE-POSTROUTING`.

---

### ğŸ” Debug Pod Network

Use **busybox** or **netshoot** Pod:

```bash
kubectl run netshoot --image=nicolaka/netshoot -it -- bash
```

Then run:

```bash
ping <pod-ip>
curl <svc-name>
traceroute <pod-ip>
```
