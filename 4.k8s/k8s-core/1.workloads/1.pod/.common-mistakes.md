# 🧪 Kubernetes Pod YAML — Common Container Definition Mistakes (Wrong ❌ vs Correct ✅)

## 📌 1. Using `:latest` (or no tag)

**Symptom:** unpredictable upgrades; “worked yesterday, broken today”.

```yaml
# ❌ Wrong
containers:
  - name: api
    image: mycorp/api
```

```yaml
# ✅ Correct
containers:
  - name: api
    image: mycorp/api:1.12.3
```

---

## 📌 2. No resource requests/limits

**Symptom:** noisy neighbors; eviction under pressure; HPA can’t scale properly.

```yaml
# ❌ Wrong
containers:
  - name: api
    image: mycorp/api:1.12.3
```

```yaml
# ✅ Correct
containers:
  - name: api
    image: mycorp/api:1.12.3
    resources:
      requests: { cpu: "200m", memory: "256Mi" }
      limits: { cpu: "500m", memory: "512Mi" }
```

---

## 📌 3. Misusing probes (or missing them)

**Symptom:** pods “Running” but dead; or constant restarts due to overly strict probes.

```yaml
# ❌ Wrong
livenessProbe:
  httpGet: { path: /health, port: 8080 }
  initialDelaySeconds: 0 # app isn’t ready yet
  periodSeconds: 5
```

```yaml
# ✅ Correct
startupProbe: # for slow-start apps
  httpGet: { path: /healthz/startup, port: 8080 }
  failureThreshold: 30
  periodSeconds: 5
livenessProbe:
  httpGet: { path: /healthz/live, port: 8080 }
  initialDelaySeconds: 10
readinessProbe:
  httpGet: { path: /healthz/ready, port: 8080 }
  initialDelaySeconds: 5
```

---

## 📌 4. Confusing `command` and `args`

K8s maps to Docker **ENTRYPOINT = command**, **CMD = args**.
**Symptom:** container exits immediately or runs the wrong thing.

```yaml
# ❌ Wrong (string, replaces shell; args ignored)
command: ["python app.py --port 8080"]
```

```yaml
# ✅ Correct (arrays, split arguments)
command: ["python", "app.py"] # ENTRYPOINT
args: ["--port", "8080"] # CMD
```

---

## 📌 5. Wrong port wiring (mismatch with Service)

**Symptom:** Service shows endpoints, but traffic fails.

```yaml
# ❌ Wrong
containers:
  - name: api
    ports:
      - containerPort: 8080
# Service points to 80 → no match
```

```yaml
# ✅ Correct
containers:
  - name: api
    ports:
      - name: http
        containerPort: 8080
# Service -> targetPort: http (or 8080)
```

---

## 📌 6. Not mounting ConfigMaps/Secrets correctly

**Symptom:** app can’t find config; CrashLoopBackOff due to missing keys.

```yaml
# ❌ Wrong (typo in key name; single env var expected)
env:
  - name: DB_HOST
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: databse_host
```

```yaml
# ✅ Correct
env:
  - name: DB_HOST
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: database_host
# or mount entire map:
envFrom:
  - configMapRef: { name: app-config }
  - secretRef: { name: db-secret }
```

---

## 📌 7. Volumes and mounts don’t match

**Symptom:** pod fails to start: “volume not found”.

```yaml
# ❌ Wrong
volumeMounts:
  - name: files
    mountPath: /data
# volumes section missing or name mismatch
```

```yaml
# ✅ Correct
volumeMounts:
  - name: files
    mountPath: /data
volumes:
  - name: files
    emptyDir: {}
```

---

## 📌 8. Running as root (no security hardening)

**Symptom:** security reviews fail; higher blast radius.

```yaml
# ❌ Wrong
securityContext: {}
```

```yaml
# ✅ Correct
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
```

---

## 📌 9. Bad quantity units / invalid requests vs limits

**Symptom:** validation errors; scheduler rejects Pod.

```yaml
# ❌ Wrong
resources:
  requests: { cpu: "1", memory: "512M" } # “M” not valid
  limits: { cpu: "500m", memory: "256Mi" } # limit < request (CPU ok; mem wrong)
```

```yaml
# ✅ Correct
resources:
  requests: { cpu: "500m", memory: "256Mi" }
  limits: { cpu: "1", memory: "512Mi" }
```

---

## 📌 10. Forgetting imagePullSecrets / private registries

**Symptom:** `ImagePullBackOff`.

```yaml
# ❌ Wrong
image: private.registry.local/my/api:1.2.0
```

```yaml
# ✅ Correct
image: private.registry.local/my/api:1.2.0
imagePullSecrets:
  - name: regcred
```

---

## 📌 11. Depending on `imagePullPolicy: Always` by accident

**Symptom:** slow deploys; rate-limits from registry.

```yaml
# ❌ Wrong (with :latest)
image: mycorp/api:latest # default policy becomes Always
```

```yaml
# ✅ Correct
image: mycorp/api:1.12.3 # default policy IfNotPresent
# or explicitly:
imagePullPolicy: IfNotPresent
```

---

## 📌 12. No graceful shutdown hooks / short termination grace

**Symptom:** in-flight requests dropped on rollout.

```yaml
# ❌ Wrong
terminationGracePeriodSeconds: 5
```

```yaml
# ✅ Correct
lifecycle:
  preStop:
    exec:
      command: ["sh", "-c", "sleep 10"] # drain/close listeners
terminationGracePeriodSeconds: 30
```

---

## 📌 13. Using `hostPath` casually

**Symptom:** coupling to a specific node; permission issues.

```yaml
# ❌ Wrong
volumes:
  - name: data
    hostPath:
      path: /var/lib/myapp
```

```yaml
# ✅ Correct (prefer portable volumes)
volumes:
  - name: data
    emptyDir: {}
# or a PVC (recommended in real apps)
```

---

## 📌 14. Missing labels (breaks selectors and Ops hygiene)

**Symptom:** Services/NetworkPolicies don’t select your Pods.

```yaml
# ❌ Wrong
metadata: { name: api }
```

```yaml
# ✅ Correct
metadata:
  name: api
  labels:
    app: api
spec:
  containers:
    - name: api
      # ...
# Service/NP use selector: { app: api }
```

---

## 📌 15. Command as one string (shell parsing surprises)

**Symptom:** quoting/space bugs.

```yaml
# ❌ Wrong
command: ["sh -c 'myapp --flag=1'"]
```

```yaml
# ✅ Correct
command: ["sh", "-c", "myapp --flag=1"]
# or avoid shell entirely:
command: ["myapp"]
args: ["--flag", "1"]
```

---

## 📌 16. Wrong probe scheme/path/port

**Symptom:** constant restarts or never-ready.

```yaml
# ❌ Wrong
livenessProbe:
  httpGet: { path: /health, port: 8443 } # but app serves HTTPS
```

```yaml
# ✅ Correct
livenessProbe:
  httpGet:
    scheme: HTTPS
    path: /health
    port: 8443
```

---

## 📌 Final Mini-Template (safe defaults)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: api
  labels: { app: api }
spec:
  terminationGracePeriodSeconds: 30
  containers:
    - name: api
      image: mycorp/api:1.12.3
      ports:
        - name: http
          containerPort: 8080
      command: ["myapp"] # ENTRYPOINT
      args: ["--port", "8080"] # CMD
      resources:
        requests: { cpu: "200m", memory: "256Mi" }
        limits: { cpu: "500m", memory: "512Mi" }
      envFrom:
        - configMapRef: { name: app-config }
        - secretRef: { name: db-secret }
      readinessProbe:
        httpGet: { path: /healthz/ready, port: http }
        initialDelaySeconds: 5
      livenessProbe:
        httpGet: { path: /healthz/live, port: http }
        initialDelaySeconds: 10
      startupProbe:
        httpGet: { path: /healthz/startup, port: http }
        failureThreshold: 30
        periodSeconds: 5
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
  imagePullSecrets:
    - name: regcred
```
