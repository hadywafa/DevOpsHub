# ğŸ¯ **Kubernetes LimitRange â€” Simple, Clear, and 100% CKS-Friendly**

## ğŸ“– **What is a LimitRange?**

A **LimitRange** is a Kubernetes policy **inside a namespace** that defines:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| What it Controls      | Meaning                                                      |
| --------------------- | ------------------------------------------------------------ |
| **Minimum resources** | Pod/Container must request at least X CPU/memory             |
| **Maximum resources** | Pod/Container cannot request more than Y CPU/memory          |
| **Default request**   | If user does not specify requests, assign automatic defaults |
| **Default limit**     | If user does not specify limits, assign automatic defaults   |
| **Max/Min ratio**     | To ensure limits are not too much higher than requests       |

</div>

- âœ” Ensures Pods do not consume excessive resources
- âœ” Ensures Pods **have requests**, so the scheduler can place them
- âœ” Often used together with **ResourceQuota**

---

## â“ **Why Do We Need LimitRange?**

**Problem without LimitRange:**

- Developers can deploy containers with _no_ CPU/memory requests
- Or with _huge_ limits (like 20 CPU!)
- Scheduler cannot handle pods without resource requests
- One bad pod can starve the node

**Solution â†’ LimitRange**
Kubernetes assigns automatic sane defaults and enforces limits.

---

## ğŸ“ **LimitRange Applies To**

LimitRange can apply to:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Type                          | Applies To                     |
| ----------------------------- | ------------------------------ |
| `type: Container`             | CPU/mem defaults per container |
| `type: Pod`                   | Total pod-level limits         |
| `type: PersistentVolumeClaim` | Min/Max storage limits         |

</div>

---

## ğŸ“ **LimitRange Example (Most Common)**

### ğŸŸ¦ **limit-range.yaml**

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: default-limits
  namespace: dev
spec:
  limits:
    - type: Container
      default:
        cpu: "500m"
        memory: "512Mi"
      defaultRequest:
        cpu: "200m"
        memory: "256Mi"
      max:
        cpu: "1"
        memory: "1Gi"
      min:
        cpu: "100m"
        memory: "128Mi"
```

---

### ğŸ’¬ **What Does This LimitRange Do?**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Rule               | Meaning                                                        |
| ------------------ | -------------------------------------------------------------- |
| **default**        | If user does NOT set limits â†’ assign 500m CPU / 512Mi memory   |
| **defaultRequest** | If user does NOT set requests â†’ assign 200m CPU / 256Mi memory |
| **max**            | Container limit cannot exceed 1 CPU / 1Gi                      |
| **min**            | Container must request at least 100m CPU / 128Mi memory        |

</div>

---

## ğŸ§ª **Hands-On Testing**

### ğŸ”¹ **Step 1 â€” Create namespace**

```bash
kubectl create ns dev
```

---

### ğŸ”¹ **Step 2 â€” Apply the LimitRange**

```bash
kubectl apply -f limit-range.yaml
```

---

### ğŸ”¹ **Step 3 â€” Create a pod with no requests and no limits**

```bash
kubectl run test --image=nginx -n dev
```

---

### ğŸ”¹ **Step 4 â€” Check the pod spec**

Kubernetes automatically adds defaults:

```bash
kubectl get pod test -n dev -o yaml | grep -A5 resources
```

Output:

```yaml
resources:
  limits:
    cpu: "500m"
    memory: "512Mi"
  requests:
    cpu: "200m"
    memory: "256Mi"
```

ğŸ’¡ **This is LimitRange injecting default requests/limits!**

---

## â›” **If You Violate the LimitRange**

### ğŸ“ Example 1 â€” Request too little

```bash
kubectl run tiny --image=nginx -n dev --requests="cpu=50m"
```

You get:

```ini
pods "tiny" is forbidden: minimum cpu usage per Container is 100m
```

---

### ğŸ“ Example 2 â€” Limit too big

```bash
kubectl run big --image=nginx -n dev --limits="cpu=2"
```

Error:

```ini
exceeded quota: limit is above maximum allowed 1 CPU
```

---

## ğŸ§© **LimitRange vs ResourceQuota**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature          | LimitRange                      | ResourceQuota                   |
| ---------------- | ------------------------------- | ------------------------------- |
| Applies to       | Namespace                       | Namespace                       |
| Controls         | Defaults + min/max              | Total usage                     |
| Scope            | Per container                   | Per namespace                   |
| Prevents         | Oversized/undersized containers | Too many pods/storage/cpu       |
| Works with       | All Pods                        | Only when requests/limits exist |
| Must be present? | Recommended                     | Required for quota enforcement  |

</div>

**They are designed to work together.**

---

## ğŸ“˜ **Example with Both (Best Practice)**

### resourcequota.yaml

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "2"
    requests.memory: "4Gi"
    limits.cpu: "4"
    limits.memory: "8Gi"
```

### limitrange.yaml

(From earlier example)

Together they enforce:

- default values for each pod
- total allowed capacity

---

## ğŸª„ **LimitRange for PVCs (Very Important for Storage)**

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: pvc-limit
  namespace: dev
spec:
  limits:
    - type: PersistentVolumeClaim
      max:
        storage: 100Gi
      min:
        storage: 1Gi
```

This forces:

- PVC cannot be more than 100Gi
- PVC cannot be less than 1Gi

---

## ğŸ—‚ï¸ **How to View Active LimitRanges**

```bash
kubectl get limitrange -n dev
kubectl describe limitrange default-limits -n dev
```

---

## ğŸ“ **CKS Important Notes**

ğŸ”¥ **Most common CKS exam task:**

> A Pod keeps getting rejected because of LimitRange â€“ fix it.

You do this by:

- Increasing LimitRange max/min
  or
- Adjusting Podâ€™s resources

ğŸ”¥ Another common task:

> ResourceQuota refuses pods because requests were missing â†’ add LimitRange to auto-set defaults.

ğŸ”¥ Another scenario:

> LimitRange blocks huge memory limits to avoid node crashes.

---

## ğŸ **Summary**

- LimitRange applies **per namespace**
- It sets **default request/limit**, **min/max**, and **PVC size restrictions**
- It keeps containers within allowed resource boundaries
- Works best together with **ResourceQuota**
- Helps stabilize scheduling and node health
