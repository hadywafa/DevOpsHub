Perfect ‚ö°Ô∏è
Now we continue to **Document 5 of 6** in your Pod Administration series:

# üåê Kubernetes Pods 105 ‚Äî Networking & Storage at Pod Level

> üéØ **Goal:** Understand how Pods communicate (internally and externally), how storage works inside them, and how to manage both as an administrator ‚Äî with real commands, troubleshooting flows, and admin tips.

---

<div align="center" style="background-color:#fff; border-radius: 2px; border: 2px solid">
  <img src="https://kubernetes.io/images/docs/pod-networking.svg" alt="Pod Networking" style="width: 70%; border-radius: 10px" />
</div>

---

## üß† 1. Networking 101 ‚Äî The Kubernetes Model

Kubernetes uses a **flat network model**:

* Every **Pod gets its own IP address**.
* All Pods can communicate **without NAT**.
* Containers inside a Pod share the **same network namespace**.

### Key Principles:

1Ô∏è‚É£ **Pod-to-Pod** ‚Äî same or different nodes
2Ô∏è‚É£ **Pod-to-Service** ‚Äî internal stable access
3Ô∏è‚É£ **Container-to-Container** ‚Äî within same Pod

---

## üß© 2. Container-to-Container Communication

Inside a single Pod, containers share:

* The same **network interface (eth0)**
* The same **IP address**
* The same **localhost**

Example:

```bash
# In container A
curl localhost:8080
```

‚úÖ Reaches container B inside the same Pod if it‚Äôs listening on port 8080.

---

## üß± 3. Pod-to-Pod Communication

Each Pod gets an IP from the cluster‚Äôs **CNI (Container Network Interface)** plugin ‚Äî such as:

* **Calico**
* **Flannel**
* **Cilium**
* **Weave**

Example:

```bash
kubectl exec -it pod-a -- ping <pod-b-ip>
```

‚úÖ Works across nodes if CNI is properly configured.

---

### üß∞ Admin Tip:

To view Pod IPs:

```bash
kubectl get pods -o wide
```

If Pods on different nodes **can‚Äôt reach** each other:

* Check CNI pods in `kube-system` namespace

  ```bash
  kubectl get pods -n kube-system
  ```
* Inspect network plugin logs

  ```bash
  kubectl logs -n kube-system <cni-pod-name>
  ```

---

## üß© 4. Pod-to-Service Communication

Services provide **stable DNS names** and **virtual IPs** (ClusterIP).
Pods access other Pods **via Service name** instead of IP.

Example:

```bash
curl http://nginx.default.svc.cluster.local
```

DNS structure:

```
<service>.<namespace>.svc.cluster.local
```

---

### Check Cluster DNS

```bash
kubectl exec -it <pod> -- nslookup kubernetes.default
```

If DNS fails:

* Check CoreDNS pods:

  ```bash
  kubectl get pods -n kube-system -l k8s-app=kube-dns
  ```
* Restart if needed:

  ```bash
  kubectl delete pod -n kube-system -l k8s-app=kube-dns
  ```

---

## üß± 5. Exposing Pod Ports

Expose port manually:

```bash
kubectl expose pod mypod --port=80 --target-port=8080 --name=mypod-svc
```

View service:

```bash
kubectl get svc mypod-svc
```

---

## üß≠ 6. Pod Networking Commands Summary

| Task                   | Command                                                 |
| ---------------------- | ------------------------------------------------------- |
| View Pod IPs           | `kubectl get pods -o wide`                              |
| Ping another pod       | `kubectl exec -it <pod> -- ping <pod-ip>`               |
| Test DNS               | `kubectl exec -it <pod> -- nslookup kubernetes.default` |
| Get service cluster IP | `kubectl get svc`                                       |
| Curl service           | `kubectl exec -it <pod> -- curl <svc-name>`             |

---

## üß∞ 7. Admin Networking Troubleshooting

### üîç Check Network Policies

If Pods cannot reach each other:

```bash
kubectl get networkpolicy -A
```

Temporarily delete policy for debugging:

```bash
kubectl delete networkpolicy <policy>
```

---

### üîç Verify IP Tables Rules

```bash
iptables -t nat -L -n | grep KUBE
```

Look for `KUBE-SERVICES` and `KUBE-POSTROUTING`.

---

### üîç Debug Pod Network

Use **busybox** or **netshoot** Pod:

```bash
kubectl run netshoot --image=nicolaka/netshoot -it -- bash
```

Then run:

```bash
ping <pod-ip>
curl <svc-name>
traceroute <pod-ip>
```

---

## üß† 8. Pod Storage Basics

Pods are ephemeral ‚Äî when a Pod dies, data inside is lost unless stored in **Volumes**.

> üíæ Volumes provide **persistent or shared storage** that survives container restarts.

---

## üß± 9. Volume Types (Admin View)

| Type                            | Description                                             | Scope         |
| ------------------------------- | ------------------------------------------------------- | ------------- |
| **emptyDir**                    | Temporary storage shared by containers in Pod           | Pod lifecycle |
| **hostPath**                    | Mount host node directory                               | Tied to node  |
| **persistentVolumeClaim (PVC)** | Connects to cluster-wide storage (EBS, AzureDisk, etc.) | Persistent    |
| **configMap / secret**          | Mounts configuration data                               | Read-only     |
| **CSI volumes**                 | Provided by external storage drivers                    | Persistent    |

---

## üß© 10. Example: emptyDir (Shared Storage)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: shared-pod
spec:
  containers:
  - name: app1
    image: busybox
    command: ["sh", "-c", "echo Hello > /data/msg; sleep 3600"]
    volumeMounts:
    - name: shared-storage
      mountPath: /data
  - name: app2
    image: busybox
    command: ["sh", "-c", "cat /data/msg; sleep 3600"]
    volumeMounts:
    - name: shared-storage
      mountPath: /data
  volumes:
  - name: shared-storage
    emptyDir: {}
```

‚úÖ Containers share `/data` folder ‚Üí same files accessible.

---

## üíæ 11. Example: hostPath

```yaml
volumes:
- name: host-storage
  hostPath:
    path: /var/log/app
    type: Directory
```

‚ö†Ô∏è **Tied to specific node.**
If Pod moves, data doesn‚Äôt follow.

---

## üß± 12. Persistent Storage with PVC

### Step 1: Define PersistentVolume (PV)

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-demo
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

---

### Step 2: Define PersistentVolumeClaim (PVC)

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-demo
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
```

---

### Step 3: Use PVC in Pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pv-pod
spec:
  containers:
  - name: app
    image: nginx
    volumeMounts:
    - name: app-storage
      mountPath: /usr/share/nginx/html
  volumes:
  - name: app-storage
    persistentVolumeClaim:
      claimName: pvc-demo
```

‚úÖ Pod mounts `/mnt/data` ‚Üí data persists if Pod is deleted.

---

## üß© 13. Verify Storage Binding

```bash
kubectl get pv,pvc
```

Expected output:

```
NAME           CAPACITY  ACCESS MODES  STATUS    CLAIM
pv/pv-demo     1Gi       RWO           Bound     default/pvc-demo
```

---

## üß∞ 14. Common Troubleshooting Commands

| Task                     | Command                       |                   |
| ------------------------ | ----------------------------- | ----------------- |
| Show volumes used by Pod | `kubectl describe pod <pod>   | grep -A3 Volumes` |
| List PV and PVC          | `kubectl get pv,pvc`          |                   |
| Check storageclass       | `kubectl get sc`              |                   |
| Inspect binding          | `kubectl describe pvc <name>` |                   |
| Remove stale PV          | `kubectl delete pv <name>`    |                   |

---

## üß† 15. Common Storage Issues

| Problem                       | Cause                        | Fix                               |
| ----------------------------- | ---------------------------- | --------------------------------- |
| PVC stuck in Pending          | No matching PV               | Create PV or correct StorageClass |
| PV Released but not Reclaimed | ReclaimPolicy set to Retain  | Manually delete PV                |
| Pod won‚Äôt start               | PVC not bound                | Check `kubectl describe pvc`      |
| Data lost after restart       | Used emptyDir instead of PVC | Use persistent volume             |

---

## üß© 16. StorageClass Quick Overview

Defines **provisioning backend** for dynamic PV creation.

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp3
reclaimPolicy: Delete
```

Then your PVC just references `storageClassName: fast`.
Kubernetes automatically provisions a PV.

---

## üß† 17. Clean-Up Commands

```bash
kubectl delete pod shared-pod
kubectl delete pvc pvc-demo
kubectl delete pv pv-demo
kubectl delete sc fast
```

---

## üß≠ 18. Best Practices Summary

| Area                  | Best Practice                             |
| --------------------- | ----------------------------------------- |
| **Networking**        | Always test DNS with busybox/netshoot     |
| **CNI Health**        | Monitor CNI plugin logs and restarts      |
| **Storage**           | Prefer PVC + StorageClass for persistence |
| **hostPath**          | Avoid in production (node-bound)          |
| **emptyDir**          | Use for cache/temp data only              |
| **Namespace Storage** | Use quotas to limit total PV usage        |

---

## üß≠ Next Deep Dives (Related Topics)

1Ô∏è‚É£ **Pods 106: Debugging & Recovery Techniques**
2Ô∏è‚É£ **Networking Deep Dive (CNI, Services, Ingress)**
3Ô∏è‚É£ **Persistent Volumes & StorageClass (Cluster-level Admin)**

---

Would you like me to continue with **Pods 106: Debugging & Recovery Techniques** next ‚Äî covering CrashLoopBackOffs, init containers, log inspection, ephemeral debugging containers, and real recovery workflows?
