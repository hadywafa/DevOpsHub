Perfect ğŸ‘Œ
Now we move to **Document 4 of 6** under *Pod Administration*:

# âš™ï¸ Kubernetes Pods 104 â€” Resource Requests, Limits & QoS Classes

> ğŸ’¡ Goal: Become fluent in how Kubernetes handles CPU, memory, and Quality of Service (QoS).
> Youâ€™ll master how to **set**, **inspect**, and **troubleshoot** pod resource controls like a real admin.

---

<div align="center" style="background-color:#fff; border-radius: 2px; border: 2px solid">
  <img src="https://kubernetes.io/images/docs/resource-requests-limits.svg" alt="Kubernetes QoS" style="width: 70%; border-radius: 10px" />
</div>

---

## ğŸ¯ Objectives

* Understand **requests** (reservation) and **limits** (enforcement)
* Learn **CPU/memory units** and scheduling impact
* Manage **QoS classes**: Guaranteed, Burstable, BestEffort
* Troubleshoot out-of-resource events (OOMKilled, throttling)

---

## ğŸ§© 1. Why Resource Management Matters

Kubernetes schedules pods based on **available node resources**.
If you donâ€™t set requests/limits:

* Some pods **hog** CPU or RAM ğŸ·
* Some pods get **killed** by the kernel OOMKiller ğŸ’€

âœ… Setting resource configs ensures:

* **Fairness**
* **Predictable scheduling**
* **Stable cluster performance**

---

## ğŸ§± 2. CPU & Memory Units

### ğŸ§® CPU

* 1 CPU = 1 vCPU or 1 core
* Fractional units supported (e.g. `500m` = 0.5 core)

### ğŸ’¾ Memory

* Expressed in bytes (e.g. `Mi`, `Gi`)

  * `Mi` = mebibytes (1024Â²)
  * `Gi` = gibibytes (1024Â³)

Example:

```yaml
resources:
  requests:
    cpu: "500m"
    memory: "256Mi"
  limits:
    cpu: "1"
    memory: "512Mi"
```

---

## âš™ï¸ 3. Resource Requests vs Limits

| Concept      | Meaning                                   | Effect                                     |
| ------------ | ----------------------------------------- | ------------------------------------------ |
| **Requests** | Minimum resources guaranteed to container | Scheduler uses this to find a node         |
| **Limits**   | Maximum resources container can use       | Kubelet enforces this (throttles or kills) |

---

### ğŸ§  Scheduler Logic

When placing a pod:

* Adds up all container **requests**
* Finds node where `available â‰¥ requests`
* Schedules pod there
  Even if pod later consumes **less**, node remains **reserved**.

---

## ğŸ§© 4. Container-Level Example

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: resource-demo
spec:
  containers:
  - name: cpu-mem-demo
    image: nginx
    resources:
      requests:
        memory: "128Mi"
        cpu: "250m"
      limits:
        memory: "256Mi"
        cpu: "500m"
```

---

### Verify Requests & Limits

```bash
kubectl get pod resource-demo -o custom-columns=NAME:.metadata.name,REQUESTS:.spec.containers[*].resources.requests,MEM:.spec.containers[*].resources.limits
```

Or describe:

```bash
kubectl describe pod resource-demo
```

---

## ğŸ§  5. CPU Behavior

* **Exceeding limit** â†’ throttled (not killed)
* **Below request** â†’ allowed, no penalty
* **No limit** â†’ can burst freely until node is saturated

Check throttling via metrics:

```bash
kubectl top pod
```

---

## ğŸ’¾ 6. Memory Behavior

* **Exceeding limit** â†’ container killed (`OOMKilled`)
* **No limit** â†’ may kill neighbors if node runs out of memory
* **Request only** â†’ scheduler respects reservation, but may still kill if limit missing

Inspect OOM:

```bash
kubectl describe pod <pod> | grep -i "OOMKilled"
```

---

## âš–ï¸ 7. QoS (Quality of Service) Classes

Determined automatically based on requests/limits of all containers in pod.

| Class          | Rules                                    | Behavior                              |
| -------------- | ---------------------------------------- | ------------------------------------- |
| **Guaranteed** | Requests = Limits for **all containers** | Highest priority; killed last         |
| **Burstable**  | Requests < Limits (or mixed)             | Middle priority                       |
| **BestEffort** | No requests or limits                    | Killed first during resource pressure |

---

### ğŸ§® Example 1: Guaranteed Pod

```yaml
resources:
  requests:
    cpu: "500m"
    memory: "256Mi"
  limits:
    cpu: "500m"
    memory: "256Mi"
```

âœ… Requests = Limits â†’ **Guaranteed**

---

### ğŸ§® Example 2: Burstable Pod

```yaml
resources:
  requests:
    cpu: "250m"
    memory: "128Mi"
  limits:
    cpu: "500m"
    memory: "256Mi"
```

âœ… Requests < Limits â†’ **Burstable**

---

### ğŸ§® Example 3: BestEffort Pod

```yaml
# no resources defined
```

âœ… No requests/limits â†’ **BestEffort**

---

### Check QoS Class

```bash
kubectl get pod <pod> -o jsonpath='{.status.qosClass}'
```

---

## âš™ï¸ 8. Node Resource Accounting

View total capacity:

```bash
kubectl describe node <nodename> | grep -A5 "Capacity"
```

List pod usage:

```bash
kubectl top pod
```

List node usage:

```bash
kubectl top node
```

---

## ğŸ§­ 9. Troubleshooting Resource Issues

### ğŸ§© Pod Pending (Unschedulable)

Cause: requests exceed available node resources
Check:

```bash
kubectl describe pod <pod>
```

Look for:

```
0/3 nodes are available: 3 Insufficient memory.
```

Fix: lower requests or add larger nodes.

---

### ğŸ’€ Pod OOMKilled

Cause: memory limit exceeded
Fix:

* Increase memory limit
* Optimize app memory usage

---

### ğŸ¢ CPU Throttling

Cause: exceeded CPU limit
Fix:

* Raise limit or remove it for critical pods

---

### ğŸ§© Node Eviction

When node under pressure:

* Evicts **BestEffort** first, then **Burstable**, then **Guaranteed**
* Marked as `Evicted` in pod status

Check:

```bash
kubectl get pods --field-selector=status.phase=Failed
```

---

## ğŸ§® 10. Resource Quotas (Namespace-Level Control)

Prevent users from consuming too many cluster resources.

### Create quota

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "2"
    limits.memory: "4Gi"
```

Apply:

```bash
kubectl apply -f quota.yaml
```

View:

```bash
kubectl describe quota -n dev
```

---

### Combine with LimitRange (Default Resource Policies)

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: container-limits
  namespace: dev
spec:
  limits:
  - default:
      cpu: 500m
      memory: 512Mi
    defaultRequest:
      cpu: 250m
      memory: 256Mi
    type: Container
```

Apply defaults for containers missing resource specs.
Check:

```bash
kubectl describe limitrange -n dev
```

---

## ğŸ§° 11. Handy Admin Commands

| Task                | Command                                                   |               |
| ------------------- | --------------------------------------------------------- | ------------- |
| Show pod resources  | `kubectl top pod`                                         |               |
| Show node resources | `kubectl top node`                                        |               |
| Describe QoS        | `kubectl get pod <name> -o jsonpath='{.status.qosClass}'` |               |
| Check quota usage   | `kubectl describe quota`                                  |               |
| Apply defaults      | `kubectl apply -f limitrange.yaml`                        |               |
| Check pending pods  | `kubectl get pods                                         | grep Pending` |

---

## ğŸ§  12. Admin Insights

* Always set **requests** for scheduler stability
* Use **limits** carefully â€” too low â†’ throttling, too high â†’ wasted resources
* Guarantee QoS for critical workloads (e.g., DBs)
* Use **LimitRange** and **ResourceQuota** in shared clusters
* Monitor continuously via **metrics-server** and **kubectl top**

---

## ğŸ§ª 13. Practical Hands-On

1ï¸âƒ£ Create a pod with requests/limits:

```bash
kubectl run demo --image=nginx --requests='cpu=200m,memory=128Mi' --limits='cpu=500m,memory=256Mi'
```

2ï¸âƒ£ View usage:

```bash
kubectl top pod demo
```

3ï¸âƒ£ Get QoS:

```bash
kubectl get pod demo -o jsonpath='{.status.qosClass}'
```

4ï¸âƒ£ Simulate OOM:

```bash
kubectl exec -it demo -- sh -c "dd if=/dev/zero of=/dev/null bs=1M count=500"
```

5ï¸âƒ£ Check pod events:

```bash
kubectl describe pod demo
```

---

## ğŸ§­ Next Deep Dives (Related Topics)

1ï¸âƒ£ **Pods 105: Networking & Storage at Pod Level**
2ï¸âƒ£ **Pods 106: Debugging & Recovery Techniques**

---

Would you like me to continue with **Pods 105: Networking & Storage at Pod Level** next (including container-to-container communication, service discovery, DNS, and volumes with examples)?
