# ğŸŒ Kubernetes Contexts & Multi-Cluster Management

Managing multiple Kubernetes clusters **without contexts** is like trying to drive multiple cars using one steering wheel â€” chaos guaranteed.  
Contexts fix that. They let you _instantly switch_ between clusters, users, and namespaces with zero pain (and fewer production accidents ğŸ˜).

---

<div align="center" style="background-color:#EAF0FA; border-radius: 10px; border: 2px solid">
 <img src="image/.kube-config.png" alt=".kube-config" style="width: 60%">
</div>

---

## ğŸ§  What Is a Kubernetes Context?

A **context** = `cluster` + `user` + `namespace`.

It tells `kubectl`:

> â€œHey, when I run commands â€” talk to _this_ cluster, authenticate as _this_ user, and assume _this_ namespace.â€

Perfect for multi-cluster setups such as:

- dev / test / staging / prod
- AKS + EKS + GKE
- local Minikube + cloud clusters
- multiple customer clusters (consulting scenario)

---

## ğŸ—ï¸ Context Anatomy

Every context has **three components**:

<div align="center" style="background:#343739ff; border-radius:20px">

| Component     | Purpose                                           |
| ------------- | ------------------------------------------------- |
| **Cluster**   | Which Kubernetes API Server to talk to            |
| **User**      | How to authenticate (token, certs, auth-provider) |
| **Namespace** | Default namespace for your commands               |

</div>

---

## ğŸ“ Understanding `~/.kube/config` (The Holy Book of kubectl)

This file defines everything kubectl knows: clusters, users, contexts, and the currently active context.

Letâ€™s break it _the smart way_ ğŸ‘‡

---

### ğŸ° 1. Clusters Section

Defines where your Kubernetes API server lives.

```yaml
clusters:
  - name: dev-cluster
    cluster:
      server: https://dev.example.com:6443
      certificate-authority: /path/to/ca.crt
      insecure-skip-tls-verify: false
```

ğŸ“ Notes

- `server` â†’ URL of API server
- Uses TLS certs or can skip verification (not recommended unless local testing)
- Cluster name is referenced by contexts

---

### ğŸ§‘â€ğŸ’» 2. Users Section

The _credentials_ (identity) you use to authenticate.

```yaml
users:
  - name: dev-user
    user:
      client-certificate: /path/to/client.crt
      client-key: /path/to/client.key
      token: <auth-token>
```

Common auth methods:

- Client certificates
- Static Bearer tokens
- Exec plugins (used by AWS EKS and GCP GKE)
- OIDC providers

---

### ğŸ”— 3. Contexts Section

Connects **cluster â†” user â†” default namespace**.

```yaml
contexts:
  - name: dev-context
    context:
      cluster: dev-cluster
      user: dev-user
      namespace: dev
```

This is what you switch using `kubectl config use-context`.

---

### â­ 4. Current Context

This tells kubectl what to use _right now_:

```yaml
current-context: dev-context
```

If you donâ€™t specify `--context` in a command, kubectl uses this.

---

## ğŸ§­ Visual Overview â€” What Happens When You Run `kubectl get pods`

Hereâ€™s the flow (Mermaid diagram):

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
flowchart LR
    A[kubectl get pods] --> B["~/.kube/config"]
    B --> C[Current Context]
    C --> D["Cluster (API Server)"]
    C --> E[User Credentials]
    C --> F[Namespace]
    D --> G[API Request Sent]
    E --> G
    F --> G
    G --> H[Pods Returned]
```

</div>

---

## ğŸ”Œ Connecting to Multiple Clusters (DevOps-Grade Workflow)

### Step 1ï¸âƒ£ â€” Add Clusters

```bash
kubectl config set-cluster dev-cluster \
  --server=https://dev-api.example.com:6443 \
  --certificate-authority=/path/to/ca.crt
```

### Step 2ï¸âƒ£ â€” Add Users

```bash
kubectl config set-credentials dev-user --token=<token>
```

### Step 3ï¸âƒ£ â€” Create Contexts

```bash
kubectl config set-context dev-context \
  --cluster=dev-cluster \
  --user=dev-user \
  --namespace=dev
```

```bash
kubectl config set-context prod-context \
  --cluster=prod-cluster \
  --user=prod-user \
  --namespace=prod
```

### Step 4ï¸âƒ£ â€” Switch Contexts Like a Boss ğŸ˜

```bash
kubectl config use-context dev-context
```

### Step 5ï¸âƒ£ â€” Run Commands

```bash
kubectl get pods
```

kubectl automatically uses the **dev cluster** and **dev namespace**.

---

## ğŸ§° Context Management Commands

### ğŸ“Œ View all contexts

```bash
kubectl config get-contexts
```

### ğŸ“Œ Switch context

```bash
kubectl config use-context <context-name>
```

### ğŸ“Œ Create new context

```bash
kubectl config set-context <ctx> \
--cluster=<cluster-name> \
--user=<user-name> \
--namespace=<namespace>
```

### ğŸ“Œ Use context only for single command

```bash
kubectl --context=prod-context get deployments
```

---

## ğŸŒ When Do You Need Multiple Contexts?

Use cases where multiple contexts shine ğŸ’¡:

- Switching between **dev â†’ staging â†’ prod** safely
- Working with **local (kind) + remote (EKS/GKE/AKS)**
- Consulting or freelancing for multiple clients
- Running CI/CD pipelines accessing multiple clusters
- Multi-tenant platform engineering

---

## ğŸ† Best Practices (Real DevOps Advice)

### âœ”ï¸ 1. Use Descriptive Names

Examples:

- `eks-prod-us-east-1`
- `aks-staging-eu`
- `minikube-local`

### âœ”ï¸ 2. Donâ€™t Mix Clusters Accidentally

Use `kubectl config current-context` before applying manifests.

### âœ”ï¸ 3. Version Control the kubeconfig (When Safe)

For team setups, create a **template** kubeconfig file.
âš ï¸ Never commit real creds.

### âœ”ï¸ 4. Separate kubeconfig files (Advanced)

Use:

```bash
export KUBECONFIG=~/.kube/dev:~/.kube/prod
```

Or merge using:

```bash
kubectl config view --merge --flatten > ~/.kube/config
```

### âœ”ï¸ 5. Auto-Select Context per Directory (pro tip)

Use **kubectx + kubens** or **direnv** for automatic context switching based on project folder.

---

## ğŸ”¥ Final Summary

Kubernetes contexts are the **safest**, **cleanest**, and **most professional** way to manage multiple clusters without messing up production.
By mastering contexts:

- You switch clusters instantly
- Your commands always hit the correct namespace
- Multi-cluster workflows become effortless
- You avoid accidental production deployments ğŸ˜¬

Contexts = **DevOps sanity + productivity + fewer headaches**.
