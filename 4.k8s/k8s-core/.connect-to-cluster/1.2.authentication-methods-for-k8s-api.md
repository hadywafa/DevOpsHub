# ğŸ” **Authentication Methods for Accessing the K8s REST API**

_Ordered from LEAST common â†’ MOST common, with full real-world DevOps detail!_

Kubernetes supports several authentication methods for users and applications interacting with the REST API.
Some are **legacy** (deprecated), some are **cryptographically strong**, and some are **enterprise-grade**.

Letâ€™s walk through **all methods**, from outdated â†’ modern â†’ recommended â†’ enterprise SSO.

---

## âŒ **1. Basic Authentication** (LEGACY / DEPRECATED)

> **Deprecated since Kubernetes 1.19**.
> Removed from most managed clusters (EKS, AKS, GKE).
> Only available if running your own `kube-apiserver` in a cluster YOU control (like kubeadm, k3s, custom clusters).

Use only for **testing**, **labs**, or **CKA exam** environments.

---

### ğŸ…°ï¸ â€” Username + Password Auth (DEPRECATED)

#### ğŸ”¹ Step 1 â€” Create `.htpasswd` file

```bash
htpasswd -c /etc/kubernetes/htpasswd admin
```

#### ğŸ”¹ Step 2 â€” Enable in kube-apiserver (ONLY self-managed clusters)

Edit `/etc/kubernetes/manifests/kube-apiserver.yaml`:

```yaml
- --basic-auth-file=/etc/kubernetes/htpasswd
```

Restart kube-apiserver (kubelet auto-reloads static pod).

#### ğŸ”¹ Step 3 â€” Use in REST API call

```bash
curl -u admin:<password> https://<api-server>/api/v1/pods
```

---

### ğŸ…±ï¸ â€” Username + Token Auth (DEPRECATED)

#### ğŸ”¹ Step 1 â€” Create token file

You define a **static token file**:

```ini
<token>,<username>,<uid>,<group1>,<group2>
```

Example `/etc/kubernetes/token.csv`:

```ini
1234567890abcdef,devuser,1001,system:masters
```

#### ğŸ”¹ Step 2 â€” Enable token-based auth

Add to `kube-apiserver.yaml`:

```yaml
- --token-auth-file=/etc/kubernetes/token.csv
```

#### ğŸ”¹ Step 3 â€” Use token

```bash
curl -H "Authorization: Bearer 1234567890abcdef" \
  https://<api-server>/api/v1/pods
```

---

### ğŸ“ƒ Using Basic/Auth Tokens in kubeconfig (For Testing Only)

```bash
kubectl config set-credentials devuser \
  --username=devuser --password=<password>

kubectl config set-credentials devtokenuser \
  --token=1234567890abcdef
```

---

## ğŸ” **2. Client Certificates** (mTLS Auth)

_Still used today (admins, kubelet), but improved using the modern CertificateSigningRequest API._

Kubernetes supports **X.509 Client Certificate authentication** where identity = CN + O fields.

---

### ğŸ…°ï¸ â€” Old Method (still works): OpenSSL + admin signer

#### ğŸ”¹ Step 1 â€” Generate key + CSR

```bash
openssl genrsa -out client.key 2048
openssl req -new -key client.key -out client.csr -subj "/CN=john/O=dev-team"
```

#### ğŸ”¹ Step 2 â€” Ask admin to sign â†’ produce `client.crt`

```bash
openssl x509 -req -in client.csr -CA /etc/kubernetes/pki/ca.crt \
  -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial \
  -out client.crt -days 36500
```

---

### ğŸ…±ï¸ â€” Modern Best Practice: Kubernetes Certificate API (CSR API)

_Recommended for Kubernetes-native certificate management._

#### ğŸ”¹ Step 1 â€” Base64 encode CSR

```bash
cat client.csr | base64 | tr -d '\n'
```

#### ğŸ”¹ Step 2 â€” Create CSR manifest

```yaml
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: dev-user-csr
spec:
  request: <base64-csr>
  signerName: kubernetes.io/kube-apiserver-client
  usages:
    - client auth
```

Apply:

```bash
kubectl apply -f csr.yaml
```

#### ğŸ”¹ Step 3 â€” Approve CSR

```bash
kubectl certificate approve dev-user-csr
```

#### ğŸ”¹ Step 4 â€” Fetch signed certificate

```bash
kubectl get csr dev-user-csr -o jsonpath='{.status.certificate}' \
  | base64 --decode > client.crt
```

#### ğŸ”¹ Using in REST

```bash
curl -k --cert client.crt --key client.key \
  https://<api-server>/api/v1/pods
```

---

### ğŸ“ƒ Using Client Certificates in kubeconfig

```bash
kubectl config set-credentials john \
  --client-certificate=client.crt \
  --client-key=client.key
```

---

## ğŸª™ **3. Token Authentication (ServiceAccounts)** â€” Modern & Widely Used

_The most common for apps, controllers, automation, CI/CD._

Previously SA tokens were stored in Secrets.  
â¡ï¸ Now Kubernetes uses the **TokenRequest API** which issues **short-lived JWTs** dynamically.

---

### ğŸ…°ï¸ â€” Legacy Method: Read SA Secret Token (Still Works)

#### ğŸ”¹ Step 1 â€” Create ServiceAccount

```bash
kubectl create sa demo
```

#### ğŸ”¹ Step 2 â€” Retrieve token

```bash
SECRET=$(kubectl get sa demo -o jsonpath='{.secrets[0].name}')
TOKEN=$(kubectl get secret $SECRET -o jsonpath='{.data.token}' | base64 --decode)
```

---

### ğŸ…±ï¸ â€” Modern Method (Recommended): TokenRequest API (Projected Token)

#### ğŸ”¹ Step 1 â€” Get a fresh JWT token

```bash
kubectl create token demo
```

Produces output like:

```ini
eyJhbGciOiJSUzI1NiIsImtpZCI6Ij...
```

This token is short-lived and safer.

#### ğŸ”¹ Step 2 â€” Use in curl

```bash
curl -H "Authorization: Bearer $TOKEN" \
  https://<api-server>/api/v1/pods
```

---

### ğŸ“ƒ Using SA Tokens in kubeconfig

```bash
kubectl config set-credentials demo-user --token=$TOKEN
```

---

## ğŸŒ **4. OpenID Connect (OIDC)** â€” Modern, Enterprise-Grade

_The MOST secure, most scalable authentication method._

Supports:

- Single Sign-On (SSO)
- MFA
- AzureAD, Okta, Google, Keycloak, Auth0
- Group-based RBAC

---

### ğŸ”¹ Step 1 â€” Enable OIDC flags on kube-apiserver

```yaml
- --oidc-issuer-url=https://accounts.google.com
- --oidc-client-id=my-k8s-client
- --oidc-username-claim=email
- --oidc-groups-claim=groups
```

---

### ğŸ”¹ Step 2 â€” Login to your Identity Provider

Example login using oidc-login plugin:

```bash
kubectl oidc-login setup
kubectl oidc-login get-token
```

This gives a JWT.

---

### ğŸ”¹ Step 3 â€” Use JWT token

```bash
curl -H "Authorization: Bearer <jwt>" \
  https://<api-server>/api/v1/pods
```

---

### ğŸ“ƒ Using OIDC Tokens in kubeconfig

```bash
kubectl config set-credentials oidc-user \
  --auth-provider=oidc \
  --auth-provider-arg=idp-issuer-url=<issuer> \
  --auth-provider-arg=client-id=<client-id> \
  --auth-provider-arg=refresh-token=<refresh-token>
```

Or modern exec plugins (EKS, AKS, GKE automatically use these).

---

## âš”ï¸ **Visual Comparison**

```mermaid
timeline
  title Kubernetes Authentication Progression
  section Legacy
    Basic Auth : Deprecated
    Static Tokens : Deprecated
  section Strong Auth
    Client Certificates : Admins & kubelet
  section Modern
    ServiceAccount Tokens (TokenRequest API) : Best for apps
  section Enterprise
    OIDC SSO : Best for humans & large companies
```

---

## ğŸ† **FINAL SUMMARY** (Best â†’ Worst)

| Rank       | Method                                   | Best for               | Notes                       |
| ---------- | ---------------------------------------- | ---------------------- | --------------------------- |
| â­â­â­â­â­ | **OIDC (SSO, MFA)**                      | Org users, DevOps, SRE | Most secure & scalable      |
| â­â­â­â­   | **ServiceAccount Tokens (TokenRequest)** | In-cluster apps, CI/CD | Modern + safe               |
| â­â­â­     | **Client Certificates**                  | Admins, kubelet        | Strong but harder to manage |
| âŒ         | **Basic Auth**                           | Testing only           | Deprecated                  |
| âŒ         | **Static Tokens**                        | Testing only           | Deprecated                  |
