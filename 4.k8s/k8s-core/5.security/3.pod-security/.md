You got it. Let‚Äôs make this a **complete, admin-grade playbook** for **secure image pulls** from **private registries**‚Äîincluding **creation, update/rotation strategies, GitOps handling, signing/verification, and troubleshooting**‚Äîwith concrete recipes for **ACR (Azure)**, **ECR (AWS)**, and **GHCR (GitHub)**.
Straightforward, exhaustive, easy to reuse. Bookmark this. üîñ

---

# üîí Kubernetes Secure Image Pulls ‚Äî End-to-End Admin Guide

*(ACR, ECR, GHCR ‚Ä¢ identity-first ‚Ä¢ secrets fallback ‚Ä¢ rotation ‚Ä¢ GitOps ‚Ä¢ signing ‚Ä¢ hardening ‚Ä¢ troubleshooting)*

---

## üß≠ Mental Model

* **Who pulls images?** ‚Üí The **kubelet** on each node.
* **How does it authenticate?**

  1. **Cloud identity** (best): AKS‚á¢ACR, EKS‚á¢ECR (no secrets in Pods).
  2. **Pull secrets**: `kubernetes.io/dockerconfigjson` via Pod/ServiceAccount.
* **Where to attach creds?** ‚Üí Prefer **ServiceAccount** ‚Üí used by all Pods that need those images.
* **Scope** ‚Üí Per **namespace/team**; never global unless necessary.
* **Rotate/Update** ‚Üí Automate. Treat creds as short-lived by default.

---

## 0) Registry URLs & Auth Summary (quick reference)

| Registry | Image URL Pattern                                | Identity-first (no secret)                  | Secret-based Auth                                        |
| -------- | ------------------------------------------------ | ------------------------------------------- | -------------------------------------------------------- |
| **ACR**  | `myacr.azurecr.io/repo/name:tag`                 | **AKS Managed Identity** with `AcrPull`     | Service Principal (appId/secret) or ACR admin user       |
| **ECR**  | `<acct>.dkr.ecr.<region>.amazonaws.com/repo:tag` | **EKS node role** + ECR credential provider | Short-lived token via `aws ecr get-login-password`       |
| **GHCR** | `ghcr.io/<org-or-user>/<image>:tag`              | ‚Äî                                           | GitHub **PAT** (`read:packages`) or **GitHub App** token |

---

## 1) Identity-First Approaches (recommended)

### 1.1 AKS ‚Üí ACR (Managed Identity, no secrets)

Grant the cluster‚Äôs managed identity **AcrPull** on your ACR.

```bash
# easiest: attach ACR to AKS
az aks update -g <rg> -n <aksName> --attach-acr <acrName>

# or explicit role assignment (if needed)
az role assignment create \
  --assignee <AKS_MANAGED_IDENTITY_OBJECT_ID> \
  --role AcrPull \
  --scope /subscriptions/<sub>/resourceGroups/<rg>/providers/Microsoft.ContainerRegistry/registries/<acrName>
```

**Use in Pod** (nothing special; just reference the image):

```yaml
containers:
- name: api
  image: myacr.azurecr.io/myteam/api:1.3.7
```

‚úÖ Pros: zero pull secrets, auto rotation, least sprawl.
üõ† Tips: If using **user-assigned MI** on node pools, ensure it has `AcrPull` too.

---

### 1.2 EKS ‚Üí ECR (Node IAM role, no secrets)

Give the node group‚Äôs role **ECR read** permissions.

* Attach AWS policy **`AmazonEC2ContainerRegistryReadOnly`** to the **node role**.
* Images: `<acct>.dkr.ecr.<region>.amazonaws.com/app:tag`

**No** `imagePullSecrets` required‚Äî**kubelet** uses node IAM creds.
(Ensure the **ECR credential provider** is available on modern EKS AMIs.)

‚úÖ Pros: secure, no secrets in manifests.
üõ† Tips: sync node time (NTP) to avoid token validation drift.

---

## 2) Secrets-Based Pull (portable, works everywhere)

> Use when identity-first isn‚Äôt possible (GHCR, on-prem, multi-cloud).

### 2.1 Create `dockerconfigjson` Secret (shortcut commands)

**ACR (service principal or admin user)**

```bash
kubectl create secret docker-registry acr-pull \
  --docker-server=<acrName>.azurecr.io \
  --docker-username=<APP_ID_OR_ADMIN_USER> \
  --docker-password='<APP_PASSWORD_OR_ADMIN_PW>' \
  --docker-email=dev@example.com \
  -n app
```

**ECR (short-lived token; **automate rotation**):**

```bash
aws ecr get-login-password --region <region> | \
kubectl create secret docker-registry ecr-pull \
  --docker-server=<acct>.dkr.ecr.<region>.amazonaws.com \
  --docker-username=AWS \
  --docker-password-stdin \
  -n app
```

**GHCR (PAT must have `read:packages`):**

```bash
kubectl create secret docker-registry ghcr-pull \
  --docker-server=ghcr.io \
  --docker-username=<github-username> \
  --docker-password='<github-PAT-with-read:packages>' \
  --docker-email=dev@example.com \
  -n app
```

### 2.2 Attach via ServiceAccount (preferred)

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: web-sa
  namespace: app
imagePullSecrets:
  - name: ghcr-pull   # or acr-pull/ecr-pull
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  namespace: app
spec:
  replicas: 2
  selector: {matchLabels: {app: web}}
  template:
    metadata: {labels: {app: web}}
    spec:
      serviceAccountName: web-sa
      containers:
      - name: web
        image: ghcr.io/org/web:1.0
```

‚úÖ Cleaner than putting `imagePullSecrets` on every Pod.
üß™ Verify: `kubectl describe pod <pod> -n app` ‚Üí Events section shows pull auth.

---

## 3) Update & Rotation Strategies (must-have in prod)

### 3.1 Secret Rotation

* **ECR**: tokens are short-lived. Automate with a **CronJob**:

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: rotate-ecr-pull
  namespace: app
spec:
  schedule: "*/30 * * * *"   # refresh every 30 min
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: rotation-bot
          restartPolicy: OnFailure
          containers:
          - name: rotator
            image: amazon/aws-cli
            command: ["/bin/sh","-c"]
            args:
            - |
              PASS=$(aws ecr get-login-password --region <region>)
              kubectl delete secret ecr-pull -n app --ignore-not-found
              kubectl create secret docker-registry ecr-pull \
                --docker-server=<acct>.dkr.ecr.<region>.amazonaws.com \
                --docker-username=AWS \
                --docker-password="$PASS" -n app
```

* **ACR/GHCR**: rotate **client secret/PAT** periodically; re-create secret with the new value.

> **Pods already running** keep using cached auth until they need to repull. Trigger rollout:

```bash
kubectl rollout restart deployment web -n app
```

### 3.2 Immutable vs Pull-on-Change

* Prefer **immutable tags** or **digest pinning**:

  * `image: myacr.azurecr.io/app@sha256:<digest>`
  * Prevents ‚Äútag drift‚Äù and surprises.
* If using tags, set `imagePullPolicy: Always` only for CI/CD or dev; otherwise default caching is fine for prod stability.

### 3.3 GitOps-friendly updates

* Never commit raw secrets. Use:

  * **SealedSecrets** (bitnami), **SOPS** (age/GPG), or **External Secrets Operator** with cloud secret stores.
* Keep **ServiceAccount** + `imagePullSecrets` references as code; rotate backing secrets out-of-band.

---

## 4) Multi-Registry & Per-Team Layouts

### 4.1 One Secret for Multiple Registries

Build a merged `~/.docker/config.json` with multiple `auths`, then:

```bash
kubectl create secret generic registry-pull \
  --type=kubernetes.io/dockerconfigjson \
  --from-file=.dockerconfigjson=$HOME/.docker/config.json \
  -n team-a
```

Attach to team ServiceAccount.

### 4.2 Namespace Scoping

* Create **one pull secret per namespace/team**.
* Bind via **team SA**; deny cross-namespace secret reads with RBAC.

---

## 5) Hardening: Restrict & Verify What Can Run

### 5.1 Restrict allowed registries (admission)

Use **Kyverno** or **Gatekeeper** to allow only your registries:

* `^myacr\.azurecr\.io/`
* `^(\d+)\.dkr\.ecr\.[a-z0-9-]+\.amazonaws\.com/`
* `^ghcr\.io/<your-org>/`

**Kyverno example (allow only ACR + your GHCR org):**

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: allowed-registries
spec:
  validationFailureAction: enforce
  rules:
  - name: check-registries
    match: {resources: {kinds: ["Pod"]}}
    validate:
      message: "Only ACR or org GHCR images are allowed."
      pattern:
        spec:
          containers:
          - image: "(myacr\\.azurecr\\.io/.+|ghcr\\.io/your-org/.+)"
```

### 5.2 Enforce no `:latest` & require digests

* Policy to block `:latest`
* Policy to require `@sha256:...` in prod namespaces

### 5.3 Image signing & verification (supply chain)

* **Sign** images with **Sigstore cosign**
* **Verify** at admission (Kyverno/Policy Controller):

  * Only admit images that pass signature verification from your public key.
* Consider **ACR content trust**, **ECR KMS encryption**, and **immutability**.

---

## 6) Registry-Side Best Practices

### 6.1 ACR

* Use **RBAC** or scoped tokens; avoid admin user for prod.
* Enable **content trust**/**image quarantine** (if applicable).
* Use **ACR Tasks** to build/promote with immutable tags.

### 6.2 ECR

* Enable **repository policy** for least privilege.
* Use **lifecycle policies** to expire old tags.
* Consider **image scanning** (enhanced scanning with Inspector).

### 6.3 GHCR

* Prefer **GitHub App** tokens over broad PATs; scope to org/repo.
* Fine-grained PAT: `read:packages` only.
* Set visibility to **private** and manage access via org teams.

---

## 7) Performance & Ops Patterns

* **Pre-warm nodes** with base images using a **DaemonSet** (faster rollouts; air-gapped assists).
* **Image pull retries/backoff**: kubelet exponentially backs off; inspect `kubectl describe pod` Events.
* **Registry mirrors/pull-through caches** for resiliency and speed (Harbor/Artifactory/ACR geo-replication).

---

## 8) Full Examples (ACR/ECR/GHCR)

### 8.1 ACR ‚Äî Secret-based (when MI not possible)

```bash
kubectl create ns payments
kubectl create secret docker-registry acr-pull \
  --docker-server=myacr.azurecr.io \
  --docker-username=<APP_ID> \
  --docker-password='<APP_SECRET>' \
  --docker-email=dev@example.com \
  -n payments
```

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: pay-sa
  namespace: payments
imagePullSecrets:
  - name: acr-pull
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pay
  namespace: payments
spec:
  replicas: 2
  selector: {matchLabels: {app: pay}}
  template:
    metadata: {labels: {app: pay}}
    spec:
      serviceAccountName: pay-sa
      containers:
      - name: api
        image: myacr.azurecr.io/payments/api@sha256:<digest>
        imagePullPolicy: IfNotPresent
```

### 8.2 ECR ‚Äî Identity-first (node role)

No secret needed‚Äîjust use:

```yaml
containers:
- name: svc
  image: <acct>.dkr.ecr.<region>.amazonaws.com/svc:1.2.3
```

Ensure node IAM role has **ECR ReadOnly**.

### 8.3 GHCR ‚Äî PAT via SA

```bash
kubectl create ns shop
kubectl create secret docker-registry ghcr-pull \
  --docker-server=ghcr.io \
  --docker-username=your-username \
  --docker-password='<PAT-with-read:packages>' \
  --docker-email=dev@example.com \
  -n shop
```

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: shop-sa
  namespace: shop
imagePullSecrets:
  - name: ghcr-pull
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shop
  namespace: shop
spec:
  selector: {matchLabels: {app: shop}}
  replicas: 2
  template:
    metadata: {labels: {app: shop}}
    spec:
      serviceAccountName: shop-sa
      containers:
      - name: web
        image: ghcr.io/your-org/shop/web:2.0.4
```

---

## 9) GitOps & Secret Management

* **Do not** commit raw Secrets. Use:

  * **Sealed Secrets** (controller decrypts at apply time)
  * **SOPS** (encrypt in Git; decrypted by CI/Flux)
  * **External Secrets Operator** (syncs from Azure Key Vault / AWS Secrets Manager / GitHub Secrets)
* Keep the **binding objects** (SA with `imagePullSecrets`) as plain YAML.

---

## 10) Troubleshooting Playbook

**1) Pod won‚Äôt pull (ImagePullBackOff / ErrImagePull)**

* `kubectl describe pod <pod> -n <ns>` ‚Üí read **Events**
* Check secret name, type `kubernetes.io/dockerconfigjson`, and key `.dockerconfigjson`.
* Ensure secret is in the **same namespace**.
* Verify registry URL matches exactly (ACR/ECR/GHCR domain).

**2) `unauthorized: authentication required`**

* GHCR: PAT missing **`read:packages`**
* ACR: wrong user/secret; consider admin user disabled?
* ECR: token expired ‚Üí rotate; node time skew?

**3) Works on some nodes only**

* Time skew or ECR token cache; sync NTP, rotate tokens.

**4) Pulling wrong image/tag**

* Tag drift; use **digests** or immutable tags.
* Admission policy to block `:latest`.

**5) Every Pod needs secret block**

* Move secret reference to **ServiceAccount**.

**6) Want to verify who‚Äôs pulling what**

* Enable kubelet/container runtime logs; registry access logs (ACR/ECR/GHCR)
* Prometheus scrape for image pull timings if available.

---

## 11) Security Checklist (copy/paste)

* [ ] Prefer **identity-first** (AKS‚á¢ACR, EKS‚á¢ECR).
* [ ] If secrets: scope per **namespace/team**; attach via **ServiceAccount**.
* [ ] **Rotate** tokens/keys (CronJob or external secret manager).
* [ ] Enforce **allowed registries** + **no `:latest`** via admission.
* [ ] Prefer **digests** in prod.
* [ ] **Sign** images (cosign) and **verify** at admission.
* [ ] Use **SealedSecrets/SOPS/External Secrets**‚Äîno raw secrets in Git.
* [ ] Enable **image scanning** (ECR/ACR/GHCR integrations).
* [ ] Monitor **pull errors**; alert on repeated backoffs.

---

## 12) Quick Commands Reference

```bash
# List secrets in ns
kubectl get secrets -n app

# Inspect a pull secret (type + key)
kubectl get secret ghcr-pull -n app -o yaml

# Test rollout after secret rotation
kubectl rollout restart deployment web -n app

# See why pull failed
kubectl describe pod <pod> -n app

# Dry-run SA + reference
kubectl create sa web-sa -n app --dry-run=client -o yaml
```

---

### TL;DR

* Use **cloud identity** (no secrets) wherever possible.
* Otherwise, create **dockerconfigjson** pull secrets, attach via **ServiceAccount**, **automate rotation**, and **lock down** what can run (allowed registries, no latest, signatures).
* Keep everything GitOps-friendly with encrypted/externally sourced secrets.

If you share your **exact environment** (AKS/EKS/kubeadm), **namespaces**, and **registry mix**, I‚Äôll spit out a ready-to-apply set of manifests + a rotation CronJob tailored to you.
