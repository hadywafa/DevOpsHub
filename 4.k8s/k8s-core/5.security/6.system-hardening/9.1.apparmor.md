# ğŸ›¡ï¸ **AppArmor in Kubernetes â€” Simple, Clear, Practical (CKS Style)**

AppArmor is a **Linux security module (LSM)** that lets you **restrict what a process can do**, even if the process is compromised.

Think of it like:

> **â€œA permission whitelist for binaries.â€**
>
> Example: _`nginx` is allowed only to read `/var/www`, bind port 80, and nothing else._

It protects containers by giving the **container runtime** (containerd, Docker, CRI-O) a set of rules that restrict system calls, file access, network access, capabilities, etc.

---

## ğŸ§  Why AppArmor Exists (Simple Explanation)

Containers share the host kernel â†’ if a container is compromised, attacker tries:

- Accessing host filesystem
- Escaping using dangerous syscalls
- Reading sensitive files
- Injecting into host processes

AppArmor **prevents** this by applying a **profile** to the containerâ€™s process.

---

## ğŸ§© AppArmor vs. Seccomp (Clear Distinction)

| Feature                | Seccomp | AppArmor                          |
| ---------------------- | ------- | --------------------------------- |
| Controls syscalls      | âœ” Yes   | âœ” Partially (via mediation rules) |
| Controls file paths    | âŒ No   | âœ” Yes                             |
| Controls capabilities  | âŒ No   | âœ” Yes                             |
| Controls network rules | âŒ No   | âœ” Yes                             |
| Blocks kernel modules  | âŒ No   | âœ” Yes                             |
| Difficulty             | Medium  | Easy                              |
| Default in Ubuntu?     | No      | âœ” Yes (AppArmor built-in)         |

**Exam tip:**

> Seccomp = syscall filter
> AppArmor = filesystem + capabilities + process restrictions

---

## ğŸ—ï¸ 1. Install AppArmor (Ubuntu)

Most Ubuntu hosts already have AppArmor enabled.

Check:

```bash
sudo apparmor_status
```

You should see something like:

```ini
apparmor module is loaded.
profiles are in enforce mode.
```

If AppArmor is NOT installed:

```bash
sudo apt install apparmor apparmor-utils
```

Enable and start:

```bash
sudo systemctl enable apparmor
sudo systemctl start apparmor
```

---

## ğŸ“ 2. AppArmor Profiles (The Core Concept)

A profile defines what a program **can** and **cannot** do.

Default location:

```ini
/etc/apparmor.d/
```

Example **simple AppArmor profile**:

```ini
# /etc/apparmor.d/container-nginx
profile container-nginx flags=(attach_disconnected,mediate_deleted) {

  # allow reading web files
  /usr/share/nginx/html/** r,

  # allow network binding
  network inet stream,
  capability net_bind_service,

  # deny everything else
  deny /** w,
}
```

Load the profile:

```bash
sudo apparmor_parser -r /etc/apparmor.d/container-nginx
```

Check loaded profiles:

```bash
sudo apparmor_status
```

---

## ğŸ”§ **AppArmor Modes**

| Mode         | Meaning                             |
| ------------ | ----------------------------------- |
| **enforce**  | Blocks violations                   |
| **complain** | Allows but logs (useful for tuning) |
| **disable**  | Not loaded                          |

Switch profile to **enforce**:

```bash
sudo aa-enforce /etc/apparmor.d/container-nginx
```

Switch to **complain**:

```bash
sudo aa-complain /etc/apparmor.d/container-nginx
```

---

## â˜¸ï¸ **Using AppArmor With Kubernetes Pods**

This is the **most important part for CKS**.

Kubernetes does NOT load AppArmor profiles.
The **node OS loads them**.
Kubernetes simply **references an existing profile**.

To check if AppArmor is enabled:

```bash
kubectl get nodes -o json | jq '.items[].status.allocatable'
```

or:

```bash
kubectl get nodes -o jsonpath='{.items[*].status.appArmor}'
```

More reliable method from node:

```bash
sudo apparmor_status
```

---

## ğŸ§· Apply AppArmor in Pod YAML

### ğŸ“ Old way using Annotations

Add this annotation:

```yaml
annotations:
  container.apparmor.security.beta.kubernetes.io/<container-name>: localhost/<profile-name>
```

Example deployment:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-aa
  annotations:
    container.apparmor.security.beta.kubernetes.io/nginx: localhost/container-nginx
spec:
  containers:
    - name: nginx
      image: nginx
```

### ğŸ“ New way using securityContext

Add this field:

```yaml
spec:
  securityContext:
    appArmorProfile:
      type: Localhost
      localhostProfile: <profile-name>
```

Example deployment:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-aa
spec:
  securityContext:
    appArmorProfile:
      type: Localhost
      localhostProfile: container-nginx
  containers:
    - name: nginx
      image: nginx
```

### ğŸš€ Apply

Apply:

```bash
kubectl apply -f nginx-aa.yaml
```

Verify annotation:

```bash
kubectl describe pod nginx-aa
```

If the profile does NOT exist on the node â†’ the pod will still run, but AppArmor will NOT be applied.

---

## ğŸ”¥ **Demo â€” Block File Writes With AppArmor (Hands-On)**

Create an AppArmor profile that **allows read but denies write**.

`/etc/apparmor.d/nginx-readonly`:

```ini
profile nginx-readonly {

  # allow nginx binary execution
  /usr/sbin/nginx ixr,

  # allow reading html
  /usr/share/nginx/html/** r,

  # deny writing anywhere
  deny /** w,
}
```

Load it:

```bash
sudo apparmor_parser -r /etc/apparmor.d/nginx-readonly
```

Deploy a pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web
  annotations:
    container.apparmor.security.beta.kubernetes.io/web: localhost/nginx-readonly
spec:
  containers:
    - name: web
      image: nginx
```

Apply:

```bash
kubectl apply -f pod.yaml
```

Exec into it:

```bash
kubectl exec -it web -- bash
```

Try writing:

```bash
echo test > /etc/passwd
```

AppArmor prevents:

```ini
Permission denied
```

And logs show violation:

```bash
sudo journalctl -xe | grep DENIED
```

---

## ğŸ› ï¸ **Editing / Creating Profiles Automatically**

Use **AppArmor learning mode**:

```bash
sudo aa-genprof /usr/sbin/nginx
```

Or switch to complain mode first:

```bash
sudo aa-complain nginx-readonly
```

Then convert to enforce after logging enough events:

```bash
sudo aa-enforce nginx-readonly
```

This is great for building custom rules for CKS exam simulations.

---

## ğŸ§¨ **How AppArmor Helps in CKS Exam**

You will use AppArmor to:

- âœ” Deny container from writing on host-like paths
- âœ” Block suspicious binaries
- âœ” Restrict container processes
- âœ” Combine AppArmor + Seccomp for maximum hardening
- âœ” Demonstrate knowledge of runtime restrictions

CKS exam expects:

- Know how to **create a simple profile**
- Know how to **apply a profile via Pod annotation**
- Know how to **load profiles on a node**
- Know how to **check violations**

Very common exam task:

> â€œApply AppArmor to block write access for a pod.â€

---

## ğŸ“ **Final Summary**

- AppArmor = LSM for **process-level** access control
- Profiles live on node: `/etc/apparmor.d/`
- Kubernetes only **references** profiles
- Use via annotation:
  `container.apparmor.security.beta.kubernetes.io/<container>: localhost/<profile-name>`
- Two modes: **enforce**, **complain**
- Denies: file writes, capabilities, network, etc.
- Works great with Seccomp

---

If you want next:

ğŸ‘‰ **AppArmor vs Seccomp vs SELinux** (exam comparison table)  
ğŸ‘‰ **Full hands-on: build profile from scratch**  
ğŸ‘‰ **CKS exam-style AppArmor challenge**

Just tell me.
