# ‚õî **SECCOMP (Secure Computation)**

_Restrict Allowing Executed Syscalls!_

> üò≠ By Default, Linux Kernal allows any syscall to be invoked by a any process running inside user space.

---

![1763291946824](image/8.3.seccomp/1763291946824.png)

---

> üòä Seccomp (**SECure COMPuting**) is a **Linux kernel feature** that lets you **restrict which system calls** (syscalls) a container or process is allowed to make.  
> üí≠ It‚Äôs like a **firewall for syscalls** ‚Äî helping reduce the attack surface.

---

## ‚ÅâÔ∏è **Why Seccomp Matters for CKS**

‚úî Blocks dangerous syscalls like:

- `mount`
- `setns`
- `unshare`
- `ptrace`
- `clone` with privileged flags

> ‚úî Prevents attacker from escaping container  
> ‚úî Reduces surface area of kernel attack  
> ‚úî Enforces ‚Äúleast privilege‚Äù at syscall level  
> ‚úî Mandatory knowledge for CKS exam

---

## üîé **How Seccomp Works (Simple)**

You attach a **seccomp profile (JSON)** to:

- A **Pod**
- Individual **containers**

This profile tells the kernel:

> ‚ÄúThis container is only allowed to use this list of syscalls.‚Äù

Any other syscall ‚Üí **blocked** ‚Üí process gets **killed** or **denied**.

---

## ü§πüèª‚Äç‚ôÇÔ∏è **Seccomp Modes**

| Numeric | Mode Name               | Description                                                               |
| ------- | ----------------------- | ------------------------------------------------------------------------- |
| `0`     | `SECCOMP_MODE_DISABLED` | Seccomp is **off** ‚Äî all syscalls are allowed                             |
| `1`     | `SECCOMP_MODE_STRICT`   | Only allows `read()`, `write()`, `exit()`, and `sigreturn()`              |
| `2`     | `SECCOMP_MODE_FILTER`   | Uses **BPF filters** to allow/block specific syscalls (most common today) |

---

### üîé Mode 0: Disabled

- No syscall filtering
- Full access to kernel APIs
- Risky in production

---

### üîé Mode 1: Strict

- Only allows:
  - `read()`
  - `write()`
  - `exit()`
  - `sigreturn()`
- Used for very simple, static programs
- Rarely used today

---

### üîé Mode 2: Filter (BPF-based)

- Most common in **Docker**, **Kubernetes**, and **sandboxed apps**
- Uses **BPF rules** to allow/block syscalls
- Example: block `ptrace`, `mount`, `clone`, etc.

---

Absolutely, Hady ‚Äî here‚Äôs a clean, example-driven explanation of **Seccomp profiles in Docker**, perfect for CKS prep and onboarding docs:

---

## üß© **Seccomp Profiles in Docker?**

A **Seccomp profile** is a JSON file that defines **which syscalls a container is allowed or denied**.  
Docker uses these profiles to apply **syscall filtering** via the Linux kernel‚Äôs **Seccomp filter mode (mode 2)**.

‚úÖ Think of it as a **syscall firewall** for containers.

---

### üîê Why Use Seccomp Profiles?

- Reduce attack surface by **blocking dangerous syscalls**
- Prevent container escape techniques (e.g., `ptrace`, `kexec_load`)
- Enforce **least privilege** at the syscall level

---

### üì¶ Default Behavior in Docker

Docker applies a **default Seccomp profile** unless you override it.

```bash
docker run ubuntu
```

> ‚úÖ This uses `/usr/share/docker/seccomp.json` internally, which blocks ~44 risky syscalls.

---

### üßæ Use a Custom Seccomp Profile

#### 1. Create `seccomp-profile.json`

```json
{
  "defaultAction": "SCMP_ACT_ALLOW",
  "syscalls": [
    {
      "names": ["ptrace", "kexec_load"],
      "action": "SCMP_ACT_ERRNO"
    }
  ]
}
```

‚úÖ This profile allows everything **except** `ptrace` and `kexec_load`.

---

#### 2. Run Docker with the Profile

```bash
docker run --security-opt seccomp=/path/to/seccomp-profile.json ubuntu
```

‚úÖ Docker will apply your custom syscall filter.

---

## üß© **Seccomp Profiles in Kubernetes**

There are **three main types**:

| Profile           | Description                            |
| ----------------- | -------------------------------------- |
| `unconfined`      | No restrictions (default in older k8s) |
| `runtime/default` | Recommended default seccomp profile    |
| Custom JSON file  | Your own fine-grained rules            |

---

## üß± **Where Seccomp Profiles Live?**

On **nodes**, not inside containers.

Default directory on most clusters:

```ini
/var/lib/kubelet/seccomp/
```

You manually copy your JSON profile there.

---

## üìù **Example Seccomp Profile (Very Common in CKS)**

This is a simple ‚Äúdeny all syscalls except a few‚Äù profile:

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "syscalls": [
    {
      "names": ["clone", "fork", "execve"],
      "action": "SCMP_ACT_ALLOW"
    }
  ]
}
```

Meaning:

- **defaultAction = deny everything**
- Only allow:

  - `clone`
  - `fork`
  - `execve`

---

## üè∑Ô∏è **Enable Seccomp on a Pod**

### 1Ô∏è‚É£ Using Pod annotations (old method)

```yaml
annotations:
  seccomp.security.alpha.kubernetes.io/pod: runtime/default
```

### 2Ô∏è‚É£ Using securityContext (NEW and recommended)

```yaml
securityContext:
  seccompProfile:
    type: RuntimeDefault
```

### 3Ô∏è‚É£ Using a custom profile

```yaml
securityContext:
  seccompProfile:
    type: Localhost
    localhostProfile: profiles/my-seccomp.json
```

This refers to:

```ini
/var/lib/kubelet/seccomp/profiles/my-seccomp.json
```

---

## üì¶ **Full Pod Example Using Custom Seccomp Profile**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: seccomp-demo
spec:
  containers:
    - name: app
      image: nginx
      securityContext:
        seccompProfile:
          type: Localhost
          localhostProfile: profiles/restricted.json
```

---

## üõ†Ô∏è **Testing Your Seccomp Profile (VERY USEFUL FOR EXAM)**

Run interactive shell and test dangerous syscalls:

```bash
strace ls
```

Run a forbidden syscall:

```bash
unshare --mount
```

If restricted ‚Üí container dies or syscall returns EPERM.

---

## ‚õî Common Dangerous Syscalls (Often Blocked)

- `unshare()` ‚Üí break namespaces
- `setns()` ‚Üí enter another namespace
- `mount()` ‚Üí mount host filesystem
- `ptrace()` ‚Üí spy on host processes
- `clone()` with flags ‚Üí create privileged processes

---

## üéì **Exam-Focused Steps (What You Actually Do)**

You will get tasks like:

### **Task Example**

> Create a seccomp profile that blocks `unshare` and apply it to a pod.

### Steps:

1Ô∏è‚É£ Create profile

```bash
sudo vi /var/lib/kubelet/seccomp/block-unshare.json
```

Add:

```json
{
  "defaultAction": "SCMP_ACT_ALLOW",
  "syscalls": [
    {
      "names": ["unshare"],
      "action": "SCMP_ACT_ERRNO"
    }
  ]
}
```

2Ô∏è‚É£ Apply it in Pod:

```yaml
securityContext:
  seccompProfile:
    type: Localhost
    localhostProfile: block-unshare.json
```

3Ô∏è‚É£ Run the pod and test:

```bash
kubectl exec -it test -- unshare --mount
```

Should return:

```ini
Operation not permitted
```

Perfect.

---

## ü™ô **Quick Memory Guide (KodeKloud Style)**

- ‚úî Seccomp restricts **syscalls**, not permissions
- ‚úî Profiles = **JSON** files placed on the **node**
- ‚úî Enable via `securityContext.seccompProfile`
- ‚úî `RuntimeDefault` = secure & recommended
- ‚úî `Unconfined` = no protection (avoid)
- ‚úî Use `Localhost` for custom profiles
- ‚úî Deny by default, allow only required syscalls
