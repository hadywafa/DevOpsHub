# ðŸ§± Ensure Immutability for Container at Runtime

Immutability means: once a container starts, **no changes to its filesystem, privileges, or behavior** are allowed. This protects against tampering, drift, and runtime exploits.

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
<img src="image/1763562652537.png" alt="OpenSSL" style="width: 60%">
</div>

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
<img src="image/1763562525590.png" alt="OpenSSL" style="width: 60%">
</div>

---

## ðŸ” Core Strategies

| Strategy                          | Purpose                                    | Enforcement Method           |
| --------------------------------- | ------------------------------------------ | ---------------------------- |
| `readOnlyRootFilesystem: true`    | Prevent filesystem writes                  | Pod `securityContext`        |
| `privileged: false`               | Block host-level access                    | Pod `securityContext` + PSA  |
| `runAsNonRoot: true`              | Drop root privileges                       | Pod `securityContext`        |
| `allowPrivilegeEscalation: false` | Prevent privilege escalation               | Pod `securityContext`        |
| `capabilities.drop: ["ALL"]`      | Remove all Linux capabilities              | Pod `securityContext`        |
| Minimal base image (Distroless)   | Remove shells, compilers, package mgrs     | Dockerfile                   |
| `seccompProfile: RuntimeDefault`  | Block dangerous syscalls                   | Pod `securityContext`        |
| Image signing + digest pinning    | Ensure image integrity and reproducibility | CI/CD + Admission Controls   |
| Block `kubectl exec`              | Prevent shell access                       | RBAC + Admission Controllers |

---

## ðŸ›¡ï¸ Policy Enforcement

### âœ… Pod Security Admission (PSA)

Use Kubernetes â‰¥1.25 built-in admission controller:

```bash
kubectl label ns secure \
  pod-security.kubernetes.io/enforce=restricted \
  pod-security.kubernetes.io/enforce-version=latest
```

> Blocks `privileged: true`, enforces `readOnlyRootFilesystem`, `runAsNonRoot`, etc.

---

### âœ… Kyverno / OPA Gatekeeper

Example Kyverno policy to block privileged pods:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-privileged
spec:
  validationFailureAction: enforce
  rules:
    - name: no-privileged
      match:
        resources:
          kinds: ["Pod"]
      validate:
        message: "Privileged containers are not allowed."
        pattern:
          spec:
            containers:
              - securityContext:
                  privileged: "false"
```

---

## ðŸ§  Summary Diagram (Textual)

```plaintext
Pod Spec â”€â”€> SecurityContext â”€â”€> Immutable Runtime
   â”‚              â”‚
   â”‚              â”œâ”€ readOnlyRootFilesystem: true
   â”‚              â”œâ”€ privileged: false
   â”‚              â”œâ”€ runAsNonRoot: true
   â”‚              â”œâ”€ drop capabilities
   â”‚              â””â”€ seccompProfile: RuntimeDefault
   â”‚
   â””â”€> Image â”€â”€> Signed + Pinned â”€â”€> Verified at Deploy
```

---

## ðŸ” 1. **Use Read-Only Root Filesystem**

Prevent writes to the containerâ€™s root filesystem:

### âœ… Kubernetes Pod Spec:

```yaml
securityContext:
  readOnlyRootFilesystem: true
```

### âœ… Docker CLI:

```bash
docker run --read-only ...
```

> This blocks writes to `/`, forcing apps to write only to explicitly mounted volumes (e.g., `/tmp`, `/var/log`).

---

## ðŸ§± 2. **Avoid Writable Volumes Unless Necessary**

- Donâ€™t mount `emptyDir`, `hostPath`, or PVCs unless the app truly needs them.
- If needed, mount them to **specific paths** (e.g., `/data`) â€” not `/` or `/var`.

---

## ðŸ§‘â€ðŸ’» 3. **Run as Non-Root + Drop Capabilities**

Prevent privilege escalation and filesystem tampering:

```yaml
securityContext:
  runAsNonRoot: true
  capabilities:
    drop: ["ALL"]
```

---

## ðŸ§¬ 4. **Use Distroless or Minimal Base Images**

- Avoid shells, package managers, and compilers in your image.
- Use [Distroless](https://github.com/GoogleContainerTools/distroless), [Wolfi](https://github.com/wolfi-dev), or [Alpine](https://alpinelinux.org) with care.

> No `bash`, no `apt`, no `curl` = no tampering.

---

## ðŸ§ª 5. **Use Seccomp + AppArmor Profiles**

- **Seccomp**: Restrict syscalls (e.g., block `mount`, `ptrace`, `chmod`)
- **AppArmor**: Restrict file access and execution

### Example:

```yaml
securityContext:
  seccompProfile:
    type: RuntimeDefault
```

---

## ðŸ§° 6. **Use Image Signing + Verification**

- Sign images with **cosign** or **Notary**
- Enforce signature verification with **Kyverno**, **OPA Gatekeeper**, or **Sigstore policy-controller**

> Prevents tampered images from being deployed.

---

## ðŸ§¯ 7. **Disable Exec and Shell Access**

- Block `kubectl exec` in production via RBAC
- Use admission controllers or PSP replacements to enforce

---

## ðŸ§¼ 8. **Immutable Tags + Digest Pinning**

- Never use `:latest` â€” use immutable digests:

```yaml
image: myapp@sha256:abc123...
```

---

## ðŸ§  Summary Table

| Strategy                     | Enforces Immutability On     |
| ---------------------------- | ---------------------------- |
| `readOnlyRootFilesystem`     | Filesystem                   |
| Drop capabilities + non-root | Privilege boundaries         |
| Distroless base image        | Build-time attack surface    |
| Seccomp/AppArmor             | Syscall and file access      |
| Image signing                | Deployment integrity         |
| Digest pinning               | Image version control        |
| No exec/shell                | Runtime tampering prevention |
