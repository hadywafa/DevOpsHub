# üêÇ **OPA (Open Policy Agent)**

## üìñ **What is OPA?**

**Open Policy Agent (OPA)** is a **general-purpose policy engine**.
You give it:

- **Data** (input/context)
- **Policies** (written in a language called **Rego**)

‚Ä¶and it returns **decisions** like:

- `allow = true/false`
- `allowed_roles = ["admin", "auditor"]`
- `patch = { ... }` (for mutations)

OPA doesn‚Äôt enforce anything by itself. It just **answers questions** like:

> ‚ÄúGiven this request and these rules, should this be allowed?‚Äù

It can be embedded in:

- Microservices
- CLIs
- API gateways
- Kubernetes (via Gatekeeper / admission webhooks)
- CI/CD pipelines
- Any system that needs policy decisions.

---

## ‚ùì **Why OPA? (Why not just `if` statements?)**

You _could_ hardcode logic like:

```go
if user.Role == "admin" && resource.Owner == user.ID {
    // allow
}
```

But this becomes a nightmare when:

- Policies change frequently
- Security/compliance want to manage rules
- You have many microservices/languages

OPA solves this by:

- Separating **policy** from **application code**
- Centralizing or standardizing policies
- Letting you test policies like code (unit tests)
- Using a **declarative language (Rego)**

Think of OPA as **‚ÄúRBAC, ABAC, and all your security/business rules as code‚Äù**.

Typical use cases:

- API authorization
- Kubernetes pod admission security
- Terraform plan validation
- CI/CD checks (e.g., ‚Äúno image from `:latest` tag‚Äù)
- Data filtering (who can see what rows/fields)

---

## üß¨ **OPA Architecture & Components**

OPA has a few core concepts:

1. **Policy** ‚Äì written in **Rego**
2. **Data** ‚Äì JSON documents (e.g., user roles, resource metadata)
3. **Input** ‚Äì JSON representing the **current request** being evaluated
4. **Decision** ‚Äì JSON result computed by the policy

You typically run OPA:

- As a **sidecar** (next to your app)
- As a **daemon** (local)
- As a **central service** (via HTTP)
- As an **admission webhook** (for Kubernetes)

---

## üß™ **Rego Basics (The Policy Language)**

A minimal Rego policy file `example.rego`:

```rego
package authz

default allow = false

allow if {
  input.user.role == "admin"
}

allow if {
  input.user.id == input.resource.owner
}
```

- `package authz` ‚Äì namespace
- `default allow = false` ‚Äì deny by default
- `allow` rules ‚Äì return `true` if any rule body succeeds

If `allow` is `true`, your app can allow the action.

---

## üíª **OPA Outside Kubernetes (Local / Microservice Setup)**

Let‚Äôs do a **local hands-on** using the OPA binary + HTTP API.

### üìå **1. Run OPA Server Locally**

Download OPA (binary) and run:

```bash
wget https://openpolicyagent.org/download/opa_linux_amd64 -O opa
chmod +x opa
```

```bash
opa run --server
```

OPA will listen on `localhost:8181` by default.

```json
{
  "level": "warning",
  "msg": "OPA running with uid or gid 0. Running OPA with root privileges is not recommended.",
  "time": "2025-11-17T12:44:03Z"
}
```

---

### üìå **2. Create a Policy: `authz.rego`**

```rego
package authz

default allow = false

# Admins can do anything
allow if {
  input.user.role == "admin"
}

# Resource owners can read their own resource
allow if {
  input.action == "read"
  input.user.id == input.resource.owner
}

# Only managers can delete resources
allow if {
  input.action == "delete"
  input.user.role == "manager"
}
```

---

### üìå **3. Load Policy into OPA (`/v1/policies/`<policy_name>)**

Run:

```bash
curl -X PUT \
  --data-binary @<policy_file>.rego \
  <host>:8181/v1/policies/<policy_name>
```

```bash
curl -X PUT \
  --data-binary @authz.rego \
  localhost:8181/v1/policies/authz
```

OPA now knows this policy.

---

### üìå **4. Query the Policy via OPA API (`/v1/data/authz/allow`)**

#### üìù Example Input (user is owner, reading)

```json
{
  "input": {
    "user": { "id": "u1", "role": "user" },
    "resource": { "id": "r1", "owner": "u1" },
    "action": "read"
  }
}
```

Query:

```bash
curl -X POST localhost:8181/v1/data/authz/allow \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "user": { "id": "u1", "role": "user" },
      "resource": { "id": "r1", "owner": "u1" },
      "action": "read"
    }
  }'
```

Result:

```json
{ "result": true }
```

---

#### üìù Example Input (user NOT allowed to delete)

```bash
curl -X POST localhost:8181/v1/data/authz/allow \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "user": { "id": "u1", "role": "user" },
      "resource": { "id": "r1", "owner": "u2" },
      "action": "delete"
    }
  }'
```

Result:

```json
{ "result": false }
```

---

### üìå **5. Integrating OPA in Your Service (Pseudo-Code)**

#### üìù Example in pseudocode (e.g., Go/C#/Node conceptually):

```pseudo
function authorize(request):
    input = {
        "user": {
            "id": request.userId,
            "role": request.userRole
        },
        "resource": {
            "id": request.resourceId,
            "owner": request.resourceOwnerId
        },
        "action": request.action
    }

    opaResponse = http.post("http://opa:8181/v1/data/authz/allow", { "input": input })

    if opaResponse.result == true:
        return ALLOW
    else:
        return DENY
```

The **app remains dumb about rules**.
Rules live entirely in OPA/Rego.

---

## üß™ **Using Data Documents in OPA (RBAC Example)**

Let‚Äôs say you have a `data.json`:

```json
{
  "roles": {
    "alice": "admin",
    "bob": "user"
  },
  "permissions": {
    "admin": ["create", "read", "update", "delete"],
    "user": ["read"]
  }
}
```

Load into OPA:

```bash
curl -X PUT \
  --data-binary @data.json \
  localhost:8181/v1/data
```

Policy `rbac.rego`:

```rego
package rbac

default allow = false

allow {
  some permission
  user_role := data.roles[input.user]
  allowed := data.permissions[user_role]
  input.action == allowed[_]  # user action is in allowed list
}
```

Query:

```bash
curl -X POST localhost:8181/v1/data/rbac/allow \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "user": "bob",
      "action": "delete"
    }
  }'
```

Result:

```json
{ "result": false }
```

OPA uses **data + policy + input** to compute decisions.

---

## ‚ò∏Ô∏è **OPA in Kubernetes** (High Level)

You rarely run pure OPA directly in Kubernetes as a raw webhook.
Common patterns:

1. **OPA as a Validating Webhook** (custom admission controller)
2. **Gatekeeper** ‚Äì project that integrates OPA with CRDs and admission control

   - You define **Constraints** + **ConstraintTemplates**
   - Uses Rego under the hood
   - Easier for cluster admins

But since you mentioned ‚ÄúOPA with K8s‚Äù, let‚Äôs show a simplified OPA webhook scenario conceptually.

---

### üß™ **OPA as Kubernetes Admission Webhook** (Conceptual)

Flow:

```mermaid
sequenceDiagram
    participant kubectl
    participant APIServer
    participant OPAWebhook

    kubectl->>APIServer: apply Pod
    APIServer->>OPAWebhook: AdmissionReview (Pod JSON)
    OPAWebhook->>OPAWebhook: Evaluate Rego policies
    OPAWebhook-->>APIServer: AdmissionResponse (allow/deny)
    APIServer-->>kubectl: success or error
```

You:

- Deploy OPA + your policies as a Deployment + Service
- Configure a **ValidatingWebhookConfiguration** pointing to OPA‚Äôs service
- OPA evaluates Pod specs (`input` = AdmissionReview.request.object)

Example of `input` in Kubernetes scenario:

```json
{
  "kind": "AdmissionReview",
  "request": {
    "uid": "123",
    "kind": { "kind": "Pod" },
    "namespace": "dev",
    "object": {
      "metadata": { "name": "nginx" },
      "spec": { "containers": [ ... ] }
    },
    "userInfo": {
      "username": "john",
      "groups": ["devs"]
    }
  }
}
```

Your Rego policy might say:

```rego
package k8s.admission

default allow = false

deny[msg] {
  input.request.kind.kind == "Pod"
  container := input.request.object.spec.containers[_]
  container.image == "nginx:latest"
  msg := "Using :latest image tag is not allowed"
}

allow {
  not deny[_]
}
```

- If any `deny` rule matches ‚Üí AdmissionResponse = reject
- Otherwise ‚Üí allow

> In practice, people usually use **Gatekeeper** instead of wiring this all by hand.

---

## ‚öîÔ∏è **OPA Without Kubernetes vs With Kubernetes**

| Aspect            | Without Kubernetes             | With Kubernetes                                 |
| ----------------- | ------------------------------ | ----------------------------------------------- |
| Where OPA runs    | Local server, sidecar, daemon  | Cluster (Deployment/Pod)                        |
| Integration style | App calls OPA HTTP API         | API server calls OPA webhook                    |
| Input             | Custom JSON (your app shape)   | AdmissionReview object (Pod, Deployment, etc.)  |
| Main use          | Microservice authz, CLI checks | Admission control, policy enforcement for specs |
| Helper tools      | Just OPA + Rego                | Often Gatekeeper, Kyverno, etc.                 |

---

## ‚úÖ 10. Mental Model Cheat Sheet

- **OPA** = generic policy engine
- **Rego** = language for writing policies
- **Data** = JSON knowledge base
- **Input** = JSON describing the current request
- **Decision** = what your app/k8s uses to allow/deny/change things

Outside K8s ‚Üí Your **app** talks to OPA
Inside K8s ‚Üí The **API server** talks to OPA

---

If you want, next I can:

- Build a **mini end-to-end example**:

  - A simple HTTP API that calls OPA for authz (with full code, e.g., in C# or Node.js)

- Show **OPA unit testing** using `opa test`
- Show a **Kubernetes + Gatekeeper example** with a "no `:latest` image" constraint

Tell me which direction you want to go deeper: **microservice authz**, **Kubernetes admission**, or **RBAC-style policies**.
