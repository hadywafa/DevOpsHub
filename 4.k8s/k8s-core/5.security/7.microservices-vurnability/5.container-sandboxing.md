# ğŸ›¡ï¸ **Container Sandboxing in Kubernetes**

**(Simple Explanation + Full Picture + Real-World Tools + Hands-On)!**

---

Container sandboxing = **adding extra isolation layers** so that even if a container is compromised, the attacker **cannot escape to the host**.

Think of it as:  
ğŸ‘‰ _â€œRun this untrusted container, but keep it inside a super-secure jail.â€_

Traditional Linux containers (Docker, containerd CRI-O) rely on:

- namespaces
- cgroups
- seccomp
- AppArmor/SELinux
- capabilities

These are strong, but **not enough** for untrusted workloads like:

- user-supplied code (e.g., CI pipelines)
- ML training untrusted images
- SaaS multi-tenancy
- WebAssembly workloads

For these cases, Kubernetes uses **sandboxed runtimes**.

---

## ğŸŒ **The Big Picture â€” What Sandboxing Means**

A â€œsandboxedâ€ container is run inside an additional isolation layer:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Sandbox Technology  | Extra Isolation Layer                           |
| ------------------- | ----------------------------------------------- |
| **gVisor**          | Userspace kernel + syscall interception         |
| **Kata Containers** | Lightweight VM (per pod)                        |
| **Wasm / Wasmtime** | No syscalls at all; secure WebAssembly sandbox  |
| **Sysbox**          | Enhanced runc with extra isolation              |
| **Firecracker**     | MicroVM technology used by AWS Lambda / Fargate |

</div>

---

> These replace **runc** (the default OCI runtime).  
> Kubernetes groups these under **General Purpose Sandbox Runtimes** in CRI.

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452798317.png" alt="OpenSSL" style="width: 80%">
</div>

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452847955.png" alt="OpenSSL" style="width: 80%">
</div>

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452862127.png" alt="OpenSSL" style="width: 80%">
</div>

---

## ğŸ¤” **Why Do We Need Container Sandboxing?**

### Without sandboxing

Attacker escapes via:

- kernel vulnerabilities
- syscalls not blocked by seccomp
- misconfigured AppArmor
- Linux capabilities allowed by mistake
- privileged containers

### With sandboxing

Even if the container is compromised:

- kernel is NOT directly exposed
- syscalls are filtered or emulated
- host filesystem/kernel stays inaccessible
- container breakout becomes extremely difficult

---

## ğŸ§© **Kubernetes Sandboxing Options** (2025)

Kubernetes supports multiple sandboxing runtimes through **runtimeClass**.

### ğŸ”¹ 1. `gVisor` (Google)

**How it works:**  
gVisor implements a **userspace kernel** (â€œrunscâ€) that intercepts syscalls and handles them inside userspace, not the host kernel.

- Pod â†’ gVisor userspace kernel â†’ host
- Host kernel sees almost nothing from the container

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452058003.png" alt="OpenSSL" style="width: 80%">
</div>

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452078048.png" alt="OpenSSL" style="width: 80%">
</div>

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452193521.png" alt="OpenSSL" style="width: 80%">
</div>

---

**Pros:**

- âœ” Very strong syscall isolation
- âœ” Fast startup
- âœ” Great for multi-tenancy
- âœ” Supported by GKE, Anthos, containerd

**Cons:**

- âœ– Heavier than runc
- âœ– Some syscalls unsupported â†’ some apps break

---

### ğŸ”¹ 2. `Kata Containers`

**How it works:**

- used techniques of nested VMs (VM inside VM)
- Your container runs inside a short-lived VM.
- Each pod gets its own **lightweight microVM** (Firecracker/QEMU/NEMU).

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452399980.png" alt="OpenSSL" style="width: 80%">
</div>

---

**Pros:**

- âœ” VM-level isolation
- âœ” Excellent for hostile workloads
- âœ” Works with containerd & CRI-O

**Cons:**

- âœ– Higher memory usage
- âœ– Slightly slower startup
- âœ– More ops overhead
- âœ– Not supported by many of cloud providers

AWS Fargate and Lambda use similar isolation (Firecracker).

---

### ğŸ”¹ 3. `WebAssembly` (Wasm)

This is **2025-level hot topic**.

- No syscalls â†’ host kernel invisible
- Memory-safe
- Great for serverless workloads
- Sandbox by design

Examples:

- wasmtime
- containerd-wasm-shim
- Spin
- wasmCloud

**Pros:**

- âœ” Ultra-secure
- âœ” Binary size tiny
- âœ” Perfect for multi-tenant functions

**Cons:**

- âœ– Can't run normal Linux apps
- âœ– Ecosystem still growing

---

## âœğŸ» **How Kubernetes Selects a Sandbox Runtime**

Using **RuntimeClass**:

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: gvisor
handler: runsc
```

Then assign to a Pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sandboxed
spec:
  runtimeClassName: gvisor
  containers:
    - name: app
      image: nginx
```

> Thatâ€™s it.  
> Kubernetes schedules this pod using gVisor instead of runc.

---

> ğŸš¨ runtimeClassName is a field in the Pod spec, not the Container spec.

---

## ğŸ“ **1. Hands-On Sandboxing with gVisor**

### 1ï¸âƒ£ Install gVisor

```bash
sudo apt update && sudo apt install -y gvisor
```

### 2ï¸âƒ£ Enable in containerd

Edit:

```ini
/etc/containerd/config.toml
```

Add:

```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc]
  runtime_type = "io.containerd.runsc.v1"
```

Reload:

```bash
sudo systemctl restart containerd
```

### 3ï¸âƒ£ Create a RuntimeClass

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: gvisor
handler: runsc
```

Apply:

```bash
kubectl apply -f runtimeclass.yaml
```

### 4ï¸âƒ£ Run a sandboxed pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secure-nginx
spec:
  runtimeClassName: gvisor
  containers:
    - name: nginx
      image: nginx
```

Apply:

```bash
kubectl apply -f nginx-gvisor.yaml
```

### 5ï¸âƒ£ Verify itâ€™s using gVisor

On the node:

```bash
ps aux | grep runsc
```

Or see detailed runtime:

```bash
kubectl get pod secure-nginx -o wide
```

---

<div align="center" style="background-color:#F1F1F1; border-radius: 10px; border: 2px solid">
  <img src="image/1763452989823.png" alt="OpenSSL" style="width: 80%">
</div>

---

## ğŸ“ **2. Hands-On Sandboxing with Kata Containers**

### 1ï¸âƒ£ Install Kata

```bash
sudo apt install kata-runtime
```

### 2ï¸âƒ£ Add Kata to containerd

Add to containerd:

```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata]
  runtime_type = "io.containerd.kata.v2"
```

Reload:

```bash
sudo systemctl restart containerd
```

### 3ï¸âƒ£ Create a RuntimeClass

RuntimeClass:

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: kata
handler: kata
```

Apply:

```bash
kubectl apply -f runtimeclass.yaml
```

### 4ï¸âƒ£ Run a sandboxed pod

Pod:

```yaml
spec:
  runtimeClassName: kata
```

Apply:

```bash
kubectl apply -f nginx-kata.yaml
```

### 5ï¸âƒ£ Verify itâ€™s using Kata

On the node:

```bash
ps aux | grep kata
```

Or see detailed runtime:

```bash
kubectl get pod secure-nginx -o wide
```

---

Boom â†’ container runs in a VM.

---

## âš”ï¸ **Container Sandboxing vs Traditional Security**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature                | runc    | gVisor | Kata    | Wasm             |
| ---------------------- | ------- | ------ | ------- | ---------------- |
| Runs in VM?            | âŒ      | âŒ     | âœ…      | âŒ (own sandbox) |
| Syscall isolation      | Low     | High   | Highest | No syscalls      |
| Speed                  | Fastest | Fast   | Medium  | Fast             |
| Workload compatibility | 100%    | ~80%   | 100%    | Low              |

</div>

---

## ğŸ¯ **When to Use Which?**

### ğŸ‘‰ğŸ» **Use gVisor for:**

- CI pipelines running untrusted code
- Multi-tenant SaaS
- Enterprise clusters needing syscall isolation

### ğŸ‘‰ğŸ» **Use Kata for:**

- Zero-trust clusters
- Regulated industries (finance, healthcare)
- Hosting third-party workloads

### ğŸ‘‰ğŸ» **Use WebAssembly for:**

- Serverless functions
- Tiny workloads
- High-isolation multi-tenancy

---

## ğŸ“Œ **CKS Exam Must-Know Summary**

- âœ” Sandboxing adds isolation on top of namespaces/cgroups
- âœ” Runtimes: **gVisor, Kata Containers, Firecracker, Wasm**
- âœ” Kubernetes uses **RuntimeClass** to choose runtime
- âœ” Sandboxing protects **host kernel** from container breakout
- âœ” Perfect for multi-tenant workloads
