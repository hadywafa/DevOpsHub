# üîí **Authorization (AuthZ) in Kubernetes ‚Äî Deep Dive for Admins**

> _‚ÄúAuthN asks: Who are you? üîê ‚Äî AuthZ asks: What can you do?‚Äù_

---

## üß© **What Is Authorization in Kubernetes?**

**Authorization (AuthZ)** in Kubernetes is the process of determining **whether an authenticated request is allowed** to perform a specific operation on a resource.

After Authentication (AuthN) succeeds, the API Server knows **who** is making the request (like `system:serviceaccount:dev:webapp-sa`).
Then it checks:

> ‚ÄúIs this identity allowed to perform this action (`verb`) on this resource (`object`) in this scope (`namespace`)?‚Äù

---

## üß† **The Big Picture: API Server Decision Pipeline**

Here‚Äôs how a single API request is processed inside Kubernetes:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
    participant Client as User / Pod / Tool
    participant APIServer as API Server
    participant AuthN as Authentication
    participant AuthZ as Authorization
    participant Admission as Admission Controllers
    participant etcd as etcd (Cluster State)

    Client->>APIServer: HTTPS Request (e.g. kubectl get pods)
    APIServer->>AuthN: Validate identity (cert, token, etc.)
    AuthN-->>APIServer: ‚úÖ User = system:serviceaccount:dev:webapp-sa
    APIServer->>AuthZ: Check if allowed (verb + resource + namespace)
    AuthZ-->>APIServer: ‚úÖ Allow or ‚ùå Deny
    APIServer->>Admission: Validate / mutate request
    Admission->>etcd: Persist changes
    etcd-->>Client: Response (200 OK or 403 Forbidden)
```

</div>

---

> So, **AuthZ** is the **second gate** that determines whether an authenticated identity can proceed.

---

## ‚öôÔ∏è **Authorization Inputs ‚Äî What Kubernetes Evaluates**

When the API Server performs authorization, it checks:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Parameter         | Description                  | Example                                    |
| ----------------- | ---------------------------- | ------------------------------------------ |
| **User/Group**    | Who made the request         | `system:serviceaccount:dev:webapp-sa`      |
| **Verb**          | The action being attempted   | `get`, `list`, `create`, `delete`, `patch` |
| **API Group**     | Which API resource group     | `""` (core), `apps`, `batch`, etc.         |
| **Resource**      | The type of object           | `pods`, `deployments`, `configmaps`        |
| **Namespace**     | Where it applies             | `dev`, `prod`                              |
| **Resource Name** | (Optional) Specific resource | `webapp-pod`                               |
| **Subresource**   | (Optional) Special endpoint  | `pods/log`                                 |

</div>

---

Example request:

```ini
User: system:serviceaccount:dev:webapp-sa
Verb: get
API Group: ""
Resource: pods
Namespace: dev
ResourceName: mypod
```

---

## üß© **Kubernetes Authorization Modes**

Kubernetes can use multiple **authorization modules** simultaneously.
They‚Äôre configured in the API server with:

```bash
--authorization-mode=Node,RBAC,Webhook
```

Each module checks the request; if any authorizer **allows** it, the request passes.

Let‚Äôs look at the major ones üëá

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Mode            | Description                                            | Common Use                        |
| --------------- | ------------------------------------------------------ | --------------------------------- |
| **RBAC**        | Role-Based Access Control (default in modern clusters) | Fine-grained permissions          |
| **ABAC**        | Attribute-Based Access Control (deprecated)            | Legacy static rules via JSON      |
| **Webhook**     | External API for dynamic authorization decisions       | Integrate with enterprise systems |
| **Node**        | Special authorizer for kubelets                        | Node-to-API communication         |
| **AlwaysAllow** | Allows all requests (unsafe, testing only)             | Development                       |
| **AlwaysDeny**  | Denies all requests (testing only)                     | Development                       |

</div>

---

> ‚úÖ In production clusters, `RBAC` + `Node` (and sometimes `Webhook`) are standard.

---

## üß± **RBAC ‚Äî The Primary Authorizer**

As you learned, **RBAC (Role-Based Access Control)** is the default and most flexible authorizer.

It matches the request against:

- `Role` or `ClusterRole` rules
- `RoleBinding` or `ClusterRoleBinding` assignments

If a matching rule is found ‚Üí ‚úÖ allow
Otherwise ‚Üí ‚ùå forbidden

### Example Request Check

| Input                                                                     |
| ------------------------------------------------------------------------- |
| **User:** `system:serviceaccount:dev:webapp-sa`                           |
| **Action:** `list pods`                                                   |
| **RBAC Rule:** `apiGroups=[""], resources=["pods"], verbs=["get","list"]` |

‚úÖ Allowed if a RoleBinding or ClusterRoleBinding grants this permission.

---

## üß± **Node Authorization (for Kubelets)**

The **Node Authorizer** handles requests made by the **kubelet** running on each node.

- Node identity ‚Üí `system:node:<nodename>`
- Belongs to ‚Üí `system:nodes` group

It allows limited operations like:

- Reading/writing Pod status for Pods scheduled on that node
- Reading ConfigMaps or Secrets only for its Pods

‚úÖ Prevents one node from reading Secrets belonging to Pods on another node.

---

## üß© **Webhook Authorization**

For enterprise or custom setups, you can delegate authorization decisions to an **external service**.

Example API server flags:

```bash
--authorization-mode=Webhook,RBAC
--authorization-webhook-config-file=/etc/kubernetes/webhook-config.yaml
```

Webhook sends a JSON payload:

```json
{
  "apiVersion": "authorization.k8s.io/v1",
  "kind": "SubjectAccessReview",
  "spec": {
    "user": "john@example.com",
    "resourceAttributes": {
      "namespace": "dev",
      "verb": "get",
      "resource": "pods"
    }
  }
}
```

External service replies:

```json
{
  "apiVersion": "authorization.k8s.io/v1",
  "kind": "SubjectAccessReview",
  "status": {
    "allowed": true,
    "reason": "User john@example.com is in group devs"
  }
}
```

‚úÖ Great for plugging Kubernetes into central corporate policy engines like **OPA (Open Policy Agent)** or **AuthZ microservices**.

---

## üß† **Authorization for Kubelet-to-API Communication**

- Each node‚Äôs kubelet must authenticate and then be authorized to act on cluster resources.
- Node authorizer ensures:

  - Node A cannot read Pods from Node B
  - Node can only modify its own status
  - Node can fetch Secrets/ConfigMaps **only** for its running Pods

‚úÖ This prevents lateral privilege escalation between nodes.

---

## üß© **The ‚ÄúSubjectAccessReview‚Äù API**

You can programmatically check authorization with the Kubernetes **SubjectAccessReview API**.

Example:

```bash
kubectl auth can-i create pods -n dev
```

Under the hood, this executes a SubjectAccessReview object:

```yaml
apiVersion: authorization.k8s.io/v1
kind: SubjectAccessReview
spec:
  user: system:serviceaccount:dev:webapp-sa
  resourceAttributes:
    namespace: dev
    verb: create
    resource: pods
```

Response:

```yaml
status:
  allowed: true
  reason: "RoleBinding grants create on pods in dev"
```

---

## üß© **Authorization Debugging Tools**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Command                                            | Description                    |
| -------------------------------------------------- | ------------------------------ |
| `kubectl auth can-i <verb> <resource> -n <ns>`     | Check current user permissions |
| `kubectl auth can-i --as <user> <verb> <resource>` | Impersonate another user       |
| `kubectl auth reconcile -f role.yaml`              | Create or update roles safely  |
| `kubectl get clusterrolebindings`                  | List cluster-level grants      |
| `kubectl describe rolebinding <name>`              | Inspect namespace bindings     |

</div>

---

Example:

```bash
kubectl auth can-i get pods --as system:serviceaccount:dev:webapp-sa -n dev
```

‚úÖ Quickly confirms whether AuthZ would allow the action.

---

## üß† **Common Real-World Authorization Flows**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Scenario                     | AuthN                           | AuthZ                        |
| ---------------------------- | ------------------------------- | ---------------------------- |
| Pod accessing Kubernetes API | ServiceAccount token            | RBAC RoleBinding             |
| `kubectl` user from laptop   | X.509 certificate or OIDC token | ClusterRoleBinding           |
| Node updating its Pod status | kubelet certificate             | Node authorizer              |
| Jenkins deploying manifests  | ServiceAccount token            | ClusterRoleBinding (limited) |

</div>

---

## üß© **Common Authorization Errors**

### ‚ùå ‚ÄúForbidden‚Äù error

```ini
Error from server (Forbidden): User "system:serviceaccount:dev:webapp-sa" cannot list resource "pods" in API group "" in the namespace "dev"
```

**Cause:** No RoleBinding exists granting that permission.
**Fix:** Bind appropriate Role or ClusterRole.

### ‚ö†Ô∏è ‚ÄúRBAC Deny‚Äù confusion

If your `--authorization-mode` includes multiple authorizers (e.g., `RBAC,Node,Webhook`),
Kubernetes allows a request if **any one** authorizer approves it.

---

## üß© **Authorization Evaluation Logic**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
flowchart TD
    A[Authenticated Request] --> B{AuthZ Check: RBAC / Node / Webhook}
    B -->|RBAC| C[Check Roles & Bindings]
    B -->|Node| D[Check kubelet node rules]
    B -->|Webhook| E[External policy service]
    C --> F{Allowed?}
    D --> F
    E --> F
    F -->|‚úÖ Yes| G[Proceed to Admission Controllers]
    F -->|‚ùå No| H[Reject: 403 Forbidden]
```

</div>

---

## ‚öñÔ∏è **Quick Comparison ‚Äî AuthN vs AuthZ**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept                    | Question Answered                                   | Examples                               |
| -------------------------- | --------------------------------------------------- | -------------------------------------- |
| **AuthN (Authentication)** | Who are you?                                        | ServiceAccount, user cert, OIDC login  |
| **AuthZ (Authorization)**  | What can you do?                                    | RBAC, Node, Webhook                    |
| **Admission Control**      | Should this object creation be allowed or modified? | PodSecurity, ResourceQuota, LimitRange |

</div>

---

## ‚úÖ **Key Takeaways**

- ‚úÖ **AuthZ** is the decision layer that follows successful AuthN
- ‚úÖ Controlled primarily through **RBAC** in Kubernetes
- ‚úÖ Multiple authorizers can coexist (`RBAC`, `Node`, `Webhook`)
- ‚úÖ Use `kubectl auth can-i` to test access
- ‚úÖ ‚ÄúDeny‚Äù means no authorizer granted permission
- ‚úÖ Implement least privilege ‚Äî grant only what‚Äôs needed
