# ğŸ—‚ï¸ Kubernetes ABAC Authorizer (Attribute-Based Access Control)

_The legacy, JSON-file-based authorization system â€” now replaced by RBAC, but still important to understand._

---

## ğŸ“– **What is ABAC?**

**ABAC = Attribute-Based Access Control.**
Kubernetes makes authorization decisions based on **attributes** attached to:

- the **user**
- the **group**
- the **requested resource**
- the **namespace**
- the **action/verb**

If a request matches **ANY** ABAC rule â†’ request **ALLOWED**.
If no rules match â†’ **DENIED**.

There are **no deny rules** and **no priorities**.

---

## ğŸ—ï¸ **How ABAC Works**

ABAC requires:

1. A **policy file** containing JSON rules
2. `kube-apiserver` running with:

```bash
--authorization-mode=ABAC
--authorization-policy-file=/etc/kubernetes/abac-policy.jsonl
```

- âœ” Rules are evaluated **line by line**
- âœ” First match â†’ â€œALLOWâ€
- âŒ No dynamic updates
- âŒ Must restart `kube-apiserver` to apply changes

---

## ğŸ§¾ **ABAC Policy File Formats**

ABAC historically supported **two formats**.

---

## ğŸŸ¦ A. **Modern & Supported Format (v1) â€” The Flat JSON Rule**

This is the **only format supported today** on modern Kubernetes clusters:

```json
{
  "apiVersion": "abac.authorization.kubernetes.io/v1",
  "kind": "Policy",
  "user": "alice",
  "namespace": "dev",
  "resource": "pods",
  "verbs": ["get", "list"]
}
```

### Supported Fields

| Attribute         | Meaning                                  |
| ----------------- | ---------------------------------------- |
| `user`            | Exact username                           |
| `group`           | One group name                           |
| `resource`        | e.g., pods, deployments                  |
| `namespace`       | Namespace restriction                    |
| `nonResourcePath` | e.g., `/metrics`                         |
| `verbs`           | ["get", "list", "create", "delete", ...] |
| `apiGroup`        | "", "apps", "\*"                         |

---

## ğŸŸ¥ B. **Legacy & Deprecated Format (v1beta1) â€” With `spec` Field**

You may see this in old blogs or very old clusters:

```json
{
  "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
  "kind": "Policy",
  "spec": {
    "user": "system:serviceaccount:default:john",
    "namespace": "default",
    "resource": "pods",
    "apiGroup": "*",
    "readonly": true
  }
}
```

### â—Important Notes

- **`v1beta1` is deprecated and removed in modern Kubernetes.**
- Modern clusters **ignore** any rule using `spec`.
- `readonly: true` â‰ˆ verbs `["get", "list", "watch"]`.

### Why this existed?

Early Kubernetes (pre-v1.6) experimented with ABAC as â€œAPI-like objects.â€
The idea was abandoned â†’ RBAC introduced â†’ ABAC frozen as legacy.

---

## ğŸ‘€ **ABAC Rule Evaluation Flow**

A request:

```bash
kubectl create deployment nginx -n dev
```

Kubernetes extracts attributes:

| Attribute | Value                           |
| --------- | ------------------------------- |
| user      | from CN in client cert or token |
| groups    | from cert O fields              |
| verb      | "create"                        |
| resource  | deployments                     |
| namespace | dev                             |

Then it checks each ABAC rule:

- If ALL specified fields match â†’ allow
- If no rule matches â†’ deny

ABAC works like a firewall without deny rules.

---

## ğŸ§¬ **Extracting User & Group from Client Certificate**

Since ABAC relies heavily on **CN** and **O** attributes:

```bash
openssl x509 -in client.crt -text -noout | grep -A1 "Subject:"
```

Typical structure:

- CN = username
- O = group(s)

Example:

```ini
Subject: CN=dev-user, O=dev-team, O=qa-team
```

This means:

- user: `dev-user`
- groups: `["dev-team", "qa-team"]`

---

## ğŸ§© **Example ABAC Rules**

**Allow user alice to list pods in dev namespace:**

```json
{ "user": "alice", "resource": "pods", "namespace": "dev", "verbs": ["get", "list"] }
```

### Allow anyone in group dev-team to create deployments:

```json
{ "group": "dev-team", "resource": "deployments", "verbs": ["create"] }
```

### Allow all authenticated users read-only access to all resources:

```json
{ "group": "system:authenticated", "resource": "*", "namespace": "*", "verbs": ["get", "list", "watch"] }
```

---

## ğŸ“Œ **ABAC vs RBAC â€” Quick Comparison**

| Feature                     | ABAC              | RBAC                 |
| --------------------------- | ----------------- | -------------------- |
| Stored in Kubernetes?       | âŒ No (file only) | âœ”ï¸ Yes (API objects) |
| Namespace delegation        | âŒ No             | âœ”ï¸ Yes               |
| Requires API server restart | âœ”ï¸ Yes            | âŒ No                |
| Scalable for large orgs     | âŒ No             | âœ”ï¸ Yes               |
| Deny rules                  | âŒ No             | âŒ No                |
| Cloud providers support     | âŒ No             | âœ”ï¸ Yes               |
| Best practice today         | âŒ No             | âœ”ï¸ Yes               |

**Conclusion:**

> ABAC is legacy. RBAC is the modern and recommended authorization system.

---

## ğŸ§¨ **Why ABAC Is No Longer Used**

ABAC has several major drawbacks:

- âŒ Static file required
- âŒ No atomic rule updates
- âŒ Must restart API server
- âŒ Can't delegate control to namespaces
- âŒ No audit-friendly model
- âŒ Unmanageable at scale
- âŒ Not supported on EKS, AKS, or GKE

RBAC solves all these issues.

---

## ğŸ›‘ **Should You Ever Use ABAC Today?**

**Absolutely not**, unless:

- Youâ€™re studying for exams
- Working on a museum-grade legacy cluster
- Doing academic research

RBAC or Webhook-based authorizers are the modern choices.

---

## ğŸ **Final Summary**

ABAC is Kubernetesâ€™ original authorization system.
It uses JSON rules stored in a file, matched against user/group/verb/resource attributes.

There are TWO formats:

### âœ” Modern, stable:

Flat JSON with `verbs` (v1)

### âŒ Deprecated, unsupported:

`spec:` format with `readonly` (v1beta1)

ABAC is fully replaced by RBAC and exists today only for legacy compatibility.
