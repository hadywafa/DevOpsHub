# üß± **Kubernetes RBAC (Role-Based Access Control) ‚Äî Deep Dive for Admins**

> _‚ÄúAuthN proves **who** you are ‚Äî RBAC decides **what** you‚Äôre allowed to do.‚Äù_

---

## üß© **What Is RBAC?**

**RBAC** (Role-Based Access Control) is Kubernetes‚Äô **authorization system** that defines what operations a user, Pod, or external tool can perform on which resources.

It answers:

> ‚ÄúIs this authenticated identity allowed to perform this action on this resource?‚Äù

Example:

> Can `system:serviceaccount:dev:webapp-sa` list Pods in namespace `dev`?

RBAC rules are evaluated by the **API Server** **after authentication** succeeds.

---

## üß† **RBAC Core Components Overview**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept                | Purpose                                                                           | Scope         | Example                               |
| ---------------------- | --------------------------------------------------------------------------------- | ------------- | ------------------------------------- |
| **Role**               | Defines permissions within a specific **namespace**                               | Namespaced    | Can list Pods in `dev`                |
| **ClusterRole**        | Defines permissions cluster-wide (or can be reused across namespaces)             | Cluster-level | Can list Nodes, manage all namespaces |
| **RoleBinding**        | Grants a Role‚Äôs permissions to a **subject** (user, group, SA) within a namespace | Namespaced    | Binds a Role to a ServiceAccount      |
| **ClusterRoleBinding** | Grants a ClusterRole‚Äôs permissions to a **subject** cluster-wide                  | Cluster-level | Give admins full access               |

</div>

---

<div align="center">
  <img src="https://kubernetes.io/docs/reference/access-authn-authz/images/authorization-rbac.svg" width="85%" alt=""/>
</div>

---

## ‚öîÔ∏è **Roles vs ClusterRoles**

Let‚Äôs compare them side by side üëá

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature                                            | **Role**           | **ClusterRole**                       |
| -------------------------------------------------- | ------------------ | ------------------------------------- |
| Scope                                              | Specific Namespace | Entire Cluster                        |
| Can manage namespaced resources?                   | ‚úÖ Yes             | ‚úÖ Yes                                |
| Can manage non-namespaced resources (e.g., Nodes)? | ‚ùå No              | ‚úÖ Yes                                |
| YAML Kind                                          | `Role`             | `ClusterRole`                         |
| Used with Binding                                  | `RoleBinding`      | `ClusterRoleBinding` (or RoleBinding) |

</div>

---

### 1Ô∏è‚É£ Example: Role (Namespace-Scoped)

**using yaml:**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: pod-reader
rules:
  - apiGroups: [""]
    resources: ["pods", "services"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list"]
```

‚úÖ Allows reading Pods only in namespace `dev`.

**using kubectl dry-run:**

```bash
kubectl create role pod-reader \
  --namespace=dev \
  --verb=get,list \
  --resource=pods,services,deployments.apps \
  --dry-run=client -o yaml > pod-reader.yaml
```

```bash
kubectl apply -f pod-reader.yaml
```

‚úÖ Same result.

---

### 2Ô∏è‚É£ Example: ClusterRole (Cluster-Scoped)

**using yaml:**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-admin
rules:
  - apiGroups: ["*"]
    resources: ["*"]
    verbs: ["*"]
```

‚úÖ Can do _anything_ on _any resource_ in _any namespace_.

**using kubectl dry-run:**

```bash
kubectl create clusterrole cluster-admin \
  --verb="*" \
  --resource="*" \
  --dry-run=client -o yaml > cluster-admin.yaml
```

```bash
kubectl apply -f cluster-admin.yaml
```

‚úÖ Same result.

---

## ‚öîÔ∏è **RoleBinding vs ClusterRoleBinding**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature          | **RoleBinding**                         | **ClusterRoleBinding**                   |
| ---------------- | --------------------------------------- | ---------------------------------------- |
| Scope            | Namespace-specific                      | Cluster-wide                             |
| Links to         | Role or ClusterRole                     | ClusterRole only                         |
| Grants access to | A specific namespace                    | All namespaces                           |
| Example usage    | Give a Pod read access in one namespace | Give DevOps team admin access everywhere |

</div>

---

### 1Ô∏è‚É£ Example: RoleBinding (Namespace-Scoped)

**using yaml:**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: dev
subjects:
  - kind: ServiceAccount
    name: webapp-sa
    namespace: dev
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

‚úÖ Binds `pod-reader` Role to `webapp-sa` in the same namespace.

**using kubectl dry-run:**

```bash
kubectl create rolebinding read-pods \
  --role=pod-reader \
  --serviceaccount=dev:webapp-sa \
  --namespace=dev \
  --dry-run=client -o yaml > read-pods.yaml
```

```bash
kubectl apply -f read-pods.yaml
```

‚úÖ Same result.

---

### 2Ô∏è‚É£ Example: ClusterRoleBinding (Cluster-Wide)

**using yaml:**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-binding
subjects:
  - kind: User
    name: dev@example.com
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
```

‚úÖ Gives user `dev@example.com` full cluster-admin privileges.

**using kubectl dry-run:**

```bash
kubectl create clusterrolebinding admin-binding \
  --user=dev@example.com \
  --clusterrole=cluster-admin \
  --dry-run=client -o yaml > admin-binding.yaml
```

```bash
kubectl apply -f admin-binding.yaml
```

‚úÖ Same result.

---

### ‚ÅâÔ∏è **RBAC Subjects (Who Gets Access)**

RBAC **subjects** define _who_ is being granted access.

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Subject Type          | Description                                          | Example Identifier                    |
| --------------------- | ---------------------------------------------------- | ------------------------------------- |
| üë§ **User**           | Human or service identity (from OIDC, cert CN, etc.) | `dev@example.com`                     |
| üë• **Group**          | Collection of users                                  | `system:masters`, `dev-team`          |
| ü§ñ **ServiceAccount** | Non-human identity within Kubernetes                 | `system:serviceaccount:dev:webapp-sa` |

</div>

Example ServiceAccount subject inside RoleBinding:

```yaml
subjects:
  - kind: ServiceAccount
    name: webapp-sa
    namespace: dev
```

Example User subject inside RoleBinding/ClusterRoleBinding:

```yaml
subjects:
  - kind: User
    name: dev@example.com
    apiGroup: rbac.authorization.k8s.io
```

Example Group subject inside RoleBinding/ClusterRoleBinding:

```yaml
subjects:
  - kind: Group
    name: dev-team
    apiGroup: rbac.authorization.k8s.io
```

---

## üß≠ **Real-World RBAC Patterns**

### üß© Pattern 1 ‚Äî **Namespace Isolation**

Each app team gets its own namespace + Role/RoleBinding.

```yaml
Role: can manage Pods, Deployments, Services in their namespace only
RoleBinding: binds Role to the team‚Äôs ServiceAccount
```

‚úÖ Prevents cross-namespace interference.

---

### üß© Pattern 2 ‚Äî **Centralized Read-Only ClusterRole**

Create one `ClusterRole` like `view-all`:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: view-all
rules:
  - apiGroups: [""]
    resources: ["pods", "services", "configmaps"]
    verbs: ["get", "list", "watch"]
```

Then bind it to multiple namespaces using `RoleBinding`:

```yaml
kind: RoleBinding
metadata:
  name: viewer
  namespace: dev
roleRef:
  kind: ClusterRole
  name: view-all
  apiGroup: rbac.authorization.k8s.io
subjects:
  - kind: ServiceAccount
    name: monitor-sa
    namespace: dev
```

‚úÖ Reuse one `ClusterRole` across many namespaces.

---

### üß© Pattern 3 ‚Äî **External CI/CD Access**

External automation tools (GitHub Actions, Jenkins, ArgoCD) use:

- A **ServiceAccount**
- Bound to a **ClusterRole** or `Role` depending on required scope
- Token manually generated via:

  ```bash
  kubectl create token cicd-bot -n dev
  ```

‚úÖ Allows external tools to `kubectl apply` safely using least privilege.

---

## ‚öôÔ∏è **How Kubernetes Evaluates RBAC**

When a request reaches the API Server:

1. ‚úÖ AuthN identifies the user/SA (e.g., `system:serviceaccount:dev:webapp-sa`)
2. ‚úÖ AuthZ (RBAC) checks:

   - **Verb** ‚Üí what action? (`get`, `list`, `delete`)
   - **Resource** ‚Üí which object? (`pods`, `deployments`)
   - **Namespace** ‚Üí where?
   - **Binding** ‚Üí does any RoleBinding or ClusterRoleBinding grant that permission?

If yes ‚Üí ‚úÖ Allowed
If not ‚Üí ‚ùå Forbidden (`Error from server (Forbidden)`)

---

## üß™ **Debugging RBAC Access**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Command                                                                        | Purpose                               |
| ------------------------------------------------------------------------------ | ------------------------------------- |
| `kubectl auth can-i list pods -n dev`                                          | Check if you can list Pods            |
| `kubectl auth can-i delete nodes`                                              | Check cluster-level permissions       |
| `kubectl auth can-i --as system:serviceaccount:dev:webapp-sa list pods -n dev` | Simulate another identity             |
| `kubectl get clusterrolebindings`                                              | List all cluster role bindings        |
| `kubectl describe rolebinding <name>`                                          | Inspect role-to-subject relationships |

</div>

---

## üî¥ **Common RBAC Troubleshooting Patterns**

### ‚ùå Error: ‚ÄúForbidden: User ... cannot list resource ...‚Äù

**Fix:**

- Check `kubectl auth whoami`
- Inspect related Role/RoleBinding
- Verify correct namespace
- Ensure subject kind/name match exactly

### ‚ö†Ô∏è Mistake: Using `ClusterRoleBinding` when you meant namespaced Role

- Over-grants access to all namespaces
- Fix: Use RoleBinding bound to Role in that namespace

### ‚öôÔ∏è Debugging tip:

```bash
kubectl get rolebinding,clusterrolebinding -A | grep <subject-name>
```

### üö´ Mistake: Edit Pod Service Account

you can't edit service account for existing Pod, you must delete and recreate the pod:

```bash
kubectl delete pod <pod-name>
kubectl create pod <pod-name> --image=nginx --restart=Never --serviceaccount=<service-account-name>
```

> üéÅ **Tip:** For Deployments you can change the `spec.template.spec.serviceAccountName` without deleting and recreating the Deployment, because the Deployment controller will trigger a new rollout with the new service account.

### üö´ Mistake: `automountServiceAccountToken: false`

this prevents the service account from being mounted into the Pod, so the Pod can‚Äôt access the service account secret.

> üéÅ **Tip:** You can fix this by setting `automountServiceAccountToken: true` and then deleting and recreating the Pod.

---

## üß© **Default ClusterRoles in Kubernetes**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Default ClusterRole | Description                             |
| ------------------- | --------------------------------------- |
| `cluster-admin`     | Full access to everything               |
| `admin`             | Namespace admin access                  |
| `edit`              | Can modify most objects in namespace    |
| `view`              | Read-only namespace access              |
| `system:node`       | Used by kubelets                        |
| `system:discovery`  | Used for unauthenticated discovery APIs |

</div>

You can inspect all:

```bash
kubectl get clusterroles
kubectl describe clusterrole admin
```

---

## üé® **RBAC Evaluation Diagram**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
flowchart TD
    A["API Request (Verb + Resource)"] --> B{Authenticated User/SA}
    B --> C{Check RoleBindings in Namespace}
    B --> D{Check ClusterRoleBindings}
    C --> E[Allowed if matching rule found]
    D --> E
    E -->|No match| F[Forbidden ‚ùå]
    E -->|Match| G[Allowed ‚úÖ]
```

</div>

---

## ‚úÖ **Summary Table**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept                | Description                                       | Example                               |
| ---------------------- | ------------------------------------------------- | ------------------------------------- |
| **Role**               | Namespace-specific permissions                    | Read Pods in `dev`                    |
| **ClusterRole**        | Cluster-wide permissions                          | Admin across all namespaces           |
| **RoleBinding**        | Connects Role/ClusterRole to subject in namespace | `webapp-sa` ‚Üí `pod-reader`            |
| **ClusterRoleBinding** | Connects ClusterRole to subject across cluster    | `dev@example.com` ‚Üí `cluster-admin`   |
| **Subjects**           | User, Group, or ServiceAccount                    | `system:serviceaccount:dev:webapp-sa` |
| **Check Access**       | `kubectl auth can-i`                              | Test permissions                      |

</div>

---

## üèÅ **Key Takeaways**

- ‚úÖ **AuthN** identifies, **RBAC** authorizes
- ‚úÖ **Roles** are namespaced; **ClusterRoles** are global
- ‚úÖ **Bindings** connect identities (subjects) to roles
- ‚úÖ Always follow **least privilege** principle
- ‚úÖ Use `kubectl auth can-i` to test
- ‚úÖ Keep RBAC YAMLs under version control

---

Would you like the **next section** to cover **advanced RBAC strategies** ‚Äî like:

- Aggregated ClusterRoles (`rbac.authorization.k8s.io/aggregate-to-*`)
- Impersonation (`--as`, `--as-group`)
- and Dynamic access troubleshooting patterns (via `audit logs` and `who-can`)
  ?

That‚Äôs where senior-level Kubernetes admins really shine.
