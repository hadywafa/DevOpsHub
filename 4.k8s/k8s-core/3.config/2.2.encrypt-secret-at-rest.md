# ğŸ” **Encrypting Secret Data at Rest in K8s**

_The complete hands-on guide: what, why, how, with real examples + encryption providers._

---

## ğŸ“– What Does â€œSecrets Encryption at Restâ€ Mean?

Kubernetes _always_ stores Secrets in **etcd**.
By default (unless enabled manually), etcd stores values **Base64-encoded, not encrypted**.

Meaning:

- If someone gains etcd access
- Or disk-level access
- Or performs a etcd backup snapshot

ğŸ‘‰ They can read your Secret plaintext.

To prevent this, Kubernetes supports **Encryption at Rest** using the API server.

---

## â“ Why Do We Encrypt Secrets at Rest?

### 2.1. Threat Scenarios

- A rogue admin gets `/var/lib/etcd/member/snap/db`
- A backup system stores etcd snapshots in S3 unencrypted
- A hostile node has filesystem access
- A security audit requires data encryption (PCI DSS, HIPAA, SOC2)

### 2.2. Protection Level

Encryption at Rest in Kubernetes protects:

- âœ”ï¸ Kubernetes Secrets
- âœ”ï¸ ConfigMaps (if configured)
- âœ”ï¸ Deployment manifests that embed secrets
- âœ”ï¸ TokenRequest API objects

It does NOT protect:

- âŒ Secrets in RAM
- âŒ Secrets transmitted to Pods
- âŒ Secrets in environment variables

---

## ğŸš¦ How K8s Secrets Encryption Works (Architecture)

```mermaid
flowchart LR
    A[Client kubectl create secret] --> B[Kube-API Server]
    B -->|Encrypt via provider| C["Encryption Provider (AES, KMS, YCSB, etc.)"]
    C --> D[Write encrypted data to etcd]

    E[Client GET secret] --> B
    B -->|Decrypt via provider| C
    C --> F[Return plaintext secret]
```

ğŸ’¡ **Encryption is only applied at the API server layer.**  
etcd never encrypts itself. API server encrypts/decrypts on-the-fly.

---

## ğŸ› ï¸ Encryption Providers (Latest Kubernetes 1.30+)

Kubernetes supports:

| Provider      | Description                                                                       |
| ------------- | --------------------------------------------------------------------------------- |
| **AES-CBC**   | Older, still supported, but CBC has risks (padding oracle attacks)                |
| **AES-GCM**   | Modern, authenticated encryption; RECOMMENDED                                     |
| **Secretbox** | Uses XSalsa20+Poly1305                                                            |
| **KMS v2**    | Cloud KMS integration (AWS KMS, GCP KMS, Azure KeyVault) with encryption envelope |
| **Identity**  | No encryption (plaintext â€“ used during migration)                                 |

**Best practice (2025):**

ğŸ‘‰ Use **KMS v2** in production  
ğŸ‘‰ Use **AES-GCM** in clusters without cloud KMS

---

## ğŸ“ƒ EncryptionConfiguration File (the most important piece)

File location (recommended):

```ini
/etc/kubernetes/encryption-config.yaml
```

### ğŸ“Œ Key concepts:

- You define **resources** that should be encrypted
- You define **providers in priority order**
- Each provider can contain multiple keys (for rotation)

---

## âœğŸ» Fully Working Example: AES-GCM Encryption

### encryption-config.yaml

```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: 5TdyOqH3uHoCYdG7+xzHNiE7UdnA/yjmCqX0Ml/G4nU= # 32 bytes base64
      - identity: {}
```

**Explanation:**

- Kubernetes encrypts secret data using AES CBC
- Key is 32 bytes (256-bit AES)
- `identity` fallback ensures old unencrypted secrets still read

---

## ğŸ› ï¸ Enable It in kube-apiserver

Modify api-server manifest:

```bash
sudo nano /etc/kubernetes/manifests/kube-apiserver.yaml
```

Add:

```yaml
--encryption-provider-config=/etc/kubernetes/encryption-config.yaml
--encryption-provider-config-automatic-reload=true
```

Save â†’ kubelet automatically restarts API server.

---

## ğŸ§ª Testing Encryption at Rest (Hands-on)

We will:

1. Create a Secret
2. View raw data stored in etcd
3. Confirm it is encrypted

---

### Step 1: Create a secret

```bash
kubectl create secret generic mysecret \
  --from-literal=password=SuperSecret123
```

---

### Step 2: Read Secret normally

```bash
kubectl get secret mysecret -o yaml
```

You will see **base64 data**:

```yaml
data:
  password: U3VwZXJTZWNyZXQxMjM=
```

This is **not encryption**, just Base64.

---

### Step 3: View secret _directly from etcd_ (unencrypted-INSTEAD-of-plaintext)

If etcdctl is installed:

```bash
ETCDCTL_API=3 etcdctl get /registry/secrets/default/mysecret \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key
```

Result:

```ini
...
"value":"k8s:enc:aescbc:v1:key1:<BIG RANDOM BINARY ENCRYPTED PAYLOAD>"
```

ğŸ”¥ **Yay! Itâ€™s encrypted. No plaintext.**

---

## ğŸ”„ Key Rotation (Real-World Example)

### Step 1: Add new key

```yaml
providers:
  - aescbc:
      keys:
        - name: key2
          secret: NEW-GENERATED-BASE64-KEY
        - name: key1
          secret: OLD-BASE64-KEY
  - identity: {}
```

**Rules:**

- New key first = used for new writes
- Old keys still decrypt old secrets

---

### Step 2: Run encryption migration

```bash
kubectl delete secret mysecret
kubectl apply -f secret.yaml
```

(or run the official encryption migration tool.)

Now data is re-written using new key.

---

## ğŸ¦ Using **KMS v2** (AWS/GCP/Azure KMS)

The **best production setup**.

Example:

```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - kms:
          name: "aws-kms"
          apiVersion: v2
          endpoint: unix:///var/run/kmsplugin/socket.sock
      - identity: {}
```

KMS Plugin Responsibilities:

- Hold master key in cloud KMS
- Generate DEKs (data encryption keys)
- Encrypt Secrets
- Decrypt on read

---

## ğŸ—ï¸ Setup KMS Provider Plugin Example (AWS)

Download AWS KMS Plugin container:

```bash
docker run -d \
  -v /var/run/kmsplugin:/var/run/kmsplugin \
  public.ecr.aws/aws-k8s-security/kms-plugin:latest
```

API server talks to the plugin using gRPC over Unix domain socket.

---

## ğŸ§ª Encrypt ConfigMaps as well

Extend:

```yaml
resources:
  - resources:
      - secrets
      - configmaps
```

---

## ğŸ›¡ï¸ Validating Encryption is Injected

Use:

```bash
kubectl get --raw /metrics | grep encryption
```

Youâ€™ll see:

```ini
apiserver_encryption_config_controller_dynamics_reload_total 1
```

---

## ğŸš¨ Important Notes (Latest Best Practices)

### âœ”ï¸ Use AES-GCM or KMS v2

CBC is older and unauthenticated.

### âœ”ï¸ Enable encryption-provider-config-automatic-reload

Works in Kubernetes 1.27+

### âœ”ï¸ Always keep identity provider at bottom

It helps during migration.

### âœ”ï¸ Rotate keys every 6 months

Or comply with SOC2/PCI requirements.

### âœ”ï¸ Encrypt backups too

etcd encryption protects only live diskâ€”not backups.

---

## ğŸ Full Minimal Working Lab (Kind Cluster)

kind-config.yaml:

```yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
kubeadmConfigPatches:
  - |
    apiVersion: kubeadm.k8s.io/v1beta3
    kind: ClusterConfiguration
    apiServer:
      extraArgs:
        encryption-provider-config: /etc/kubernetes/encryption-config.yaml
      extraVolumes:
        - name: encryption-config
          hostPath: /root/encryption-config.yaml
          mountPath: /etc/kubernetes/encryption-config.yaml
          readOnly: true
```

Run Kind:

```bash
sudo kind create cluster --config kind-config.yaml
```

Apply encryption config â†’ tested earlier.

---

## ğŸ Final Summary (Cheat Sheet)

| Concept                 | Meaning                                 |
| ----------------------- | --------------------------------------- |
| EncryptionConfiguration | Defines K8s encryption                  |
| Encryption Providers    | aescbc, aesgcm, kms, secretbox          |
| Etcd encryption         | Done by API server only                 |
| Key Rotation            | Add new keys + re-encrypt               |
| KMS v2                  | Production-grade cloud-based encryption |

**Encrypting at rest = protecting Secrets stored in etcd.**
