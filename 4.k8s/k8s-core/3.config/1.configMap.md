# ⚙️ **ConfigMaps in Kubernetes — Full Administrative Deep Dive**

> 🎯 **Goal:** Learn to **create, manage, mount, update, and troubleshoot ConfigMaps** using CLI and YAML, understand how apps consume them (via environment variables, command args, and volumes), and know real-world best practices for versioning and rollout control.

---

## 📖 **What is a ConfigMap?**

A **ConfigMap** is a **key-value store** used to keep **non-sensitive configuration data** outside your container image.

Think of it as:

> 🗂️ “Environment settings for your Pods — managed centrally and injected dynamically.”

---

## 🧠 **Why ConfigMaps?**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Benefit                           | Description                                   |
| --------------------------------- | --------------------------------------------- |
| **🖇️ Decoupling**                 | Configs separated from container images       |
| **⚡ Dynamic Updates**            | Change app behavior without redeploying image |
| **🔁 Reusable**                   | Share config across multiple Pods             |
| **🤹🏻 Multiple Injection Methods** | As env vars, files, or command-line args      |
| **📃 Declarative Management**     | Managed via YAML or CLI                       |

</div>

---

## 🪜 **Creating ConfigMaps**

There are **four ways** to create ConfigMaps. Let’s cover all of them.

---

### **1️⃣ From Literal Key-Values**

```bash
kubectl create configmap app-config \
  --from-literal=APP_MODE=production \
  --from-literal=APP_PORT=8080
```

View:

```bash
kubectl get configmap app-config -o yaml
```

Output:

```yaml
data:
  APP_MODE: production
  APP_PORT: "8080"
```

---

### **2️⃣ From a File**

Say you have a `config.properties`:

```ini
APP_MODE=staging
DB_HOST=db-svc
```

Create:

```bash
kubectl create configmap app-config --from-file=config.properties
```

Output:

```yaml
data:
  config.properties: |
    APP_MODE=staging
    DB_HOST=db-svc
```

---

### **3️⃣ From Multiple Files**

```bash
kubectl create configmap web-config \
  --from-file=nginx.conf \
  --from-file=app.properties
```

output:

```yaml
data:
  app.properties: |
    APP_MODE=staging
    DB_HOST=db-svc
  nginx.conf: |
    server {
      listen 80;
      location / {
        proxy_pass http://app:8080;
      }
    }
```

Each file’s content becomes a separate key.

---

### **4️⃣ From a Directory**

If you have many config files in one folder:

```bash
kubectl create configmap app-config --from-file=./config/
```

Every file inside that folder will become a key.

---

## 🧠 **View, Edit, and Delete**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Action              | Command                                |
| ------------------- | -------------------------------------- |
| List all ConfigMaps | `kubectl get configmaps`               |
| Show details        | `kubectl describe configmap <name>`    |
| YAML output         | `kubectl get configmap <name> -o yaml` |
| Edit inline         | `kubectl edit configmap <name>`        |
| Delete              | `kubectl delete configmap <name>`      |

</div>

---

## 📦 **Using ConfigMaps in Pods**

You can inject ConfigMaps into Pods in **three main ways**.

---

### **1️⃣ As Environment Variables**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: env-demo
spec:
  containers:
    - name: app
      image: alpine
      command: ["sh", "-c", "echo Mode=$APP_MODE Port=$APP_PORT; sleep 3600"]
      envFrom:
        - configMapRef:
            name: app-config
```

Check logs:

```bash
kubectl logs env-demo
```

Output:

```ini
Mode=production Port=8080
```

---

### **2️⃣ As Individual Env Vars (Selective Import)**

```yaml
env:
  - name: MODE
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: APP_MODE
```

🧠 Use this when you only need _specific keys_.

---

### **3️⃣ As Mounted Files (Volumes)**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: file-demo
spec:
  containers:
    - name: app
      image: alpine
      command: ["sh", "-c", "cat /etc/config/APP_MODE; sleep 3600"]
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: app-config
```

Now inside the container:

```bash
cat /etc/config/APP_MODE
```

Output:

```ini
production
```

---

## 🔁 **Updating ConfigMaps**

You can **update** them either declaratively or imperatively.

### ✅ Declarative (Best Practice)

Edit YAML and reapply:

```bash
kubectl apply -f configmap.yaml
```

### ⚠️ Imperative (Quick Fix)

```bash
kubectl create configmap app-config --from-literal=APP_MODE=debug -o yaml --dry-run=client | kubectl apply -f -
```

---

### 🧠 Important:

> Pods **don’t auto-reload** ConfigMaps unless restarted.
> You must **restart Pods manually** or via rollout to pick up changes.

#### Restart example:

```bash
kubectl rollout restart deployment myapp
```

---

## 📺 **Live Reload Patterns (Advanced)**

In some setups, apps can detect file changes if the ConfigMap is **mounted as a volume**.

- Mount with:

  ```yaml
  volumeMounts:
    - name: config-volume
      mountPath: /etc/config
  ```

- Use apps or sidecars that **watch file changes** (`inotify`, `reloader`, etc.)
- Example: [stakater/Reloader](https://github.com/stakater/Reloader) automates Pod restarts when ConfigMaps change.

---

## ⚠️ **ConfigMap Size & Limits**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Limit           | Description                              |
| --------------- | ---------------------------------------- |
| Max size        | 1 MB total (keys + values)               |
| Namespace scope | Yes (per namespace)                      |
| Binary data     | Not supported (use Secrets)              |
| Updates         | Immediate in API but not in running Pods |

</div>

---

## 🔴 **Troubleshooting ConfigMaps**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Problem               | Symptom                | Fix                                       |
| --------------------- | ---------------------- | ----------------------------------------- |
| Pod fails to start    | Missing ConfigMap      | Ensure it exists before Pod creation      |
| Pod can’t read config | Wrong key name         | Check YAML and `kubectl describe` output  |
| Config not updating   | Old Pod still running  | Restart Deployment or Pod                 |
| Mount path empty      | Wrong volume reference | Ensure correct `name` and `mountPath`     |
| File permission issue | Read-only mount        | ConfigMap volumes are read-only by design |

</div>

---

## 🧰 **Diagnostic Commands**

```bash
kubectl get configmaps
kubectl describe configmap <name>
kubectl get pods
kubectl exec -it <pod> -- env | grep APP_
kubectl exec -it <pod> -- ls /etc/config
```

---

## ✍🏻 **Example: Full App Using ConfigMap**

`app-config.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-config
data:
  APP_ENV: production
  APP_COLOR: blue
  APP_PORT: "8080"
```

`deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
        - name: web
          image: nginx
          ports:
            - containerPort: 8080
          envFrom:
            - configMapRef:
                name: web-config
```

✅ When ConfigMap changes:

```bash
kubectl rollout restart deployment webapp
```

---

## 🔒 **RBAC & Security Notes**

- ConfigMaps are **non-sensitive**, but still accessible via API.
- Restrict user access using RBAC:

  ```yaml
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list"]
  ```

- Do not store passwords, tokens, or private keys in ConfigMaps — use **Secrets** instead.

---

## 💡 **Pro Tips (Real Clusters)**

- 💡 **Tip 1:** Prefix ConfigMaps with the app name (e.g., `webapp-config`).
- 💡 **Tip 2:** Always label your ConfigMaps:

  ```yaml
  metadata:
  labels:
    app: webapp
    type: config
  ```

- 💡 **Tip 3:** Use GitOps — store ConfigMap YAMLs in source control.
- 💡 **Tip 4:** Automate reloads with `stakater/reloader` or ArgoCD hooks.
- 💡 **Tip 5:** Avoid hardcoding defaults in apps — load from ConfigMap dynamically.

---

## ✅ **Summary**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature             | Description                                      |
| ------------------- | ------------------------------------------------ |
| **Purpose**         | Store non-sensitive key-value config data        |
| **Injection**       | Env vars, files, or command args                 |
| **Scope**           | Namespaced                                       |
| **Update Behavior** | Pods must restart to reflect changes             |
| **Security**        | Not encrypted, not for secrets                   |
| **Best Practice**   | Keep immutable app images + externalized configs |

</div>

---

## 🧭 **Next Deep Dives**

If you want to go further:

- 🧩 **Immutable ConfigMaps** — `kubectl create configmap --immutable=true`
- 🧩 **Dynamic Reload Tools** — Stakater Reloader, External Secrets Operator
- 🧩 **Comparing ConfigMap vs Secret**
- 🧩 **Injecting Configs into StatefulSets**
