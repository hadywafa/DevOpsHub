# üîê **How Big Companies Store & Use Secrets in K8s**

> **TL;DR:**  
> Encrypting Kubernetes Secrets at rest (KMS) is _good_ but **not enough**.  
> Modern companies use **external secret managers**, **short-lived tokens**, **sealed secrets/GitOps integrations**, and **runtime fetching patterns**.

Let's deep dive.

---

## ‚ùì **Why Encrypting Secrets at Rest in Kubernetes Is NOT Enough**

Kubernetes Secrets are:

- Base64-encoded (not encryption)
- Stored in etcd
- Accessed by anyone with etcd access or K8s API access
- Sometimes written into container filesystems or logs

**Encrypting secrets at rest protects only against disk theft.
But not against:**

- Compromised API server
- Misconfigured RBAC
- Developers with cluster-admin
- Attackers that gain pod-level access
- CI/CD pipelines that pull secrets

That‚Äôs why big companies combine multiple strategies.

---

## üè¢ **What the Big Companies Actually Do**

### ‚≠ê Approach 1 ‚Äî External Secret Managers (**Most Common**)

Large companies rarely store real secrets _inside_ Kubernetes.

They delegate to:

- **AWS Secrets Manager**
- **AWS Parameter Store**
- **HashiCorp Vault (most common in regulated industries)**
- **Azure Key Vault**
- **GCP Secret Manager**

#### Benefits:

- Secrets never stored in etcd
- Fine-grained IAM permissions
- Automatic rotation
- Audit logging
- KMS-managed encryption
- Short-lived token generation

#### Tools used to sync secrets into K8s:

- **External Secrets Operator (ESO)** (industry standard)
- Vault Agent Injector
- Secrets Store CSI Driver

This is the #1 industry pattern.

---

### ‚≠ê Approach 2 ‚Äî GitOps + Sealed Secrets (Bitnami)

Used by:

- Financial institutions
- Healthcare
- GitOps-heavy companies (ArgoCD, FluxCD)

#### Why?

Secrets can be safely stored encrypted in Git repositories without exposing plaintext.

#### Workflow:

1. Dev runs:

   ```bash
   kubeseal < secret.yaml > sealed-secret.yaml
   ```

2. Git stores **sealed-secret.yaml** (safe)
3. Only the cluster can decrypt it.

---

### ‚≠ê Approach 3 ‚Äî Runtime Secret Fetching (No K8s Secrets at all)

Used by high-security companies (Stripe, Netflix-type architectures):

Pods do NOT store secrets. Instead:

- Init containers fetch secrets at startup
- Sidecars fetch & rotate secrets periodically
- Workload Identity (GCP), IRSA (AWS), Managed Identity (Azure) used for access

Secrets live in memory only.

---

### ‚≠ê Approach 4 ‚Äî Use Kubernetes Encryption Providers + KMS

This is what you requested in the previous topic.

Big companies still enable this, but they don't rely on it.

They treat it as a **baseline hardening requirement**, not a full solution.

---

### ‚≠ê Approach 5 ‚Äî Zero Trust Workload Identity

Instead of storing credentials, workloads authenticate using identity-based mechanisms:

- **AWS IRSA (IAM Roles for Service Accounts)**
- **Azure Workload Identity**
- **GCP Workload Identity Federation**
- **SPIFFE/SPIRE** (in high-security orgs)

This eliminates static long-lived secrets entirely.

---

## üõ°Ô∏è **Modern Comparison Table (What should YOU use?)**

| Approach                                   | Where Used                | Security Level | Pros                 | Cons                             |
| ------------------------------------------ | ------------------------- | -------------- | -------------------- | -------------------------------- |
| **Encrypt secrets at rest (KMS provider)** | All big companies         | Medium         | Easy, native         | Doesn‚Äôt remove secrets from etcd |
| **External Secret Manager + ESO**          | 90% of modern enterprises | Very High      | Rotation, IAM, audit | Requires IAM setup               |
| **Sealed Secrets (GitOps)**                | Argo/Flux companies       | High           | Git-friendly         | No rotation                      |
| **Vault Agent / CSI Driver**               | Banks, healthcare         | Very High      | Dynamic secrets      | More complex                     |
| **Workload Identity (IRSA, MSI, GCP)**     | AWS, Azure, GCP           | Ultra High     | No stored secrets    | Requires cloud-native infra      |
| **Runtime fetching (envoy, spire)**        | High-security orgs        | Ultra High     | No static secrets    | Complex                          |

---

## üî•**Recommended Approach for Real Production**

**Best practice combo:**

### 1Ô∏è‚É£ Enable encryption at rest (baseline)

KMS-provider (AWS KMS, Azure Key Vault, GCP KMS)

### 2Ô∏è‚É£ Implement Workload Identity

Pods authenticate via IAM roles, not passwords.

### 3Ô∏è‚É£ Store secrets in an External Secret Manager

Use:

- External Secrets Operator
- or Secrets Store CSI Driver

### 4Ô∏è‚É£ Rotate secrets automatically

External secret managers support this.

### 5Ô∏è‚É£ Use Sealed Secrets ONLY for bootstrapping

Not for long-term secret storage.

### 6Ô∏è‚É£ Avoid mounting secrets as files for long time

Prefer environment variables or memory-only stores.

### 7Ô∏è‚É£ Enable RBAC & Pod Security Standards

Minimize who can read secrets.

---

## üß™ 5. Real-World Examples (With YAML)

---

## üîê Example 1 ‚Äî AWS Secrets Manager + External Secrets Operator (ESO)

### Step 1 ‚Äî Create a secret in AWS Secrets Manager

```bash
aws secretsmanager create-secret \
  --name db-password \
  --secret-string "P@ssw0rd123!"
```

### Step 2 ‚Äî ExternalSecret manifest

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: mysecret
spec:
  refreshInterval: "5m"
  secretStoreRef:
    name: aws
    kind: SecretStore
  target:
    name: app-secret
    creationPolicy: Owner
  data:
    - secretKey: DB_PASSWORD
      remoteRef:
        key: db-password
```

### Result:

Kubernetes gets:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
data:
  DB_PASSWORD: UEA... # (base64-encoded)
```

But _no plaintext ever enters Git, CI/CD, or YAML_.

---

## üîê Example 2 ‚Äî Sealed Secrets

### Step 1 ‚Äî Create a secret

```bash
kubectl create secret generic mysecret --from-literal=password="Admin123" --dry-run=client -o yaml > secret.yaml
```

### Step 2 ‚Äî Seal it

```bash
kubeseal -o yaml < secret.yaml > sealed-secret.yaml
```

### sealed-secret.yaml (safe for Git)

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: mysecret
spec:
  encryptedData:
    password: AgCda42...
```

ArgoCD or Flux decrypts it inside the cluster.

---

## üîê Example 3 ‚Äî Vault Agent Sidecar (Dynamic Secrets)

Pods get dynamic DB passwords that auto-expire.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: vault-demo
spec:
  serviceAccountName: vault-auth
  containers:
    - name: app
      image: nginx
      env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-creds
              key: password
  initContainers:
    - name: vault-agent
      image: hashicorp/vault
      command:
        - "vault"
        - "agent"
        - "-config=/vault/config.hcl"
```

Vault injects secrets at startup.

They expire after < 1 hour.

---

## üîê Example 4 ‚Äî AWS IRSA (no secrets at all)

Service account:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-sa
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123:role/AppRole
```

Pod uses AWS SDK to access resources securely.

No secret is stored in K8s.

---

## üß∞ What You Should NEVER Do in Kubernetes

- ‚ùå Don‚Äôt store secrets directly in ConfigMaps
- ‚ùå Don‚Äôt commit Kubernetes Secrets to Git
- ‚ùå Don‚Äôt mount long-lived secrets into files
- ‚ùå Don‚Äôt allow any pod to run as cluster-admin
- ‚ùå Don‚Äôt use static DB credentials (rotate!)
- ‚ùå Don‚Äôt store secrets inside Docker images

---

## üèÜ What‚Äôs the Best Approach for YOU?

### If you‚Äôre running Kubernetes on AWS:

- ‚úî Enable Encryption at Rest (KMS)
- ‚úî Use IRSA
- ‚úî Use AWS Secrets Manager + External Secrets Operator

### On Azure AKS:

- ‚úî Enable KMS-based EncryptionProvider
- ‚úî Use Azure Workload Identity
- ‚úî Use Azure Key Vault Provider + CSI Driver

### On GKE:

- ‚úî Enable Encryption at Rest with Cloud KMS
- ‚úî Use Workload Identity
- ‚úî Use Secret Manager + Secrets Store CSI Driver

### On On-Prem K8s:

- ‚úî Use Vault
- ‚úî Use Sealed Secrets if GitOps
- ‚úî Enable at-rest encryption via OpenShift/KMS

---

## üéØ **Final Recommendation**

> **Use an External Secret Manager + Workload Identity + Encrypt K8s secrets at rest.**  
> This is the same architecture used in AWS EKS, Azure AKS, GKE, and opensource K8s clusters in production today.

This gives you:

- No plaintext secrets in Git
- No secrets in etcd
- No static long-lived secrets
- Automatic rotation
- Full audit logs
- Perfect alignment with Zero Trust
- Matches big companies‚Äô security posture
