# âš™ï¸ **Container Runtime Internals**

_(dockerd / containerd / CRI / OCI Full Deep Dive)!_

---

## ğŸ“– **Where It Fits in the Kubernetes Architecture**

At the bottom of the Kubernetes stack lives the **Container Runtime** â€” the component that physically starts, stops, and manages containers.

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
  A[API Server] --> B[Kubelet]
  B --> C[CRI Plugin]
  C --> D["Container Runtime (containerd/dockerd)"]
  D --> E["runc (OCI Runtime)"]
  E --> F["Linux Kernel (Namespaces + Cgroups)"]
```

</div>

---

> âœ… **Kubelet** doesnâ€™t create containers directly.  
> âœ… It communicates via **CRI (Container Runtime Interface)** using **gRPC**.  
> âœ… **containerd** (or **dockerd**) translates CRI calls into **OCI runtime** commands.  
> âœ… **runc** creates the container using Linux primitives (namespaces, cgroups, capabilities).

---

## ğŸ¤º **Key Standards: CRI vs OCI**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Standard                              | Purpose                                                               | Used By                              |
| ------------------------------------- | --------------------------------------------------------------------- | ------------------------------------ |
| **CRI (Container Runtime Interface)** | Defines _how Kubelet talks to a runtime_ (via gRPC)                   | Between Kubelet â†” containerd/dockerd |
| **OCI (Open Container Initiative)**   | Defines _how containers are built and run_ (runtime spec, image spec) | Between containerd â†” runc            |

</div>

---

> âœ… CRI is **Kubernetes-defined**,  
> âœ… OCI is **industry-wide (Docker, Podman, CRI-O, etc.)**.

---

## ğŸ§© **Runtime Components Overview**

Letâ€™s break down what happens when youâ€™re using Docker or containerd underneath Kubernetes.

---

### ğŸ”¹ (A) Docker Stack (pre-1.24)

Before Kubernetes v1.24, Kubelet talked to **dockerd** through a shim called **dockershim**.

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
  A[Kubelet] --> B[dockershim]
  B --> C[dockerd]
  C --> D[containerd]
  D --> E[runc]
```

</div>

- **dockershim** implemented the CRI spec for Kubelet.
- **dockerd** managed images, networks, and volumes.
- **containerd** handled container lifecycle.
- **runc** executed containers using kernel features.

ğŸ‘‰ This model was deprecated in 2022 (v1.24+) â€” **dockershim removed**.

---

### ğŸ”¹ (B) Modern containerd-based Architecture

Now Kubelet communicates **directly** with **containerd** via CRI (no dockershim).

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
  A[Kubelet] -->|gRPC CRI| B[containerd]
  B -->|OCI runtime| C[runc]
  B --> D[Image Store]
  B --> E["Network (CNI)"]
  B --> F["Snapshotter (OverlayFS, etc.)"]
```

</div>

---

> âœ… containerd is now the **default Kubernetes runtime** (fast, modular, lightweight).  
> âœ… Itâ€™s used by Docker too â€” Docker itself _depends_ on containerd internally.

---

## âš™ï¸ **`containerd` Architecture Internals**

containerd has a clean modular structure:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Component                            | Role                                               |
| ------------------------------------ | -------------------------------------------------- |
| **containerd daemon (`containerd`)** | Long-running service managing containers           |
| **shim process (`containerd-shim`)** | Manages each container lifecycle independently     |
| **runc**                             | Executes containers (create, start, stop)          |
| **snapshotter**                      | Manages filesystem layers (OverlayFS, btrfs, etc.) |
| **content store**                    | Stores image blobs                                 |
| **image service**                    | Pulls/unpacks OCI images                           |
| **CRI plugin**                       | Implements the gRPC interface for Kubelet          |

</div>

---

### ğŸ”§ `containerd` Component Flow

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
  A[Kubelet] -->|CRI API| B[containerd]
  B --> C[CRI Plugin]
  C --> D[containerd-shim]
  D --> E[runc]
  E --> F["Linux Kernel (Namespaces + Cgroups)"]
  B --> G[Snapshotter]
  B --> H[Image Store]
```

</div>

---

> âœ… Each container gets its **own shim** process, which acts as a parent of `runc` and manages stdio and lifecycle even if containerd restarts.

---

## ğŸ§­ **Container Creation Lifecycle** (Step-by-Step)

Letâ€™s visualize how a Pod container is born when Kubelet calls containerd ğŸ‘‡

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
  participant K as Kubelet
  participant CR as containerd
  participant SH as containerd-shim
  participant R as runc
  participant OS as Linux Kernel

  K->>CR: RunPodSandbox()
  CR->>OS: Call CNI plugin (create netns, veth)
  K->>CR: CreateContainer(podSpec)
  CR->>SH: Spawn containerd-shim
  SH->>R: runc create (build namespaces, cgroups, mounts)
  R->>OS: Use clone() + setns() + pivot_root()
  SH->>R: runc start
  R->>OS: Container process launched
  SH->>CR: Report container ID
  CR->>K: Return container status
```

</div>

---

âœ… **runc** uses kernel syscalls like:

- `clone()` â€” to fork a process in new namespaces.
- `setns()` â€” to enter namespaces.
- `pivot_root()` â€” to change filesystem root.

---

## ğŸ“Œ **The Sandbox Concept**

Kubelet always creates a **Pod Sandbox** first.

- Represents the **network namespace** shared by all containers in the Pod.
- Only one sandbox per Pod; multiple containers share it.

**CRI Call:**

```bash
RunPodSandbox(podConfig)
```

containerd:

- Creates pause container (`k8s.gcr.io/pause:3.9`)
- Sets up network (via CNI)
- Returns sandbox ID

---

## ğŸ›œ **Networking via CNI in Runtime**

During `RunPodSandbox`, containerd invokes the CNI chain:

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph LR
  A[containerd] -->|invoke| B[CNI binary]
  B --> C[bridge plugin]
  C --> D[veth pair]
  D --> E[Pod netns]
  C --> F[Host bridge cni0]
  F --> G[eth0]
```

</div>

---

> âœ… Assigns Pod IP from pool  
> âœ… Adds routing  
> âœ… Updates `/etc/cni/net.d/` config files

---

## ğŸ“¦ **Storage via Snapshotters**

containerd uses **snapshotters** to manage image and container filesystems.

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Snapshotter | Description                         |
| ----------- | ----------------------------------- |
| `overlayfs` | Default; fast, layered filesystem   |
| `btrfs`     | CoW filesystem for advanced storage |
| `zfs`       | Used on ZFS systems                 |
| `devmapper` | Thin provisioning backend           |

</div>

---

> âœ… Each container gets a **layered writable mount** derived from its image.

---

## ğŸ§  **OCI Runtime (runc) Internals**

`runc` is the low-level runtime that actually **executes** containers.

### It handles:

- Namespace creation (UTS, PID, NET, IPC, MNT, USER)
- CGroup enforcement (CPU, memory, blkio)
- Capabilities dropping
- Seccomp filters
- AppArmor / SELinux profiles
- Pivot root and chroot isolation

> âœ… runc executes based on **OCI Runtime Spec**, typically under `/run/containerd/io.containerd.runtime.v2.task/<namespace>/...`.

---

### ğŸ§  Example runc Process Flow

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
  participant R as runc
  participant OS as Linux Kernel

  R->>OS: clone(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET)
  R->>OS: setns(netns)
  R->>OS: mount(rootfs)
  R->>OS: pivot_root()
  R->>OS: exec(container command)
```

</div>

---

## ğŸ’¡ **Example: Full Flow (Pod Creation to Running)**

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
  A[Kubelet] -->|CRI gRPC| B[containerd]
  B -->|RunPodSandbox| C[CNI Plugins]
  C --> D[Network Namespace Created]
  B -->|CreateContainer| E[containerd-shim]
  E -->|runc create/start| F[Linux Kernel]
  F --> G[Container Process Running]
```

</div>

---

> âœ… All status updates bubble back up via gRPC â†’ Kubelet â†’ API Server.

---

## ğŸ’¡ **Example CLI Flow (Behind the Scenes)**

Letâ€™s simulate this manually (simplified):

```bash
# 1. Pull image
ctr images pull docker.io/library/nginx:latest

# 2. Create container
ctr run --rm -t docker.io/library/nginx:latest webserver

# Behind the scenes:
# containerd -> runc -> namespaces + cgroups -> nginx process
```

---

## ğŸ§¬ **`containerd` and Dockerd Relationship**

Docker today is built **on top of** containerd:

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
  A[dockerd] --> B[containerd]
  B --> C[runc]
  C --> D[Linux Kernel]
```

</div>

So when you run:

```bash
docker run nginx
```

It actually translates to:

1. dockerd â†’ API call to containerd
2. containerd â†’ invokes runc
3. runc â†’ creates container

âœ… Thatâ€™s why **Docker can also serve as a CRI runtime** (through cri-dockerd plugin for Kubernetes).

---

## ğŸ·ï¸ **Common Container Runtime Implementations**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Runtime                         | Description                                          | Use Case               |
| ------------------------------- | ---------------------------------------------------- | ---------------------- |
| **containerd**                  | Default runtime for Kubernetes; lightweight, modular | Standard choice        |
| **CRI-O**                       | Red Hatâ€™s runtime implementing CRI directly          | OpenShift              |
| **Docker Engine + cri-dockerd** | Legacy Docker compatibility                          | Migration phase        |
| **gVisor / Kata Containers**    | Secure, sandboxed runtimes                           | Multi-tenant workloads |
| **Mirantis Dockerd**            | Maintained version for enterprise                    | Backward compatibility |

</div>

---

## ğŸ” **Security Model in Runtimes**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Mechanism              | Purpose                                      |
| ---------------------- | -------------------------------------------- |
| **Namespaces**         | Process isolation (PID, NET, IPC, MNT, etc.) |
| **Cgroups**            | Resource limits (CPU, memory, IO)            |
| **Capabilities**       | Drop root-level powers selectively           |
| **Seccomp**            | Restrict allowed syscalls                    |
| **AppArmor / SELinux** | Policy-based file access control             |
| **User namespaces**    | Map container root to unprivileged host UID  |

</div>

âœ… Together they form the **core of container security sandboxing**.

---

## ğŸ“ƒ **containerd Configuration File** (Example)

Located at `/etc/containerd/config.toml`:

```toml
version = 2

[plugins."io.containerd.grpc.v1.cri"]
  sandbox_image = "registry.k8s.io/pause:3.9"
  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
    runtime_type = "io.containerd.runc.v2"
```

âœ… You can modify the `sandbox_image`, change snapshotter, or enable seccomp profiles here.

---

## ğŸ **Summary**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Layer                 | Component                                         | Description                      |
| --------------------- | ------------------------------------------------- | -------------------------------- |
| **Kubelet â†’ Runtime** | CRI (gRPC)                                        | Standard API for Kubeletâ€“runtime |
| **Runtime â†’ Kernel**  | OCI (Runtime Spec)                                | Standard interface for execution |
| **containerd-shim**   | Keeps container alive even if containerd restarts |                                  |
| **runc**              | Executes containers with namespaces & cgroups     |                                  |
| **CNI**               | Handles Pod networking                            |                                  |
| **Snapshotter**       | Manages filesystem layers                         |                                  |
| **CRI Plugin**        | Main entry point for Kubelet                      |                                  |
| **Pause Container**   | Defines Pod-level network namespace               |                                  |

</div>

---

## ğŸ–¼ï¸ **Visual Summary: Full Container Lifecycle**

<div align="center" style="background-color: #255560ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
  participant U as User (kubectl apply)
  participant API as API Server
  participant K as Kubelet
  participant CR as containerd
  participant SH as containerd-shim
  participant R as runc
  participant OS as Linux Kernel

  U->>API: Create Pod YAML
  API->>K: Notify Pod assigned to node
  K->>CR: RunPodSandbox (CNI setup)
  K->>CR: CreateContainer (container spec)
  CR->>SH: Start shim process
  SH->>R: runc create/start
  R->>OS: Clone namespaces + apply cgroups
  R->>OS: Start container process
  SH->>CR: Report running state
  CR->>K: Return status
  K->>API: Update Pod phase=Running
```

</div>

---

âœ… **In plain English:**

> Kubelet asks containerd (via CRI) to run containers. containerd prepares the filesystem, sets up networking and storage, and calls `runc` to spawn an isolated process using Linux namespaces and cgroups. The shim keeps it alive and reports back up to Kubelet, which updates the Pod status in the API Server.
