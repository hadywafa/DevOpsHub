# âœðŸ» **Hands on Helm CI/CD Integration**

here are **production-style CI and CD pipelines** for a simple **ASP.NET Core API** using **Helm**.
Youâ€™ll get separate setups for:

- **GitHub Actions** â†’ **GHCR** (build, test, push) + **Helm deploy**
- **Azure DevOps** â†’ **ACR** (build, test, push) + **Helm deploy**

They follow best practices: **build once, tag well (SHA/SemVer/branch), capture image digest, deploy with Helm (prefer digest for prod), env-specific values files, caching, and atomic rollouts**.

---

## ðŸ“ Suggested repo layout

```ini
.
â”œâ”€ src/MyApi/                     # ASP.NET Core API (Dockerfile here)
â”œâ”€ helm/myapi/                    # Helm chart
â”‚   â”œâ”€ values.yaml
â”‚   â”œâ”€ values-dev.yaml
â”‚   â”œâ”€ values-staging.yaml
â”‚   â”œâ”€ values-prod.yaml
â”‚   â””â”€ templates/deployment.yaml
â”œâ”€ .github/workflows/             # GitHub Actions pipelines (CI/CD)
â””â”€ azure-pipelines/               # Azure DevOps pipelines (CI/CD)
```

---

## ðŸ§° Helm chart essentials (works for both GA + AzDO)

**helm/myapi/values.yaml:**

```yaml
replicaCount: 1
image:
  repository: CHANGEME_BY_PIPELINE
  tag: "" # used for non-prod (e.g., SHA)
  digest: "" # preferred for prod (immutable)
service:
  type: ClusterIP
  port: 80
```

**helm/myapi/templates/deployment.yaml** (image pin by digest if provided)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "myapi.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount | default 1 }}
  selector:
    matchLabels:
      app.kubernetes.io/name: {{ include "myapi.name" . }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ include "myapi.name" . }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          {{- if .Values.image.digest }}
          image: "{{ .Values.image.repository }}@{{ .Values.image.digest }}"
          {{- else }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          {{- end }}
          ports:
            - containerPort: 80
          imagePullPolicy: IfNotPresent
```

**environment values** (minimal example):

- `values-dev.yaml`

```yaml
replicaCount: 1
```

- `values-staging.yaml`

```yaml
replicaCount: 2
```

- `values-prod.yaml`

```yaml
replicaCount: 3
```

---

## ðŸ™ GitHub Actions â€” CI to **GHCR**, CD via **Helm**

### 1. CI: build, test, cache, push (GHCR)

**.github/workflows/ci-build-push.yml:**

```yaml
name: CI - Build, Test, Push (GHCR)

on:
  push:
    branches: ["**"]
    tags: ["v*.*.*"]
  pull_request:

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: myapi
  DOTNET_VERSION: "8.0.x"   # LTS

jobs:
  build-test-push:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # dotnet cache
      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: ${{ env.DOTNET_VERSION }} }

      - name: Restore
        run: dotnet restore src/MyApi/MyApi.csproj
      - name: Build
        run: dotnet build src/MyApi/MyApi.csproj -c Release --no-restore
      - name: Test
        run: dotnet test --no-build --verbosity normal

      # Docker login to GHCR
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: docker/setup-buildx-action@v3

      - name: Compute image tags
        id: meta
        run: |
          REPO="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}"
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          BR="${GITHUB_REF_NAME//\//-}"
          echo "branch=$BR" >> $GITHUB_OUTPUT
          if [[ "${GITHUB_REF_TYPE}" == "tag" && "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "semver=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          fi
          if [[ "${GITHUB_REF_NAME}" == "main" ]]; then
            echo "latest=latest" >> $GITHUB_OUTPUT
          fi

      - name: Build & Push (multi-tags) and capture digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/MyApi/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.repo }}:${{ steps.meta.outputs.sha }}
            ${{ steps.meta.outputs.repo }}:${{ steps.meta.outputs.branch }}
            ${{ steps.meta.outputs.semver && format('{0}:{1}', steps.meta.outputs.repo, steps.meta.outputs.semver) || '' }}
            ${{ steps.meta.outputs.latest && format('{0}:{1}', steps.meta.outputs.repo, steps.meta.outputs.latest) || '' }}
          outputs: type=image
      # docker/build-push-action exposes digest as output
      - name: Save image meta artifact
        run: |
          echo "repository=${{ steps.meta.outputs.repo }}" > image-meta.txt
          echo "shaTag=${{ steps.meta.outputs.sha }}"   >> image-meta.txt
          echo "branchTag=${{ steps.meta.outputs.branch }}" >> image-meta.txt
          echo "semverTag=${{ steps.meta.outputs.semver }}" >> image-meta.txt
          echo "digest=${{ steps.build.outputs.digest }}"   >> image-meta.txt
      - uses: actions/upload-artifact@v4
        with:
          name: image-meta
          path: image-meta.txt
```

> **What you get in GHCR:** > `ghcr.io/<owner>/myapi:3a1c9f7`, `:main` (or branch), optional `:vX.Y.Z`, and `:latest` for main â€” all pointing to the **same digest** (captured in `image-meta.txt` artifact).

---

### 2. CD: deploy with Helm (choose env + tag or digest)

**.github/workflows/cd-deploy-helm.yml:**

```yaml
name: CD - Deploy with Helm

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: Target env
        options: [dev, staging, prod]
        required: true
      refType:
        type: choice
        description: Use tag or digest?
        options: [tag, digest]
        required: true
      refValue:
        description: Tag (e.g., 3a1c9f7 / main / v1.2.0) or sha256:... for digest
        required: true

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: myapi
  CHART: helm/myapi
  RELEASE: myapi

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Configure cluster access here (example for AKS via Azure/login if you like)
      - name: Configure kubectl
        run: echo "kubectl context setup goes here (e.g., az aks get-credentials ...)"

      - uses: azure/setup-helm@v4
        with: { version: v3.15.1 }

      - name: Derive namespace & values file
        id: env
        run: |
          case "${{ github.event.inputs.environment }}" in
            dev)     echo "ns=dev"     >> $GITHUB_OUTPUT; echo "vals=values-dev.yaml"     >> $GITHUB_OUTPUT;;
            staging) echo "ns=staging" >> $GITHUB_OUTPUT; echo "vals=values-staging.yaml" >> $GITHUB_OUTPUT;;
            prod)    echo "ns=prod"    >> $GITHUB_OUTPUT; echo "vals=values-prod.yaml"    >> $GITHUB_OUTPUT;;
          esac

      - name: Helm upgrade --install
        run: |
          IMAGE_REPO="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}"
          NS="${{ steps.env.outputs.ns }}"
          VALS="${{ steps.env.outputs.vals }}"
          if [ "${{ github.event.inputs.refType }}" = "digest" ]; then
            helm upgrade --install "${{ env.RELEASE }}" "${{ env.CHART }}" \
              --namespace "$NS" --create-namespace \
              -f "${{ env.CHART }}/$VALS" \
              --set image.repository="$IMAGE_REPO" \
              --set image.digest="${{ github.event.inputs.refValue }}" \
              --set image.tag="" \
              --wait --atomic --timeout 10m
          else
            helm upgrade --install "${{ env.RELEASE }}" "${{ env.CHART }}" \
              --namespace "$NS" --create-namespace \
              -f "${{ env.CHART }}/$VALS" \
              --set image.repository="$IMAGE_REPO" \
              --set image.tag="${{ github.event.inputs.refValue }}" \
              --set image.digest="" \
              --wait --atomic --timeout 10m
          fi
```

> **Best practice:** For **prod**, choose `refType=digest` and pass `sha256:...` from the CI artifact; for dev/staging, a **SHA tag** is fine.

---

## ðŸŸ¦ Azure DevOps â€” CI to **ACR**, CD via **Helm** (AKS)

### 1. CI: build, test, push (ACR) + publish image metadata

**azure-pipelines/ci.yml:**

```yaml
trigger:
  branches:
    include: ["*"]
  tags:
    include: ["v*.*.*"]

variables:
  dotnetVersion: "8.0.x"
  acrName: "myacr" # change
  registry: "$(acrName).azurecr.io"
  imageName: "myapi"

pool:
  vmImage: ubuntu-latest

stages:
  - stage: BuildTestPush
    jobs:
      - job: ci
        steps:
          - checkout: self

          - task: UseDotNet@2
            inputs:
              packageType: "sdk"
              version: "$(dotnetVersion)"

          - script: dotnet restore src/MyApi/MyApi.csproj
            displayName: Restore
          - script: dotnet build src/MyApi/MyApi.csproj -c Release --no-restore
            displayName: Build
          - script: dotnet test --no-build --verbosity normal
            displayName: Test

          - task: AzureCLI@2
            displayName: "ACR Login"
            inputs:
              azureSubscription: "MyAzureConnection" # service connection
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr login -n $(acrName)

          - script: |
              IMAGE="$(registry)/$(imageName)"
              SHA="$(Build.SourceVersion:0:7)"
              BR="$(Build.SourceBranchName)"
              BR="${BR//\//-}"
              docker build -f src/MyApi/Dockerfile -t "$IMAGE:$SHA" -t "$IMAGE:$BR" .
              docker push "$IMAGE:$SHA"
              docker push "$IMAGE:$BR"
              if [ "$BR" = "main" ]; then
                docker tag "$IMAGE:$SHA" "$IMAGE:latest"
                docker push "$IMAGE:latest"
              fi
              # capture digest of the SHA tag
              DIGEST=$(docker manifest inspect "$IMAGE:$SHA" | jq -r '.manifests[0].digest // .config.digest // .digest')
              echo "repository=$IMAGE"   > image-meta.json
              echo "shaTag=$SHA"        >> image-meta.json
              echo "branchTag=$BR"      >> image-meta.json
              echo "digest=$DIGEST"     >> image-meta.json
            displayName: "Build, Push, Capture digest"

          - publish: image-meta.json
            artifact: image-meta
            displayName: "Publish image metadata"
```

> This publishes an `image-meta` artifact with `repository`, `shaTag`, `branchTag`, and `digest`.

---

### 2. CD: deploy with Helm to AKS

**azure-pipelines/cd.yml:**

```yaml
trigger: none # run manually or via pipeline resource from CI

variables:
  chartPath: "helm/myapi"
  releaseName: "myapi"
  acrName: "myacr"
  registry: "$(acrName).azurecr.io"
  imageName: "myapi"

pool:
  vmImage: ubuntu-latest

stages:
  - stage: Deploy
    jobs:
      - job: helm
        variables:
          # set at queue time:
          # env = dev|staging|prod
          # refType = tag|digest
          # refValue = 3a1c9f7 | main | v1.2.0 | sha256:...
          env: "staging"
          refType: "tag"
          refValue: "3a1c9f7"
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: "Get AKS credentials"
            inputs:
              azureSubscription: "MyAzureConnection"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g MyRG -n MyAKS --overwrite-existing

          - task: HelmInstaller@1
            inputs:
              helmVersionToInstall: "latest"

          - script: |
              case "$(env)" in
                dev)     NS=dev;     VALS=values-dev.yaml;;
                staging) NS=staging; VALS=values-staging.yaml;;
                prod)    NS=prod;    VALS=values-prod.yaml;;
              esac

              IMAGE_REPO="$(registry)/$(imageName)"
              CHART="$(chartPath)"

              if [ "$(refType)" = "digest" ]; then
                echo "Deploying digest $(refValue) to $NS"
                helm upgrade --install "$(releaseName)" "$CHART" \
                  --namespace "$NS" --create-namespace \
                  -f "$CHART/$VALS" \
                  --set image.repository="$IMAGE_REPO" \
                  --set image.digest="$(refValue)" \
                  --set image.tag="" \
                  --wait --atomic --timeout 10m
              else
                echo "Deploying tag $(refValue) to $NS"
                helm upgrade --install "$(releaseName)" "$CHART" \
                  --namespace "$NS" --create-namespace \
                  -f "$CHART/$VALS" \
                  --set image.repository="$IMAGE_REPO" \
                  --set image.tag="$(refValue)" \
                  --set image.digest="" \
                  --wait --atomic --timeout 10m
              fi
            displayName: "Helm upgrade --install"
```

> **Tip:** You can wire this CD pipeline to trigger from CI (pipeline resource) and automatically pick the latest `image-meta` artifact, or keep it manual and paste `refValue` when promoting.

---

## ðŸ”‘ Secrets & access youâ€™ll need

- **GitHub Actions**

  - `GITHUB_TOKEN` (provided automatically) to push to GHCR.
  - Cluster auth step (e.g., to AKS via Azure/login + `az aks get-credentials`, or any kubeconfig you use).

- **Azure DevOps**

  - Service connection `MyAzureConnection` with rights on ACR & AKS.
  - AKS resource group & cluster names in the CD script.
  - Optional: Kubernetes service connection instead of CLI.

---

## âœ… Best-practice checklist (Helm + image tags)

- Build once â†’ push **multiple immutable references**: `:sha`, `:branch`, optional `:vX.Y.Z`, `:latest` (main only).
- **Capture digest** in CI; **use digest in prod**, tag in lower envs.
- Separate **env values files** and pass them via `-f`.
- Use `--wait --atomic --timeout` for safe rollouts; `helm test` as a next step if you add test hooks.
- Sanitise branch tags (lowercase, replace `/` with `-`).
- Keep registry retention policies (keep SemVer forever, prune old branch SHAs).
- Optionally sign images (Cosign) & verify in cluster (Kyverno/OPA).
