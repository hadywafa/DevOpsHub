# üéØ Goals of a good tagging strategy

- **Immutability:** every deploy points to an unchanging artifact.
- **Traceability:** you can map a running pod ‚Üí image ‚Üí commit ‚Üí PR ‚Üí build.
- **Promotability:** ‚Äúbuild once, deploy many‚Äù across dev ‚Üí staging ‚Üí prod without rebuilding.
- **Rollbackability:** a single command puts you back on a known-good image.

---

## üè∑Ô∏è The tags you should produce on every build

Build the image **once** and push **multiple tags** that reference the _same digest_:

1. **Commit SHA (short)** ‚Äî immutable, primary deployment ID

   - e.g., `:3a1c9f7`
   - ‚úÖ Use for staging and often for prod.

2. **Semantic version (if you cut releases)**

   - e.g., `:v1.12.3`
   - ‚úÖ Human-friendly; pin prod to this if you do versioned releases.

3. **Branch channel**

   - e.g., `:main`, `:develop`, `:feature-abc`
   - ‚úÖ Great for ephemeral envs; ‚ùå don‚Äôt use for prod.

4. **Latest**

   - e.g., `:latest` only for `main`
   - üëç fine for dev local testing; ‚ùå avoid in prod.

> **Rule of thumb:** **Deploy with SHA or SemVer**, never rely on moving tags (like `latest` or `main`) in production.

---

## üîí Even better than tags: pin by digest at deploy time

Tags can be retagged; **digests cannot**.

- Image reference in Helm:

  - **Tag form:** `myreg/app:3a1c9f7`
  - **Digest form (preferred for prod):** `myreg/app@sha256:<digest>`

- CI/CD should capture the built **digest** and pass it to Helm.

### Helm values pattern (supports either)

```yaml
# values.yaml
image:
  repository: myregistry.io/team/myapp
  tag: "" # set this for non-prod (e.g., SHA)
  digest: "" # set this for prod (e.g., sha256:abcd...)

imagePullPolicy: IfNotPresent
```

### Deployment template logic

```yaml
# templates/deployment.yaml (snippet)
containers:
  - name: {{ .Chart.Name }}
    {{- if .Values.image.digest }}
    image: "{{ .Values.image.repository }}@{{ .Values.image.digest }}"
    {{- else }}
    image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
    {{- end }}
```

> **Practice:** Use **digest in prod**, **tag (SHA)** elsewhere. Same image, same digest; you just control how you reference it.

---

## üîÅ Build once, promote by retag (don‚Äôt rebuild)

- **Do not rebuild for each environment.** That breaks traceability.
- Promote by **adding a new tag** (e.g., retag `3a1c9f7` ‚Üí `v1.12.3`) that points to the same digest.
- Your deploy job pins **the digest** (or the SHA tag) for each env.

**Example promotion (ACR / GHCR):**

```bash
# Both tags point to the same digest
# ACR
az acr repository show-manifests -n myacr --repository myapp
az acr repository update-manifest -n myacr --image myapp@sha256:... --add-tag myapp:v1.12.3

# GHCR (docker/oras)
docker pull ghcr.io/org/myapp@sha256:...
docker tag ghcr.io/org/myapp@sha256:... ghcr.io/org/myapp:v1.12.3
docker push ghcr.io/org/myapp:v1.12.3
```

---

## üß™ Suggested ‚Äúwho uses what‚Äù per environment

| Environment              | Recommended reference                            | Why                                              |
| ------------------------ | ------------------------------------------------ | ------------------------------------------------ |
| **Dev**                  | `:branch` or short `:sha`                        | quick iteration, easy mapping to CI runs         |
| **Staging**              | `:sha`                                           | immutable, test exactly what you‚Äôll promote      |
| **Prod (non-versioned)** | **`@sha256:digest`** (or `:sha`)                 | strongest immutability                           |
| **Prod (versioned)**     | **`:vX.Y.Z` + optionally pin `@sha256` in Helm** | human-friendly release numbers and immutable pin |

---

## üß∞ CI/CD handoff to Helm (simple & solid)

Have your build job output **both**:

- `IMAGE_DIGEST` ‚Äì e.g., `sha256:abcd...`
- `IMAGE_TAG_SHA` ‚Äì e.g., `3a1c9f7`

Then deploy with one of these calls:

**Prod (pin digest):**

```bash
helm upgrade --install myapp ./chart \
  --set image.repository=myreg/myapp \
  --set image.digest=sha256:abcd... \
  --set image.tag=
```

**Staging (use SHA tag):**

```bash
helm upgrade --install myapp-stg ./chart \
  --set image.repository=myreg/myapp \
  --set image.tag=3a1c9f7 \
  --set image.digest=
```

---

## ‚úÖ Naming & hygiene rules that save pain

- **Sanitize branch tags**: lowercase, replace `/` with `-`.
- **Keep tag set small**: SHA + (optional) SemVer + branch + latest(main).
- **Enforce tag immutability** in registry (if supported) for `v*` and `sha*`.
- **Retention policies**: keep recent SHAs; keep all SemVer tags; keep only last N branch tags.
- **Never overwrite SemVer tags** once released.
- Prefer **OCI-compliant** registries (GHCR/ACR/ECR/GCR all fine).

---

## üîê Supply-chain best practices (works great with Helm)

- **Sign images** (Sigstore Cosign) and **verify in admission** (Kyverno/OPA):

  - Build: `cosign sign myreg/myapp@sha256:...`
  - Cluster policy: only admit signed digests from your org.

- Attach **SBOM** (Syft) and scan (Grype/Trivy).
- Record **provenance** (SLSA/GitHub OIDC) so you can prove where an image came from.

---

## üß≠ Rollback & debugging checklist

- Always record deployed **tag + digest + Helm revision** in release notes/annotations.
- Use `helm rollback` to jump to the last known good **(same digest)**.
- Verify what‚Äôs running:

  ```bash
  kubectl get pods -n prod -o jsonpath='{..image}' | tr ' ' '\n'
  ```

- Map image ‚Üí digest back to CI build using your registry UI or `docker manifest inspect`.

---

## üßæ Quick reference (copy/paste)

- **Build tags:** `:sha`, `:branch`, optional `:vX.Y.Z`, `:latest (main only)`
- **Deploy:** staging ‚Üí `--set image.tag=$SHA`; prod ‚Üí `--set image.digest=$DIGEST`
- **Don‚Äôt:** use `:latest` in prod; rebuild per env; mutate SemVer tags
- **Do:** build once; promote by retag; pin by digest for prod; sign images
