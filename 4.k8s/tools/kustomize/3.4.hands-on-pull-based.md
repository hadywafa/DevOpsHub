# ğŸ§© **Azure DevOps + Kustomize + GitOps (Flux/ArgoCD)**

## ğŸ¯ **Goal**

- CI builds & pushes Docker image to **Azure Container Registry (ACR)**
- CI **updates Kustomize overlay** (injects the new image tag)
- CI commits & pushes that change to Git
- **Flux** or **Argo CD** auto-syncs the cluster to match Git state

No direct `kubectl apply` from pipeline â€” the **cluster pulls from Git**.

---

## ğŸ“‚ **Repo structure**

```ini
.
â”œâ”€â”€ src/MyApi/
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”‚   â”œâ”€â”€ service.yaml
â”‚   â”‚   â””â”€â”€ kustomization.yaml
â”‚   â””â”€â”€ overlays/
â”‚       â”œâ”€â”€ dev/kustomization.yaml
â”‚       â”œâ”€â”€ staging/kustomization.yaml
â”‚       â””â”€â”€ prod/kustomization.yaml
â””â”€â”€ azure-pipelines/
    â””â”€â”€ ci-gitops.yml
```

---

## âš™ï¸ **Kustomize setup**

### ğŸ§© `base/deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapi
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapi
  template:
    metadata:
      labels:
        app: myapi
    spec:
      containers:
        - name: myapi
          image: myacr.azurecr.io/myapi # no tag here
          ports:
            - containerPort: 80
```

---

### ğŸ§© `overlays/dev/kustomization.yaml`

```yaml
resources:
  - ../../base

namespace: dev
namePrefix: dev-
images:
  - name: myacr.azurecr.io/myapi
    newTag: placeholder
```

âœ… The pipeline will replace `placeholder` with your **commit SHA**.

---

## ğŸ§° **Flux or Argo setup (cluster side)**

### ğŸ§© For **Flux**

```yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: myapi-dev
  namespace: flux-system
spec:
  interval: 1m
  path: ./k8s/overlays/dev
  prune: true
  sourceRef:
    kind: GitRepository
    name: platform-config
```

### ğŸ§© For **Argo CD**

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapi-dev
spec:
  project: default
  source:
    repoURL: https://github.com/myorg/myrepo
    targetRevision: main
    path: k8s/overlays/dev
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

Both continuously watch your Git repo and reconcile automatically.

---

## ğŸ—ï¸ **Azure DevOps CI (GitOps style)**

### File: `azure-pipelines/ci-gitops.yml`

```yaml
trigger:
  - main

pool:
  vmImage: ubuntu-latest

variables:
  acrName: myacr
  registry: $(acrName).azurecr.io
  imageName: myapi
  overlaysPath: k8s/overlays/dev

steps:
  - checkout: self
    persistCredentials: true # allows pushing back to Git

  # Build and push image
  - task: AzureCLI@2
    displayName: Build & Push to ACR
    inputs:
      azureSubscription: "MyAzureConnection"
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az acr login -n $(acrName)
        IMAGE="$(registry)/$(imageName)"
        SHA=$(Build.SourceVersion)
        docker build -f src/MyApi/Dockerfile -t "$IMAGE:$SHA" .
        docker push "$IMAGE:$SHA"
        echo "##vso[task.setvariable variable=SHA;isOutput=true]$SHA"

  # Update overlay and commit the change
  - script: |
      cd $(overlaysPath)
      kustomize edit set image $(registry)/$(imageName)=$(registry)/$(imageName):$(Build.SourceVersion)
      git config user.name "azure-pipelines"
      git config user.email "pipeline@mycompany.com"
      git add .
      git commit -m "Promote dev -> $(Build.SourceVersion)"
      git push origin HEAD:main
    displayName: "Update overlay & push to Git"
```

âœ… What happens:

1. Pipeline builds and pushes image
2. Kustomize overlay updated with new SHA
3. Commit pushed to Git
4. **Flux or Argo CD auto-syncs the cluster**

No need for `kubectl` or credentials in the pipeline.

---

## ğŸ§  **Visual Flow**

```mermaid
flowchart LR
A[Build & tag Docker image] --> B[Push to ACR]
B --> C[Pipeline updates Kustomize overlay]
C --> D[Pipeline commits & pushes to Git]
D --> E[Flux/Argo detects change]
E --> F[Cluster reconciles automatically]
```

---

## ğŸ’¡ **Why This Is Best Practice**

| Feature             | Benefit                                     |
| ------------------- | ------------------------------------------- |
| ğŸ”’ Cluster security | Pipeline never needs cluster credentials    |
| ğŸ§¾ Audit trail      | Git keeps a full deployment history         |
| ğŸ” Self-healing     | Flux/Argo reconciles drift automatically    |
| ğŸ§  Clear promotions | Promote between environments via PRs        |
| ğŸ§° Modular design   | Uses same overlays (Kustomize) across tools |

---

## âœ… **Summary**

| Concept               | Description                                    |
| --------------------- | ---------------------------------------------- |
| **Pipeline job**      | Builds image, pushes to ACR                    |
| **Kustomize**         | Defines manifests per environment              |
| **Overlay edit**      | Pipeline injects the image tag                 |
| **GitOps controller** | Syncs cluster to Git automatically             |
| **Result**            | Secure, auditable, and declarative delivery ğŸš€ |

---

âœ¨ **In short:**

> CI builds the image ğŸ—ï¸ â†’  
> commits the new tag to Git ğŸ§¾ â†’  
> Flux/Argo updates the cluster ğŸ”
