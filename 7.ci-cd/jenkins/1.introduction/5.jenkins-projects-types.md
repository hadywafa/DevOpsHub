# ðŸ§© Jenkins Project Types

Jenkins offers different **project types (job types)** based on how you want to automate, structure, and trigger your builds.  
Each project type solves a different problem and offers different flexibility levels.

---

<div align="center" style="background-color:#fff; border-radius: 10px; border: 2px solid">
   <img src="image/1765354444394.png" alt="GitHub Actions Matrix Build" style="width: 80%">
</div>

---

## ðŸ†“ 1. Freestyle Project

> âœ” The "classic" Jenkins job  
> âœ” Perfect for quick tasks  
> âœ” GUI-driven configuration  
> âœ” Limited compared to Pipelines

---

### ðŸ§  What Is It?

A **Freestyle Project** is a simple job where you manually configure:

- Source code checkout
- Build steps
- Post-build actions
- Triggers
- Environment variables

All through the **Jenkins Web UI** â€” no scripting required.

---

### ðŸ›  Example Use Cases

- Run a shell/batch script
- Trigger a Maven/Gradle build
- Download files and process them
- Integrate with build tools like Ant
- Trigger deployments via scripts

---

### ðŸŽ¯ Advantages

- Easy to create
- GUI-driven
- Good for beginners
- Good for simple workflows

---

### âš ï¸ Limitations

- Hard to maintain for complex pipelines
- No code versioning of pipeline logic
- Cannot orchestrate complex CI/CD flows
- Not suitable for multi-branch or dynamic workflows

---

## ðŸŒŠ 2. Pipeline Project

> âœ” The modern Jenkins job  
> âœ” Uses **Jenkinsfile**  
> âœ” Code-as-pipeline  
> âœ” Supports complex CI/CD

---

### ðŸ§  What Is It?

A **Pipeline Project** allows you to define your whole build, test, and deploy process **as code**, using Groovy-based syntax.

Stored in Jenkins or in your repository as `Jenkinsfile`.

---

### ðŸ”¥ Pipeline Types:

#### 1. Declarative Pipeline

- Structured, simple, recommended.

#### 2. Scripted Pipeline

- Fully Groovy, flexible, more advanced.

---

### ðŸ§± Example Jenkinsfile (Declarative)

```groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps { sh 'mvn package' }
        }

        stage('Test') {
            steps { sh 'mvn test' }
        }

        stage('Deploy') {
            steps { sh './deploy.sh' }
        }
    }
}
```

---

### ðŸŽ¯ Advantages

- Pipeline as code
- Versioned with source code
- Supports retries, conditions, agents per stage
- Works with Kubernetes, Docker, cloud agents
- Strong DevOps integration

---

### âš ï¸ Limitations

- Requires writing Groovy-like syntax
- Harder for beginners
- Complex debugging for Scripted Pipelines

---

## ðŸŒ³ 3. Multibranch Pipeline

> âœ” Automatically creates pipelines per branch  
> âœ” Perfect for Git Flow / Trunk-based development  
> âœ” Zero manual job creation per branch

---

### ðŸ§  What Is It?

A **Multibranch Pipeline** scans your Git repo and creates a **separate pipeline job** for each branch, PR, or tag that contains a Jenkinsfile.

---

### ðŸ§© Why Is This Important?

Imagine you have 50 branches.
You DO NOT want to create 50 pipeline jobs manually.

Multibranch automates ALL of this.

---

### ðŸ” How It Works (Visualization)

```mermaid
flowchart LR
    Repo[Git Repository] --> Scan[ðŸ” Jenkins Branch Scan]

    Scan --> BranchA[Pipeline: feature/login]
    Scan --> BranchB[Pipeline: feature/payment]
    Scan --> BranchC[Pipeline: hotfix-001]
    Scan --> PR1[Pipeline: Pull Request #17]
```

Each of these will:

- Have its own build history
- Run its own Jenkinsfile
- Auto-delete when the branch is deleted

---

### ðŸŽ¯ Advantages

- Full automation of branch pipelines
- Ideal for microservices and GitFlow
- Auto-discovers new branches/PRs
- Keeps pipelines isolated

---

### âš ï¸ Limitations

- Requires repo structure to be clean
- Jenkinsfile must exist in every branch
- Scanning large repos may be slow

---

## ðŸª 4. GitHub Organization / Bitbucket Organization Project

> âœ” Best for enterprises with many repos  
> âœ” Auto-discovers repos + branches  
> âœ” Basically Multibranch but across ENTIRE org

---

### ðŸ§  What Is It?

Jenkins connects to:

- GitHub Organization
- Bitbucket Team
- GitLab Group

It then automatically:

- Lists all repositories
- Finds which repos contain a Jenkinsfile
- Creates a multibranch pipeline for EACH repo

---

### ðŸ¢ Example Scenario

A company with:

```ini
org/
 â”œâ”€â”€ payments-service
 â”œâ”€â”€ auth-service
 â”œâ”€â”€ analytics-service
 â”œâ”€â”€ mobile-app
 â”œâ”€â”€ frontend-react
```

Creating pipelines manually for 50+ repos = âŒ  
GitHub Organization job solves this = âœ”

---

### ðŸŽ¯ Advantages

- Automatic onboarding of new repositories
- Fully dynamic
- Zero manual configuration
- Great for microservices

---

### âš ï¸ Limitations

- Requires proper repo permissions
- Scans may be expensive for large orgs
- Requires correct Jenkinsfile placement

---

## ðŸ”„ 5. External Job

> âœ” Used for jobs triggered outside Jenkins  
> âœ” Jenkins only collects results

---

### ðŸ§  What Is It?

An **External Job** is triggered OUTSIDE Jenkins (CLI/APIs), usually from:

- Cron jobs
- External systems
- Legacy apps

Jenkins only records:

- Whether it ran
- Logs
- Status

---

### ðŸŽ¯ Example

Legacy system runs:

```ini
jenkins-cli build external-job-name
```

Jenkins shows results, but doesnâ€™t run anything internally.

---

### âš ï¸ Rarely used today

Most teams prefer:

- Pipelines
- Remote triggers via webhook

---

## ðŸ§ 6. Maven Project

> âœ” Legacy job type for Maven builds  
> âœ” Offers special Maven integrations

---

### ðŸ§  What Is It?

A **Maven Project** automatically understands:

- Maven lifecycle
- Modules
- POM structure

This job type runs Maven goals and shows Maven-specific reports like:

- Test results
- Dependency graphs
- Module build times

---

### ðŸ’¡ But modern Jenkins best practice?

Use **Pipeline Project** instead:

```groovy
sh 'mvn clean install'
```

Maven Project is now considered legacy.

---

## ðŸ‹ï¸ 7. Multi-Configuration Project (Matrix Job)

> âœ” Run same job across multiple configurations  
> âœ” OS matrix, JDK matrix, env matrix  
> âœ” Parallel execution

---

### ðŸ§  What Is It?

A **Matrix job** lets you run the same task across combinations of parameters.

Example matrix:

| OS      | JDK    | Browser |
| ------- | ------ | ------- |
| Linux   | JDK 11 | Chrome  |
| Linux   | JDK 17 | Firefox |
| Windows | JDK 17 | Chrome  |

Each combination becomes a separate job run.

---

### ðŸŽ¯ Example Use Cases

- Test Python app on multiple versions
- Run tests on different OS
- Cross-browser testing
- Library builds per JDK

---

### ðŸ›  Visualization

```mermaid
graph TD
    A[Jenkins Matrix Job]
    A --> B[Linux + JDK 11]
    A --> C[Linux + JDK 17]
    A --> D[Windows + JDK 11]
    A --> E[Windows + JDK 17]
```

---

### âš ï¸ Limitations

- Old UI
- Hard to maintain
- Replaced by Pipeline + `matrix` directive

### Example:

```groovy
// this will create 4 jobs [Linux + JDK 11, Linux + JDK 17, Windows + JDK 11, Windows + JDK 17]
matrix {
    axes {
        axis { name 'JDK'; values '11', '17' }
        axis { name 'OS'; values 'linux', 'windows' }
    }
    stages {
        stage('Test') {
            steps {
                sh 'run-tests.sh'
            }
        }
    }
}
```

---

## ðŸ—‚ï¸ 8. Folder

> âœ” Not a job type  
> âœ” But critical for organizing large Jenkins setups

---

### ðŸ§  Why Use Folders?

You can group pipelines and projects by:

- Team
- Microservice
- Environment
- Business unit

Folders also allow:

- Role-based security
- Credential scoping
- Better navigation in large setups

---

## ðŸ§© Summary Table

| Project Type                     | Best For               | UI or Code? | Modern Usage                         |
| -------------------------------- | ---------------------- | ----------- | ------------------------------------ |
| **Freestyle**                    | Simple jobs            | UI          | Medium                               |
| **Pipeline**                     | Modern CI/CD           | Code        | ðŸ”¥ HIGH                              |
| **Multibranch Pipeline**         | Branch automation      | Code        | ðŸ”¥ðŸ”¥ VERY HIGH                       |
| **GitHub/Bitbucket Org**         | Auto-managing repos    | Code        | ðŸ”¥ðŸ”¥ VERY HIGH                       |
| **External Job**                 | External triggers      | N/A         | Low                                  |
| **Maven Project**                | Maven builds           | UI          | Low (legacy)                         |
| **Multi-Configuration (Matrix)** | Testing across configs | UI          | Medium â†’ Replaced by Pipeline Matrix |
| **Folder**                       | Organization           | N/A         | Essential                            |

---

## ðŸŽ‰ Final Takeaway

Think of Jenkins project types like apps on your phone:

- **Freestyle = Simple Notes App**
- **Pipeline = Full IDE**
- **Multibranch = Auto-create IDE per branch**
- **GitHub Org = Auto-create IDE per repo**
- **Matrix Job = Testing lab**
- **Maven Project = Old Maven plugin**
- **Folders = Folders on your phone**
