Love this direction ğŸ˜ Reusable workflow is **exactly** what you want here.

Letâ€™s do this in 3 parts:

1. Why **reusable workflow** (not custom action) is the right tool
2. The **generic reusable workflow** (lives in one repo, used by many)
3. How to call it from:

   * your **monorepo** (console.api + dashboard.api)
   * a **single-project repo** (one Dockerfile)

---

## 1ï¸âƒ£ Why reusable workflow, not custom action?

You need:

* Multiple jobs:

  * `prepare-meta` (SHA, branch/env, semver)
  * `build-and-push` (matrix build)
  * `update-helm-chart` (other repo)
* Permissions, `needs`, matrix, `workflow_call` inputs, and secrets.

ğŸ‘‰ A **composite action** can only define **steps in a single job**, no jobs, no `workflow_call`.

So:

* âœ… **Reusable workflow** (with `on: workflow_call`)
  â†’ perfect for â€œbuild + tag + push + update Helmâ€ logic.
* âŒ Custom action
  â†’ too limited for this multi-job CI/CD.

Weâ€™ll put the reusable workflow in a **shared repo**, e.g.:

> `orchida-tax/workflows`
> (you *already* use that repo for `test_api` image in Helm)

---

## 2ï¸âƒ£ Reusable workflow: `backend-docker-and-helm.yml`

In repo: **`orchida-tax/workflows`**

Create: `.github/workflows/backend-docker-and-helm.yml`

This is a general template that:

* Builds **one or more services** (matrix from JSON)
* Tags images with:

  * `sha-<FULL_SHA>`
  * `<branch>-<SHORT_SHA>`
  * `<branch>-latest`
  * `<SHORT_SHA>-<build_tag>` (for Helm)
  * `vX.Y.Z` and `X.Y.Z` on tag push
* Updates your **Helm repo** (`orchida-tax/helm-deployments`) for the services you specify.

```yaml
name: Backend Docker build + Helm update (reusable)

on:
  workflow_call:
    inputs:
      container_registry:
        description: "Container registry hostname"
        required: false
        default: ghcr.io
        type: string

      services:
        description: >
          JSON array of { "service": "<image-name>", "dockerfile": "<path>" }.
          Example:
          [
            {"service":"console.api","dockerfile":"core/osTaxConsoleCore/DockerFile"},
            {"service":"dashboard.api","dockerfile":"core/osDashboardApi/DockerFile"}
          ]
        required: true
        type: string

      helm_repo:
        description: "Helm repo (owner/repo)"
        required: false
        default: "orchida-tax/helm-deployments"
        type: string

      helm_chart_path:
        description: "Path to chart inside helm_repo"
        required: false
        default: "helm-deployments/OrchidaTax"
        type: string

      helm_services:
        description: "Space-separated list of Helm services to update (e.g. 'pub_api extractor_api dashboard_api')"
        required: true
        type: string

    secrets:
      gh_pat:
        description: "PAT with access to helm repo"
        required: true

permissions:
  contents: read
  packages: write

env:
  CONTAINER_REGISTRY: ${{ inputs.container_registry }}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1) Prepare metadata
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
jobs:
  prepare-meta:
    name: Prepare build metadata
    runs-on: ubuntu-latest

    outputs:
      short_sha: ${{ steps.sha.outputs.short_sha }}
      full_sha: ${{ steps.sha.outputs.full_sha }}
      branch_safe: ${{ steps.branch.outputs.branch_safe }}
      build_tag: ${{ steps.buildtag.outputs.build_tag }}
      ref_type: ${{ steps.ref.outputs.ref_type }}
      ref_name: ${{ steps.ref.outputs.ref_name }}
      version_tag: ${{ steps.version.outputs.version_tag }}
      plain_version: ${{ steps.version.outputs.plain_version }}

    steps:
      - name: Expose ref info
        id: ref
        run: |
          echo "ref_type=${{ github.ref_type || 'branch' }}" >> "$GITHUB_OUTPUT"
          echo "ref_name=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"

      - name: Compute commit SHAs
        id: sha
        run: |
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"
          echo "full_sha=$GITHUB_SHA" >> "$GITHUB_OUTPUT"

      - name: Compute branch-safe name
        id: branch
        run: |
          EVENT_NAME="${{ github.event_name }}"
          REF_TYPE="${{ github.ref_type || 'branch' }}"
          REF_NAME="${{ github.ref_name }}"
          BASE_REF="${{ github.base_ref }}"

          # For PRs: use the base branch (where we're merging into)
          if [ "$EVENT_NAME" = "pull_request" ] && [ -n "$BASE_REF" ]; then
            BRANCH_RAW="$BASE_REF"
          elif [ "$REF_TYPE" = "branch" ]; then
            BRANCH_RAW="$REF_NAME"
          else
            BRANCH_RAW=""
          fi

          if [ -n "$BRANCH_RAW" ]; then
            BRANCH_SAFE=$(echo "$BRANCH_RAW" | tr '[:upper:]' '[:lower:]' | tr '/_' '-')
          else
            BRANCH_SAFE=""
          fi

          echo "branch_safe=$BRANCH_SAFE" >> "$GITHUB_OUTPUT"

      - name: Determine build tag (dev / qa / latest)
        id: buildtag
        run: |
          EVENT_NAME="${{ github.event_name }}"
          REF_TYPE="${{ github.ref_type || 'branch' }}"
          REF_NAME="${{ github.ref_name }}"
          BASE_REF="${{ github.base_ref }}"

          if [ "$EVENT_NAME" = "pull_request" ] && [ -n "$BASE_REF" ]; then
            TARGET_BRANCH="$BASE_REF"
          elif [ "$REF_TYPE" = "branch" ]; then
            TARGET_BRANCH="$REF_NAME"
          else
            TARGET_BRANCH=""
          fi

          BUILD_TAG="dev"  # default

          # SemVer tag push â†’ qa
          if [[ "$REF_TYPE" = "tag" && "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            BUILD_TAG="qa"
          fi

          case "$TARGET_BRANCH" in
            dev)
              BUILD_TAG="dev"
              ;;
            alfa)
              BUILD_TAG="dev"
              ;;
            main)
              BUILD_TAG="latest"
              ;;
          esac

          echo "build_tag=$BUILD_TAG" >> "$GITHUB_OUTPUT"

      - name: Determine semantic version (for tag pushes)
        id: version
        run: |
          REF_TYPE="${{ github.ref_type || 'branch' }}"
          REF_NAME="${{ github.ref_name }}"

          VERSION_TAG=""
          PLAIN_VERSION=""

          if [ "$REF_TYPE" = "tag" ] && [[ "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION_TAG="$REF_NAME"
            PLAIN_VERSION="${REF_NAME#v}"
          fi

          echo "version_tag=$VERSION_TAG" >> "$GITHUB_OUTPUT"
          echo "plain_version=$PLAIN_VERSION" >> "$GITHUB_OUTPUT"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2) Build & push images (matrix over services)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-and-push:
    name: Build & Push backend images
    needs: prepare-meta
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(inputs.services) }}
        # Each element: { "service": "...", "dockerfile": "..." }

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image tags for ${{ matrix.service.service }}
        id: meta
        env:
          REGISTRY: ${{ env.CONTAINER_REGISTRY }}
          REPOSITORY: ${{ github.repository }}                # e.g. orchida-tax/tax-api or other repo
          SERVICE: ${{ matrix.service.service }}
          DOCKERFILE: ${{ matrix.service.dockerfile }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
          FULL_SHA: ${{ needs.prepare-meta.outputs.full_sha }}
          BRANCH_SAFE: ${{ needs.prepare-meta.outputs.branch_safe }}
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          REF_TYPE: ${{ needs.prepare-meta.outputs.ref_type }}
          VERSION_TAG: ${{ needs.prepare-meta.outputs.version_tag }}
          PLAIN_VERSION: ${{ needs.prepare-meta.outputs.plain_version }}
        run: |
          IMAGE_NAME="${REGISTRY}/${REPOSITORY}/${SERVICE}"

          TAGS=""

          # 1) Full SHA tag
          TAGS+="${IMAGE_NAME}:sha-${FULL_SHA}"

          # 2) branch-short_sha & branch-latest
          if [ -n "$BRANCH_SAFE" ]; then
            TAGS+=$'\n'"${IMAGE_NAME}:${BRANCH_SAFE}-${SHORT_SHA}"
            TAGS+=$'\n'"${IMAGE_NAME}:${BRANCH_SAFE}-latest"
          fi

          # 3) Helm-compatible tag SHORTSHA-build_tag
          TAGS+=$'\n'"${IMAGE_NAME}:${SHORT_SHA}-${BUILD_TAG}"

          # 4) Semver tags (for release tags)
          if [ "$REF_TYPE" = "tag" ] && [ -n "$VERSION_TAG" ]; then
            TAGS+=$'\n'"${IMAGE_NAME}:${VERSION_TAG}"
            if [ -n "$PLAIN_VERSION" ]; then
              TAGS+=$'\n'"${IMAGE_NAME}:${PLAIN_VERSION}"
            fi
          fi

          echo "IMAGE_NAME=$IMAGE_NAME"
          echo "DOCKERFILE=$DOCKERFILE"
          echo "Final tags:"
          echo "$TAGS"

          {
            echo "image_name=$IMAGE_NAME"
            echo "dockerfile=$DOCKERFILE"
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Build & push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ steps.meta.outputs.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3) Update Helm chart
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  update-helm-chart:
    name: Update Helm chart with new image tags
    needs:
      - prepare-meta
      - build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helm chart repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.helm_repo }}
          ref: main
          path: helm-deployments
          token: ${{ secrets.gh_pat }}

      - name: Install yq
        run: |
          VERSION=v4.45.1
          BINARY=yq_linux_amd64
          wget "https://github.com/mikefarah/yq/releases/download/${VERSION}/${BINARY}.tar.gz" -O - | \
          tar xz && sudo mv "${BINARY}" /usr/bin/yq

      - name: Update image tags in Helm values
        env:
          HELM_SERVICES: ${{ inputs.helm_services }}
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
          CHART_PATH: ${{ inputs.helm_chart_path }}
        run: |
          cd "$CHART_PATH"

          IMAGE="$SHORT_SHA"
          echo "Setting tag to ${IMAGE}-${BUILD_TAG} for services: $HELM_SERVICES"

          set -x
          for service in $HELM_SERVICES; do
            echo "Updating service: $service"
            if [[ "$BUILD_TAG" == "latest" ]]; then
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-staging.yaml
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-prod.yaml
            else
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-${BUILD_TAG}.yaml
            fi
          done
          set +x

      - name: Commit and push Helm chart changes
        env:
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
        run: |
          cd ${{ inputs.helm_chart_path }}
          IMAGE="${SHORT_SHA}"

          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          git add .
          git commit -m "Update backend-services tags for ${BUILD_TAG} environment to ${IMAGE}-${BUILD_TAG}" || echo "No changes to commit"
          git push origin main
```

---

## 3ï¸âƒ£ How to use this reusable workflow

### A) From your **monorepo** (`orchida-tax/tax-api`)

Create in that repo: `.github/workflows/backend-ci.yml`

```yaml
name: Backend CI (monorepo)

on:
  push:
    branches: [ dev, alfa, main ]
    tags: [ "v*.*.*" ]
  pull_request:
    branches: [ dev, alfa, main ]
    types: [closed]
  workflow_dispatch:

jobs:
  backend:
    uses: orchida-tax/workflows/.github/workflows/backend-docker-and-helm.yml@main
    with:
      services: |
        [
          {"service":"console.api","dockerfile":"core/osTaxConsoleCore/DockerFile"},
          {"service":"dashboard.api","dockerfile":"core/osDashboardApi/DockerFile"}
        ]
      helm_services: "pub_api extractor_api dashboard_api"
      container_registry: ghcr.io
      helm_repo: "orchida-tax/helm-deployments"
      helm_chart_path: "helm-deployments/OrchidaTax"
    secrets:
      gh_pat: ${{ secrets.GH_PAT }}
```

This will:

* Build:

  * `ghcr.io/orchida-tax/tax-api/console.api:...`
  * `ghcr.io/orchida-tax/tax-api/dashboard.api:...`
* Update Helm:

  * `.services.pub_api.image.tag`
  * `.services.extractor_api.image.tag`
  * `.services.dashboard_api.image.tag`

---

### B) From a **single-project repo** (one Dockerfile)

Example repo: `orchida-tax/ap-peppol`
with a root `Dockerfile`, and a Helm service `peppol_ap`.

In that repo: `.github/workflows/backend-ci.yml`

```yaml
name: AP Peppol CI

on:
  push:
    branches: [ dev, alfa, main ]
    tags: [ "v*.*.*" ]
  pull_request:
    branches: [ dev, alfa, main ]
    types: [closed]
  workflow_dispatch:

jobs:
  backend:
    uses: orchida-tax/workflows/.github/workflows/backend-docker-and-helm.yml@main
    with:
      services: |
        [
          {"service":"ap-peppol","dockerfile":"Dockerfile"}
        ]
      helm_services: "peppol_ap"
      container_registry: ghcr.io
      helm_repo: "orchida-tax/helm-deployments"
      helm_chart_path: "helm-deployments/OrchidaTax"
    secrets:
      gh_pat: ${{ secrets.GH_PAT }}
```

That will:

* Build: `ghcr.io/orchida-tax/ap-peppol/ap-peppol:<tags>`
* Update: `.services.peppol_ap.image.tag` in your Helm chart.

---

If you show me one of your **single-project reposâ€™ structure** (just a short tree + Dockerfile path + Helm service name), I can give you tailored YAML for that one as a concrete example.
