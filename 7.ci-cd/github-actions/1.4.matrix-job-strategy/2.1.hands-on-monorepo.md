# ‚úçüèª **Hands-on: Matrix Workflow for Monorepo**

## üß± 1. Monorepo Structure

Assume your repo looks like this:

```text
my-monorepo/
‚îú‚îÄ services/
‚îÇ  ‚îú‚îÄ api/
‚îÇ  ‚îÇ  ‚îú‚îÄ package.json
‚îÇ  ‚îÇ  ‚îî‚îÄ ...
‚îÇ  ‚îú‚îÄ web/
‚îÇ  ‚îÇ  ‚îú‚îÄ package.json
‚îÇ  ‚îÇ  ‚îî‚îÄ ...
‚îÇ  ‚îî‚îÄ worker/
‚îÇ     ‚îú‚îÄ package.json
‚îÇ     ‚îî‚îÄ ...
‚îú‚îÄ shared/
‚îÇ  ‚îî‚îÄ lib/   (shared code, optional)
‚îî‚îÄ .github/
   ‚îî‚îÄ workflows/
      ‚îî‚îÄ ci.yml
```

Each `services/*` folder is a **separate app**.

For example, `services/api/package.json`:

```json
{
  "name": "api",
  "version": "1.0.0",
  "scripts": {
    "lint": "eslint .",
    "test": "npm test",
    "build": "npm run build"
  }
}
```

Same idea for `web` and `worker`.

---

## üß™ 2. Goal: One Workflow, Test All Services Using a Matrix

We want:

- **One workflow file** (`ci.yml`)
- **One job** that runs **for each service** (`api`, `web`, `worker`)
- Steps: checkout ‚Üí setup Node ‚Üí install ‚Üí test ‚Üí build

We‚Äôll use a **matrix** over `service`.

---

## ‚öôÔ∏è 3. Basic Matrix Workflow for Monorepo

Create `.github/workflows/ci.yml`:

```yaml
name: Monorepo CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test-and-build:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        service: [api, web, worker]

    defaults:
      run:
        working-directory: services/${{ matrix.service }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            services/${{ matrix.service }}/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build
        run: npm run build
```

### üîç What‚Äôs happening?

- `strategy.matrix.service: [api, web, worker]`

  - GitHub creates **3 parallel jobs**:

    - `test-and-build (service=api)`
    - `test-and-build (service=web)`
    - `test-and-build (service=worker)`

- `defaults.run.working-directory: services/${{ matrix.service }}`

  - Every `run:` step executes **inside the correct subfolder**.

- `cache-dependency-path`

  - Cache is per service, based on its `package-lock.json`.

You can adapt `npm ci`, `npm test`, `npm run build` to `dotnet test`, `mvn test`, `pytest`, etc.

---

## üß† 4. Adding OS + Service Matrix (More Realistic)

Now let‚Äôs say you want:

- Multiple services (`api`, `web`)
- Multiple OS (`ubuntu`, `windows`)

Update matrix:

```yaml
strategy:
  fail-fast: false
  matrix:
    os: [ubuntu-latest, windows-latest]
    service: [api, web]
```

And set `runs-on` to use `matrix.os`:

```yaml
jobs:
  test-and-build:
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        service: [api, web]

    defaults:
      run:
        working-directory: services/${{ matrix.service }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build
        run: npm run build
```

You now get jobs like:

- `ubuntu-latest + api`
- `ubuntu-latest + web`
- `windows-latest + api`
- `windows-latest + web`

---

## üßπ 5. Excluding or Customizing for Some Services

### üî∏ Example: Only build `web` on Windows, others only on Ubuntu

```yaml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest]
    service: [api, web]
    exclude:
      - os: windows-latest
        service: api
```

Now combos:

- ‚úÖ ubuntu + api
- ‚úÖ ubuntu + web
- ‚úÖ windows + web
- ‚ùå windows + api (excluded)

---

## üöÄ 6. Split Jobs by Responsibility (Lint / Test / Build) But Same Matrix

You might want separate jobs, but all driven by the same matrix.

### ‚úÖ Lint + Test + Build as separate jobs

```yaml
name: Monorepo CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [api, web, worker]

    defaults:
      run:
        working-directory: services/${{ matrix.service }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm ci
      - run: npm run lint

  test:
    runs-on: ubuntu-latest
    needs: lint
    strategy:
      matrix:
        service: [api, web, worker]

    defaults:
      run:
        working-directory: services/${{ matrix.service }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm ci
      - run: npm test

  build:
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        service: [api, web, worker]

    defaults:
      run:
        working-directory: services/${{ matrix.service }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm ci
      - run: npm run build
```

Each job has **the same matrix**:

- `lint (service=api/web/worker)`
- `test (service=api/web/worker)`
- `build (service=api/web/worker)`

And they run in dependency order via `needs`.

---

## üéØ 7. Only Run for Services That Changed (Dynamic Matrix ‚Äì Advanced but Useful)

For monorepos, you usually want:

> ‚ÄúIf only `services/web` changed, don‚Äôt waste time running `api` and `worker`.‚Äù

We can approximate this with:

1. A **prepare job** that figures out which services changed.
2. A **test job** that uses a **dynamic matrix** from that output.

### Step 1 ‚Äì prepare-matrix job

```yaml
jobs:
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}

    steps:
      - uses: actions/checkout@v4

      - name: Get changed files
        id: changes
        run: |
          # For PRs: compare against the base
          git fetch origin ${{ github.base_ref }} --depth=1 || true
          git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt

      - name: Compute affected services
        id: set-matrix
        run: |
          services=()

          while IFS= read -r file; do
            case "$file" in
              services/api/*)
                services+=('"api"')
                ;;
              services/web/*)
                services+=('"web"')
                ;;
              services/worker/*)
                services+=('"worker"')
                ;;
            esac
          done < changed_files.txt

          # Remove duplicates
          unique_services=$(printf '%s\n' "${services[@]}" | sort -u | paste -sd "," -)

          if [ -z "$unique_services" ]; then
            # If nothing detected, run all
            unique_services='"api","web","worker"'
          fi

          echo "Detected services: [$unique_services]"

          echo "matrix={\"service\":[${unique_services}]}" >> $GITHUB_OUTPUT
```

> **Note:** For pushes (non-PR) you might diff against `HEAD~1` instead of `github.base_ref`.

### Step 2 ‚Äì use the matrix in another job

```yaml
test-and-build:
  needs: prepare-matrix
  runs-on: ubuntu-latest

  strategy:
    fail-fast: false
    matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

  defaults:
    run:
      working-directory: services/${{ matrix.service }}

  steps:
    - uses: actions/checkout@v4

    - uses: actions/setup-node@v4
      with:
        node-version: 20

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

    - name: Build
      run: npm run build
```

Now the `test-and-build` job‚Äôs matrix is **generated dynamically**:

- Only services that actually changed are included.
- If nothing is detected (e.g., only README changed), you can choose to:

  - run all services (as in example), or
  - skip the job entirely (more complex logic).

---

## üßØ 8. Control Parallelism for Monorepo Matrix

If you have:

- Many services, or
- Heavy tests, or
- Self-hosted runner

Use `max-parallel`:

```yaml
strategy:
  fail-fast: false
  max-parallel: 2
  matrix:
    service: [api, web, worker, admin, mobile]
```

This will **only run 2 services at a time**, queueing the others.

---

## üßæ 9. Summary ‚Äì Monorepo + Matrix Checklist

For a monorepo, a good **starter CI** is:

1. **Matrix over `service`**:
   `matrix.service: [api, web, worker]`
2. **Use `defaults.run.working-directory`** to avoid repeating paths.
3. **Cache per service** using `cache-dependency-path`.
4. Optionally add **OS** to the matrix to test cross-platform.
5. Use **separate jobs** (`lint`, `test`, `build`) but same matrix and `needs`.
6. For performance, add **dynamic matrix** based on changed files.

---

If you tell me your **actual monorepo tech** (e.g., ‚Äú.NET services in `src/ServiceA`, `src/ServiceB`‚Äù or ‚ÄúYarn workspaces‚Äù), I can rewrite the YAML and commands **exactly** for your stack so you can just copy‚Äìpaste into your repo.
