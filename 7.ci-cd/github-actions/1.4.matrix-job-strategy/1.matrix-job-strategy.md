# ðŸ“– What is `strategy` in a GitHub Actions job?

Inside a workflow, each **job** can have a `strategy` section:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      # stuff goes here (matrix, fail-fast, max-parallel)
```

`strategy` mainly controls:

- **`matrix`** â€“ Run the job multiple times with different variables (Node versions, OS, DB, etc.).
- **`fail-fast`** â€“ Stop other matrix jobs when one fails.
- **`max-parallel`** â€“ Limit how many matrix jobs run at the same time.

---

## ðŸ§© Matrix Strategy â€“ The Main One

### ðŸ”¹ Basic matrix example

Run the same build on **multiple Node.js versions**:

```yaml
name: Node CI

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16, 18, 20]

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test
```

This will automatically create **3 parallel jobs**:

- `build (node-version=16)`
- `build (node-version=18)`
- `build (node-version=20)`

All steps are the same, just the value of `matrix.node-version` changes.

---

### ðŸ”¹ Multiple dimensions matrix (OS + Node)

```yaml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest]
    node-version: [18, 20]
```

This creates combinations:

- ubuntu-latest + Node 18
- ubuntu-latest + Node 20
- windows-latest + Node 18
- windows-latest + Node 20

Full job:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node-version: [18, 20]

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - run: npm ci
      - run: npm test
```

**Use case:** Quickly test your app on **different OS + runtimes**.

---

## ðŸŽ¯ Include / Exclude Specific Combinations

Sometimes you donâ€™t want all combinations.

### ðŸ”¹ Exclude some combinations

Example: Donâ€™t run Node 20 on Windows:

```yaml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest]
    node-version: [18, 20]
    exclude:
      - os: windows-latest
        node-version: 20
```

Now your matrix becomes:

- ubuntu-latest + 18 âœ…
- ubuntu-latest + 20 âœ…
- windows-latest + 18 âœ…
- windows-latest + 20 âŒ (excluded)

---

### ðŸ”¹ Include extra â€œspecialâ€ combinations

Sometimes you want a **main matrix**, plus **one special case**.

```yaml
strategy:
  matrix:
    os: [ubuntu-latest]
    node-version: [18, 20]
    include:
      - os: windows-latest
        node-version: 20
        extra-flag: true
```

Then in your job:

```yaml
steps:
  - name: Conditional step for special combo
    if: ${{ matrix.extra-flag == true }}
    run: echo "Running extra checks on Windows + Node 20"
```

So the matrix will be:

- ubuntu-latest + 18
- ubuntu-latest + 20
- windows-latest + 20 (+ `extra-flag=true`)

---

## ðŸ”´ `fail-fast` - Controlling Failure Behavior

By default, if one matrix job fails, **GitHub Actions cancels the others** to save time. Thatâ€™s `fail-fast: true` (default).

### ðŸ”¹ Turn off fail-fast

If you want to **see all failures** (for example, which platforms are broken), disable it:

```yaml
strategy:
  fail-fast: false
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node-version: [18, 20]
```

Now, even if Ubuntu + Node 18 fails, Windows and macOS jobs will continue.
Useful for:

- Libraries supporting many platforms.
- When you want a **full test report** instead of early cancel.

---

## ðŸƒðŸ»â€â™‚ï¸ Limiting Parallelism â€“ `max-parallel`

Matrix builds can become huge and eat your runners/credits.

### ðŸ”¹ Limit how many run at once

```yaml
strategy:
  max-parallel: 2
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node-version: [18, 20]
```

Now, although 6 combinations exist, only **2 jobs run at a time**, the rest wait in queue.

**Use cases:**

- You have a **self-hosted runner** with limited CPU/RAM.
- You want to **avoid hitting concurrency limits** or overloading external test systems (e.g., test DB, rate-limited API).

---

## âœðŸ» Using Matrix for App Variants (Not just runtimes)

Matrix isnâ€™t only for Node/OS. You can model **app configurations**:

### ðŸ”¹ Example: Run tests with different DB backends

```yaml
jobs:
  integration-tests:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        db: [mysql, postgres]

    steps:
      - uses: actions/checkout@v4

      - name: Start services
        run: docker-compose -f docker-compose.${{ matrix.db }}.yml up -d

      - name: Run integration tests (${{ matrix.db }})
        run: |
          export DB_ENGINE=${{ matrix.db }}
          ./run-tests.sh
```

This will:

- Start tests using MySQL config.
- Start tests using PostgreSQL config.

---

## ðŸ”ž Dynamic Matrix (from previous step output) â€“ Advanced Strategy

You can **generate a matrix at runtime** using `fromJSON` + job outputs.

### ðŸ”¹ Example idea

1. First job calculates which environments need testing.
2. Second job uses that JSON as matrix.

```yaml
jobs:
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          echo 'matrix={"env":["dev","staging"]}' >> $GITHUB_OUTPUT

  test:
    needs: prepare-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
      - run: echo "Running tests on ${{ matrix.env }}"
```

Now `test` job dynamically uses the `env` list returned by `prepare-matrix`.

---

## âœ… Common Patterns / Strategies Summary

Here are typical **real-world strategies** youâ€™ll use:

1. **Cross-version testing**

   - Test on many runtime or tool versions (Node, Python, Java, .NET).

2. **Cross-platform testing**

   - Test on different OS (`ubuntu`, `windows`, `macos`).

3. **Feature or config matrix**

   - Test enabled/disabled flags, DBs, modules, regions, etc.

4. **Exhaustive but safe**

   - Use `fail-fast: false` to see all broken combinations.

5. **Resource-safe**

   - Use `max-parallel` to control CI workload.

6. **Smart filtering**

   - `include` / `exclude` to remove useless combos and add special ones.

7. **Dynamic matrix**

   - Generate matrix based on changed files, labels, or other logic.
