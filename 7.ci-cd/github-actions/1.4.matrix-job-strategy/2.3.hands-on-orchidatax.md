Nice, thanks for sharing the old pipeline üëå
Let‚Äôs clean this up and modernize it a bit while **keeping the same behavior** (SHORT_SHA + build_tag for Helm).

I‚Äôll give you:

1. ‚úÖ Refactored GitHub Actions workflow (with a matrix per service, no need for docker-compose in CI)
2. ‚úÖ Refactored `docker-compose.build.yml` (if you still want it for local builds)

---

## 1Ô∏è‚É£ Refactored GitHub Actions workflow (monorepo + matrix)

### üîß What this version does

* Still builds **all backend services** in the monorepo.
* Pushes images to **GHCR**.
* Uses **matrix** per service (instead of `docker compose build`).
* Creates tags like:
  `ghcr.io/<owner>/<repo>/<service>:<SHORT_SHA>-<build_tag>`
* Exposes the same outputs:

  * `image` ‚Üí `SHORT_SHA`
  * `build_tag` ‚Üí `dev | qa | latest`
    so your Helm update logic still works without changes.

> üìù Make sure service names in `SERVICES_NAMES` match your Helm `values-*.yaml` structure.

Create/update: `.github/workflows/build-and-push-backend.yml`

```yaml
name: Build .NET Backend services and Push the images to container registry

on:
  push:
    tags:
      - "v*.*.*"        # e.g. v1.2.3
  pull_request:
    branches:
      - dev
      - alfa
    types: [closed]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  CONTAINER_REGISTRY: ghcr.io
  # Used by the Helm update job
  SERVICES_NAMES: "pub_api extractor_api dashboard_api"

jobs:
  prepare-meta:
    name: Prepare build metadata (sha & tag)
    runs-on: ubuntu-latest

    outputs:
      short_sha: ${{ steps.sha.outputs.short_sha }}
      build_tag: ${{ steps.tag.outputs.build_tag }}

    steps:
      - name: Get Short Commit SHA
        id: sha
        run: |
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"

      - name: Determine build tag (dev / qa / latest)
        id: tag
        run: |
          BUILD_TAG="dev" # default

          # Tag push -> qa
          if [[ "${GITHUB_REF}" == refs/tags/v*.*.* ]]; then
            BUILD_TAG="qa"
          fi

          # For PR closed, use base branch (dev / alfa / main)
          if [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            TARGET_BRANCH="${{ github.base_ref }}"
          else
            TARGET_BRANCH="${GITHUB_REF#refs/heads/}"
          fi

          case "$TARGET_BRANCH" in
            alfa)
              BUILD_TAG="dev"
              ;;
            main)
              BUILD_TAG="latest"
              ;;
          esac

          echo "Resolved BUILD_TAG=$BUILD_TAG for TARGET_BRANCH=$TARGET_BRANCH"
          echo "build_tag=$BUILD_TAG" >> "$GITHUB_OUTPUT"

  build-and-push:
    name: Build & Push backend images
    needs: prepare-meta
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - service: console.api
            dockerfile: core/osTaxConsoleCore/DockerFile
          - service: dashboard.api
            dockerfile: core/osDashboardApi/DockerFile
          # add more services here if needed

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
      # Optional but good for multi-arch / caching
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push image for ${{ matrix.service }}
        env:
          REGISTRY: ${{ env.CONTAINER_REGISTRY }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
        run: |
          IMAGE_NAME="${REGISTRY}/${OWNER}/${REPO}/${{ matrix.service }}"
          IMAGE_TAG="${SHORT_SHA}-${BUILD_TAG}"

          echo "Building ${IMAGE_NAME}:${IMAGE_TAG}"

          docker build \
            -f ${{ matrix.dockerfile }} \
            -t "${IMAGE_NAME}:${IMAGE_TAG}" \
            .

          docker push "${IMAGE_NAME}:${IMAGE_TAG}"

  update-helm-chart:
    name: Update Helm chart with new image tags
    needs:
      - prepare-meta
      - build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helm chart repository
        uses: actions/checkout@v4
        with:
          repository: orchida-tax/helm-deployments
          ref: 'main'
          path: helm-deployments
          token: ${{ secrets.GH_PAT }}

      - name: Install yq
        run: |
          VERSION=v4.45.1
          BINARY=yq_linux_amd64
          wget https://github.com/mikefarah/yq/releases/download/${VERSION}/${BINARY}.tar.gz -O - | \
          tar xz && sudo mv ${BINARY} /usr/bin/yq

      - name: Update image tags in Helm values
        env:
          SERVICES_NAMES: ${{ env.SERVICES_NAMES }}
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
        run: |
          cd helm-deployments/OrchidaTax
          IMAGE="${SHORT_SHA}"
          echo "Updating values for BUILD_TAG=$BUILD_TAG with IMAGE=${IMAGE}-${BUILD_TAG}"

          set -x
          for service in $SERVICES_NAMES; do
            echo "Updating service: $service"
            if [[ "$BUILD_TAG" == "latest" ]]; then
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-staging.yaml
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-prod.yaml
            else
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-${BUILD_TAG}.yaml
            fi
          done
          set +x

      - name: Commit and push Helm chart changes
        env:
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
        run: |
          cd helm-deployments/OrchidaTax
          IMAGE="${SHORT_SHA}"
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add .
          git commit -m "Update backend-services tags for ${BUILD_TAG} environment to ${IMAGE}-${BUILD_TAG}" || echo "No changes to commit"
          git push origin main
```

### üîë Key improvements

* **Separation of concerns**: `prepare-meta` only decides `SHORT_SHA` + `build_tag`.
* `build-and-push` uses a **matrix per service** (no docker-compose needed in CI).
* `update-helm-chart` still uses exactly `SHORT_SHA` + `build_tag`, so your Helm values remain compatible.

---

## 2Ô∏è‚É£ Refactored `docker-compose.build.yml` (optional / for local dev)

If you still want a compose file (e.g., for local builds), I‚Äôd simplify it to use a single `IMAGE_TAG` env instead of `SHORT_SHA` + `build_tag` separately:

```yaml
version: "3.9"

services:
  console.api:
    image: ${CONTAINER_REGISTRY:-ghcr.io}/${GITHUB_REPOSITORY}/console.api:${IMAGE_TAG:-local}
    build:
      context: .
      dockerfile: core/osTaxConsoleCore/DockerFile

  dashboard.api:
    image: ${CONTAINER_REGISTRY:-ghcr.io}/${GITHUB_REPOSITORY}/dashboard.api:${IMAGE_TAG:-local}
    build:
      context: .
      dockerfile: core/osDashboardApi/DockerFile
```

Then:

* For **local** builds:

  ```bash
  export IMAGE_TAG=my-local-test
  docker compose -f docker-compose.build.yml build
  ```

* If you **really** want to reuse it in CI with the old scheme:

  ```bash
  IMAGE_TAG="${SHORT_SHA}-${BUILD_TAG}" docker compose -f docker-compose.build.yml build
  ```

‚Ä¶but with the new matrix build in CI, you *don‚Äôt need* compose there anymore.

---

If you want, next step I can also add **multi-tag support** (sha_full, branch-short, branch-latest, semver tag) on top of this refactor, but still keep `SHORT_SHA-build_tag` for Helm so you don‚Äôt break anything.
