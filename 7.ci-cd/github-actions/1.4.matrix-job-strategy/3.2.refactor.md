Perfect, dropping `docker-compose` from CI is a good move ğŸ‘
Iâ€™ll give you a **refactored pipeline** that:

* Builds **directly** with `docker build` via `docker/build-push-action` (no compose).
* Builds **two images** from this repo:

  * `console.api`  â†’ used by `pub_api` + `extractor_api`
  * `dashboard.api` â†’ used by `dashboard_api`
* Keeps the **same Helm behaviour**:

  * Helm values get tags like: `<SHORT_SHA>-<build_tag>`
  * `build_tag` = `dev | qa | latest` depending on branch/tag
* Adds **better Docker tagging** (optional but nice):

  * `sha-<full_sha>`
  * `<branch>-<short_sha>`
  * `<branch>-latest`
  * `<short_sha>-<build_tag>` (for Helm)
  * plus `vX.Y.Z` / `X.Y.Z` for release tags

You can paste this as:
`.github/workflows/backend-build-and-push.yml`

---

## ğŸ” Refactored pipeline (no docker-compose)

```yaml
name: Build .NET Backend services and Push images to GHCR

on:
  push:
    branches:
      - dev
      - alfa
      - main
    tags:
      - "v*.*.*"         # e.g. v1.2.3
  pull_request:
    branches:
      - dev
      - alfa
      - main
    types: [closed]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  CONTAINER_REGISTRY: ghcr.io
  # Helm services whose .image.tag will be updated
  SERVICES_NAMES: "pub_api extractor_api dashboard_api"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1) prepare-meta: compute sha, branch, env (build_tag), semver
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
jobs:
  prepare-meta:
    name: Prepare build metadata
    runs-on: ubuntu-latest

    outputs:
      short_sha: ${{ steps.sha.outputs.short_sha }}
      full_sha: ${{ steps.sha.outputs.full_sha }}
      branch_safe: ${{ steps.branch.outputs.branch_safe }}
      build_tag: ${{ steps.buildtag.outputs.build_tag }}
      ref_type: ${{ steps.ref.outputs.ref_type }}
      ref_name: ${{ steps.ref.outputs.ref_name }}
      version_tag: ${{ steps.version.outputs.version_tag }}
      plain_version: ${{ steps.version.outputs.plain_version }}

    steps:
      - name: Expose ref info
        id: ref
        run: |
          echo "ref_type=${{ github.ref_type || 'branch' }}" >> "$GITHUB_OUTPUT"
          echo "ref_name=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"

      - name: Compute commit SHAs
        id: sha
        run: |
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"
          echo "full_sha=$GITHUB_SHA" >> "$GITHUB_OUTPUT"

      - name: Compute branch-safe name
        id: branch
        run: |
          EVENT_NAME="${{ github.event_name }}"
          REF_TYPE="${{ github.ref_type || 'branch' }}"
          REF_NAME="${{ github.ref_name }}"
          BASE_REF="${{ github.base_ref }}"

          # For PRs: we care about the target (base) branch
          if [ "$EVENT_NAME" = "pull_request" ] && [ -n "$BASE_REF" ]; then
            BRANCH_RAW="$BASE_REF"
          elif [ "$REF_TYPE" = "branch" ]; then
            BRANCH_RAW="$REF_NAME"
          else
            BRANCH_RAW=""
          fi

          if [ -n "$BRANCH_RAW" ]; then
            BRANCH_SAFE=$(echo "$BRANCH_RAW" | tr '[:upper:]' '[:lower:]' | tr '/_' '-')
          else
            BRANCH_SAFE=""
          fi

          echo "branch_safe=$BRANCH_SAFE" >> "$GITHUB_OUTPUT"

      - name: Determine build tag (dev / qa / latest)
        id: buildtag
        run: |
          EVENT_NAME="${{ github.event_name }}"
          REF_TYPE="${{ github.ref_type || 'branch' }}"
          REF_NAME="${{ github.ref_name }}"
          BASE_REF="${{ github.base_ref }}"

          # Decide which branch to map to an environment
          if [ "$EVENT_NAME" = "pull_request" ] && [ -n "$BASE_REF" ]; then
            TARGET_BRANCH="$BASE_REF"
          elif [ "$REF_TYPE" = "branch" ]; then
            TARGET_BRANCH="$REF_NAME"
          else
            TARGET_BRANCH=""
          fi

          BUILD_TAG="dev"  # default

          # Tag push (SemVer) â†’ qa
          if [[ "$REF_TYPE" = "tag" && "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            BUILD_TAG="qa"
          fi

          # Branch-based override
          case "$TARGET_BRANCH" in
            dev)
              BUILD_TAG="dev"
              ;;
            alfa)
              # if alfa is also pointing to dev cluster, keep as dev
              BUILD_TAG="dev"
              ;;
            main)
              BUILD_TAG="latest"
              ;;
          esac

          echo "build_tag=$BUILD_TAG" >> "$GITHUB_OUTPUT"

      - name: Determine semantic version (for tag pushes)
        id: version
        run: |
          REF_TYPE="${{ github.ref_type || 'branch' }}"
          REF_NAME="${{ github.ref_name }}"

          VERSION_TAG=""
          PLAIN_VERSION=""

          if [ "$REF_TYPE" = "tag" ] && [[ "$REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION_TAG="$REF_NAME"
            PLAIN_VERSION="${REF_NAME#v}"
          fi

          echo "version_tag=$VERSION_TAG" >> "$GITHUB_OUTPUT"
          echo "plain_version=$PLAIN_VERSION" >> "$GITHUB_OUTPUT"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2) build-and-push: build console.api & dashboard.api via matrix
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-and-push:
    name: Build & Push backend images
    needs: prepare-meta
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          # backend APIs in this repo
          - service: console.api
            dockerfile: core/osTaxConsoleCore/DockerFile
          - service: dashboard.api
            dockerfile: core/osDashboardApi/DockerFile

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image tags for ${{ matrix.service }}
        id: meta
        env:
          REGISTRY: ${{ env.CONTAINER_REGISTRY }}
          REPOSITORY: ${{ github.repository }}          # e.g. orchida-tax/tax-api
          SERVICE: ${{ matrix.service }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
          FULL_SHA: ${{ needs.prepare-meta.outputs.full_sha }}
          BRANCH_SAFE: ${{ needs.prepare-meta.outputs.branch_safe }}
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          REF_TYPE: ${{ needs.prepare-meta.outputs.ref_type }}
          VERSION_TAG: ${{ needs.prepare-meta.outputs.version_tag }}
          PLAIN_VERSION: ${{ needs.prepare-meta.outputs.plain_version }}
        run: |
          IMAGE_NAME="${REGISTRY}/${REPOSITORY}/${SERVICE}"

          TAGS=""

          # 1) Full SHA tag (good for rollbacks)
          TAGS+="${IMAGE_NAME}:sha-${FULL_SHA}"

          # 2) branch-short_sha & branch-latest (only if branch context exists)
          if [ -n "$BRANCH_SAFE" ]; then
            TAGS+=$'\n'"${IMAGE_NAME}:${BRANCH_SAFE}-${SHORT_SHA}"
            TAGS+=$'\n'"${IMAGE_NAME}:${BRANCH_SAFE}-latest"
          fi

          # 3) Helm-compatible tag SHORTSHA-build_tag
          #    This is what your Helm values file uses (e.g. f499b29-dev)
          TAGS+=$'\n'"${IMAGE_NAME}:${SHORT_SHA}-${BUILD_TAG}"

          # 4) Semver tags when pushing a Git tag (vX.Y.Z)
          if [ "$REF_TYPE" = "tag" ] && [ -n "$VERSION_TAG" ]; then
            TAGS+=$'\n'"${IMAGE_NAME}:${VERSION_TAG}"
            if [ -n "$PLAIN_VERSION" ]; then
              TAGS+=$'\n'"${IMAGE_NAME}:${PLAIN_VERSION}"
            fi
          fi

          echo "Final tags for ${IMAGE_NAME}:"
          echo "$TAGS"

          {
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Build & push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3) update-helm-chart: bump tags in orchida-tax/helm-deployments
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  update-helm-chart:
    name: Update Helm chart with new image tags
    needs:
      - prepare-meta
    # build-and-push must succeed; GitHub enforces that automatically
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Helm chart repository
        uses: actions/checkout@v4
        with:
          repository: orchida-tax/helm-deployments
          ref: main
          path: helm-deployments
          token: ${{ secrets.GH_PAT }}

      - name: Install yq
        run: |
          VERSION=v4.45.1
          BINARY=yq_linux_amd64
          wget "https://github.com/mikefarah/yq/releases/download/${VERSION}/${BINARY}.tar.gz" -O - | \
          tar xz && sudo mv "${BINARY}" /usr/bin/yq

      - name: Update image tags in Helm values
        env:
          SERVICES_NAMES: ${{ env.SERVICES_NAMES }}             # pub_api extractor_api dashboard_api
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
        run: |
          cd helm-deployments/OrchidaTax

          IMAGE="$SHORT_SHA"
          echo "Setting tag to ${IMAGE}-${BUILD_TAG} for services: $SERVICES_NAMES"

          set -x
          for service in $SERVICES_NAMES; do
            echo "Updating service: $service"
            if [[ "$BUILD_TAG" == "latest" ]]; then
              # main -> staging & prod use same tag
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-staging.yaml
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-prod.yaml
            else
              # dev / qa
              yq -i ".services.${service}.image.tag = \"${IMAGE}-${BUILD_TAG}\"" values-${BUILD_TAG}.yaml
            fi
          done
          set +x

      - name: Commit and push Helm chart changes
        env:
          BUILD_TAG: ${{ needs.prepare-meta.outputs.build_tag }}
          SHORT_SHA: ${{ needs.prepare-meta.outputs.short_sha }}
        run: |
          cd helm-deployments/OrchidaTax
          IMAGE="${SHORT_SHA}"

          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          git add .
          git commit -m "Update backend-services tags for ${BUILD_TAG} environment to ${IMAGE}-${BUILD_TAG}" || echo "No changes to commit"
          git push origin main
```

---

### ğŸ§  Summary of what this does (in your terms)

* **Builds images:**

  * `ghcr.io/orchida-tax/tax-api/console.api:<many-tags>`
  * `ghcr.io/orchida-tax/tax-api/dashboard.api:<many-tags>`
* **Helm still uses:**
  `f499b29-dev` / `abc1234-qa` / `xyz7890-latest`
  via `.services.<service>.image.tag`
* **`pub_api` and `extractor_api`** â†’ both use `console.api` image
* **`dashboard_api`** â†’ uses `dashboard.api` image

And now: **no `docker-compose` in CI at all** ğŸ‰

If you want, next step we can add **dynamic matrix** (build only console.api when core/backend changes, etc.) but thatâ€™s optional sugar on top.
