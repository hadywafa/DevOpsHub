# ğŸ³ Caching for Docker Builds in GitHub Actions

> **Official Definition (simplified):**  
> Docker layer caching reuses previously built image layers so that unchanged layers donâ€™t need to rebuild or re-download during subsequent runs.

Translation:

> Docker cache = â€œDonâ€™t rebuild what hasnâ€™t changed, genius.â€ ğŸ˜

---

## âš™ï¸ Why Docker Cache Matters

Every Dockerfile command (`FROM`, `RUN`, `COPY`, etc.) creates a **layer**.  
When you rebuild an image, Docker only rebuilds layers that changed â€” **if** it still has the previous layers available.

But in GitHub Actions, runners are ephemeral (they disappear after each run).  
So your precious Docker cache ğŸ’€ dies with them... unless you **save it manually**.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ§± Dockerfile Layers"] -->|Build| B["ğŸ³ Local Layer Cache"]
    B -->|Runner ends| C["ğŸ’£ Cache lost"]
    C -->|Use actions/cache| D["ğŸ’¾ GitHub Cache Storage"]
    D -->|Next run| E["ğŸš€ Restored Cache"]
```

</div>

---

## ğŸ§© Option 1 â€” Caching with `actions/cache`

The most universal approach: store Dockerâ€™s build cache directory in GitHubâ€™s cache storage.

### Example

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Move new cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
```

### How it works

- **`actions/cache`** stores `/tmp/.buildx-cache` between runs.
- Buildx uses it as a **local cache source** and writes updates to `cache-to`.
- You then replace the old cache with the new one for next runs.

---

## âš¡ Option 2 â€” BuildKit + Registry Cache (Recommended for Teams)

> ğŸ’¡ Best for multi-runner pipelines or shared caches across environments.

Instead of local cache directories, Docker can **push cache layers to a container registry** like GitHub Container Registry (GHCR), AWS ECR, or Azure ACR.

### Example (GHCR)

```yaml
- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v3

- name: Build and push image with registry cache
  uses: docker/build-push-action@v6
  with:
    context: .
    push: true
    tags: ghcr.io/${{ github.repository }}:latest
    cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:buildcache
    cache-to: type=registry,ref=ghcr.io/${{ github.repository }}:buildcache,mode=max
```

### Explanation

- `cache-from`: pulls previous build layers from GHCR.
- `cache-to`: pushes new cache layers after build.
- `mode=max`: keeps all layers possible (great for shared pipelines).

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
sequenceDiagram
    participant G as ğŸ§‘â€ğŸ’» GitHub Action
    participant R as ğŸ³ Docker Buildx
    participant C as ğŸ·ï¸ Container Registry (GHCR)

    G->>R: Start Build
    R->>C: ğŸ” Fetch cache (cache-from)
    alt Cache hit
        C-->>R: âœ… Layer restored
    else Cache miss
        R->>C: ğŸš§ Build new layers
        R->>C: ğŸ’¾ Push cache (cache-to)
    end
    R-->>G: ğŸš€ Image built
```

</div>

---

## ğŸ§  Layer Caching Best Practices

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Layer                     | Cachable? | Notes                                                |
| ------------------------- | --------- | ---------------------------------------------------- |
| `FROM` base image         | âœ…        | Cached if same tag & digest                          |
| `RUN apt-get install ...` | âœ…        | Cache invalidates when package list changes          |
| `COPY package.json`       | âœ…        | Keep dependency files separate for faster caching    |
| `COPY . .`                | âš ï¸        | Avoid copying entire repo early (breaks cache often) |
| `RUN npm install`         | âœ…        | Depends on previous `COPY` layer                     |

</div>

### Example of Cache-Friendly Dockerfile

```dockerfile
FROM node:18
WORKDIR /app

# 1ï¸âƒ£ Copy only dependency files first
COPY package*.json ./

# 2ï¸âƒ£ Install dependencies
RUN npm ci

# 3ï¸âƒ£ Copy remaining files
COPY . .

CMD ["npm", "start"]
```

> ğŸ’¡ Keep `COPY . .` at the bottom â€” otherwise, any code change invalidates all previous layers.

---

## ğŸ§® Combining Cache + Artifact

You can pair cache and artifacts for **hybrid optimization**:

```yaml
- name: Cache Docker layers
  uses: actions/cache@v4
  with:
    path: /tmp/.buildx-cache
    key: ${{ runner.os }}-docker-${{ github.sha }}

- name: Upload build results
  uses: actions/upload-artifact@v4
  with:
    name: built-image
    path: ./dist
```

- Cache â†’ saves layer data between builds.
- Artifact â†’ saves compiled image or binaries between jobs.

---

## ğŸ” Multi-Platform Build Caching (amd64 + arm64)

If youâ€™re building for multiple architectures:

```yaml
- name: Build multi-platform image
  uses: docker/build-push-action@v6
  with:
    context: .
    platforms: linux/amd64,linux/arm64
    push: true
    tags: ghcr.io/${{ github.repository }}:latest
    cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:cache
    cache-to: type=registry,ref=ghcr.io/${{ github.repository }}:cache,mode=max
```

âœ… **BuildKit** automatically manages cache per platform.
âœ… Speeds up both architectures in future runs.

---

## ğŸ§± Shared Cache Between Branches

To reuse caches between branches:

```yaml
cache-from: type=registry,ref=ghcr.io/${{ github.repository }}:buildcache-${{ github.base_ref || 'main' }}
cache-to: type=registry,ref=ghcr.io/${{ github.repository }}:buildcache-${{ github.ref_name }},mode=max
```

That means:

- Each branch maintains its own cache
- But fallbacks to the `main` branch cache when available ğŸª„

---

## ğŸ§© Cache Invalidation Strategy

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Strategy                | Method                                 | When to Use                           |
| ----------------------- | -------------------------------------- | ------------------------------------- |
| **SHA key**             | Use `${{ github.sha }}`                | Forces rebuild for every commit       |
| **Lockfile hash**       | `hashFiles('package-lock.json')`       | Best for dependency-driven rebuilds   |
| **Weekly rotation**     | Include `${{ github.run_number % 7 }}` | Keeps cache fresh                     |
| **Registry digest tag** | Use base image digest                  | When rebuilding on base image updates |

</div>

---

## ğŸ§  Debugging Docker Cache

Add verbosity to inspect cache hits/misses:

```yaml
- name: Debug cache
  run: docker buildx build . --progress=plain
```

or use:

```yaml
- name: Check buildx state
  run: docker buildx du
```

---

## ğŸ§¹ Cleaning Cache in GHCR

If GHCR storage grows large:

```bash
gh api repos/<owner>/<repo>/packages/container/<package>/versions | jq '.[].id' | xargs -I {} gh api -X DELETE repos/<owner>/<repo>/packages/container/<package>/versions/{}
```

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ§± Local Cache (actions/cache)"] --> B["ğŸ³ Buildx"]
    B -->|Optional| C["ğŸ·ï¸ Registry Cache (GHCR/ECR)"]
    C --> D["ğŸš€ Multi-platform Builds"]
    D --> E["â±ï¸ 80% Faster Docker CI"]
```

</div>

---

## ğŸ“˜ Summary Table

| Feature                    | Local Cache (`actions/cache`) | Registry Cache (BuildKit)     |
| -------------------------- | ----------------------------- | ----------------------------- |
| **Scope**                  | Per-runner                    | Global (shared)               |
| **Persistence**            | 7 days (GitHub cache)         | Permanent (in registry)       |
| **Performance**            | Very fast restore             | Depends on network            |
| **Multi-platform support** | âŒ No                         | âœ… Yes                        |
| **Recommended for**        | Small projects                | Enterprise CI/CD              |
| **Example tool**           | `actions/cache@v4`            | `docker/build-push-action@v6` |

---

### ğŸ§© Final Thought

> Docker caching is like remembering what you cooked yesterday â€”
> if the ingredients havenâ€™t changed, why re-chop all the onions again? ğŸ§…

Whether you use **actions/cache** or **registry-based caching**,
the principle is the same: **avoid rebuilding layers unnecessarily**.

Combined with smart cache keys and matrix builds,
your pipelines will go from _â€œpulling all dependencies again?!â€_ â†’ to _â€œinstant builds in under a minute.â€_

---

Would you like me to continue next with **ğŸ§  Topic: Self-hosted Runners + Persistent Docker Caching (Advanced Build Environments)** â€” where Iâ€™ll show how to use persistent disks or volume mounts to keep Docker cache across builds automatically (no manual actions/cache steps)?
