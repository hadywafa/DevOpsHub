# âš¡ **GitHub Actions Cache** â€” The Hidden Performance Engine

Every time your workflow runs, the runner starts on a **fresh VM** with no previous files, packages, or dependencies.
Thatâ€™s great for isolationâ€¦ but painfully slow for builds that must reinstall packages every time.

Enter **`actions/cache`** â€” a built-in GitHub Action that lets you **save and reuse dependencies** or other files between workflow runs, cutting your build time dramatically.

> **Official Definition:**
> GitHubâ€™s caching action enables you to persist files and directories between workflow runs to speed up subsequent jobs that depend on the same data.

Think of it like a â€œshortcutâ€ for your workflows:

> Why redownload 200 MB of npm packages when you could just reuse yesterdayâ€™s node_modules folder?

---

## ğŸ¯ **The Core Concept**

The cache action saves files to **GitHubâ€™s cache storage** (separate from artifacts) using a **unique key**.
When a future workflow runs with the same key, the cache is **restored instantly**, skipping slow installations.

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A[ğŸ—ï¸ Workflow Run #1] -->|Save cache| B[(ğŸ’¾ Cache Storage)]
    B -->|Restore cache| C[âš™ï¸ Workflow Run #2]
    C -->|Reuse node_modules| D[ğŸš€ Faster build]
```

</div>

---

## ğŸ§± **Cache vs Artifact (Quick Comparison)**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Feature                | **Cache**                               | **Artifact**                       |
| ---------------------- | --------------------------------------- | ---------------------------------- |
| **Purpose**            | Speed up jobs by reusing dependencies   | Persist build outputs between jobs |
| **Scope**              | Across workflow runs                    | Within a single workflow run       |
| **Automatic Expiry**   | 7 days (if not accessed)                | Retention policy (default 90 days) |
| **Key Required**       | Yes (for matching)                      | No                                 |
| **Best for**           | npm, pip, Maven, Gradle, Docker layers  | Build files, test reports, logs    |
| **Storage**            | Cache backend                           | Artifact backend                   |
| **Overwrite behavior** | Overwrites existing cache with same key | New upload each time               |

</div>

---

So:

- Use **cache** for _dependencies and tools_.
- Use **artifacts** for _build outputs and results_.

---

## âš™ï¸ **Basic Syntax**

Hereâ€™s how you cache dependencies in a Node.js project:

```yaml
- name: Cache npm dependencies
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-npm-
```

### Explanation

- `path:` â€” The directory to cache (e.g., npm, pip, Gradle).
- `key:` â€” A unique identifier for the cache (must change when dependencies change).
- `restore-keys:` â€” Optional fallback keys (used when exact key doesnâ€™t exist).

---

## ğŸ§  Deep Dive: How `actions/cache@v4` Works

### ğŸ”¹ 1. **Key Generation**

- The `key` is a **unique string** that identifies a cache entry. In your example:

  ```yaml
  key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
  ```

- This resolves to something like:

  ```ini
  Linux-npm-abc123def456
  ```

- `runner.os` â†’ OS-specific (e.g., `Linux`, `Windows`)
- `hashFiles(...)` â†’ SHA-256 hash of the contents of `package-lock.json`
- This ensures the cache is **tied to the exact dependency state**

---

### ğŸ”¹ 2. **Cache Lookup**

- GitHub checks for a cache entry with an **exact match** to the `key`.

- If not found, it tries **fallback keys** from `restore-keys`, like:

  ```yaml
  restore-keys: |
    Linux-npm-
  ```

- This matches any cache key that starts with `Linux-npm-`, such as:

  ```ini
  Linux-npm-xyz987
  ```

> âœ… This allows partial reuse of older caches even if the lockfile changed.

---

### ğŸ”¹ 3. **Cache Restore**

If a match is found (exact or partial):

- The cache archive is downloaded from GitHubâ€™s cache storage
- It is extracted into the specified `path` (e.g., `~/.npm`)
- The runner proceeds with the job using the restored files

---

### ğŸ”¹ 4. **Cache Miss**

If no match is found:

- The job proceeds normally (e.g., runs `npm install`)
- At the end of the job, the cache is **saved** using the original `key`

> âš ï¸ Only one cache can be saved per job, and only if the key was not already used.

---

### ğŸ”¹ 5. **Cache Save**

- The specified `path` is zipped and uploaded to GitHubâ€™s cache storage
- It is stored under the exact `key` used in the job
- Future jobs with the same key will restore this cache

---

### ğŸ”„ Cache Invalidation

If `package-lock.json` changes:

- The hash changes â†’ the `key` changes â†’ cache miss
- But fallback keys may still match and restore a **stale cache**
- This is why itâ€™s important to **pin the key to the lockfile hash**

---

## ğŸ§¬ Detailed Mermaid Diagram

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
    participant W as ğŸ§‘â€ğŸ’» Workflow Runner
    participant A as ğŸ§  Cache Action
    participant S as ğŸ’¾ GitHub Cache Storage
    participant N as ğŸ“¦ Dependency Installer (e.g., npm)

    W->>A: ğŸ”§ Start cache action
    A->>A: ğŸ”‘ Generate key = OS + hash(package-lock.json)
    A->>S: ğŸ” Lookup exact key
    alt Exact match found
        S-->>A: âœ… Return cache archive
        A->>W: ğŸ“‚ Restore to path (e.g., ~/.npm)
    else No exact match
        A->>S: ğŸ” Try restore-keys (prefix match)
        alt Fallback match found
            S-->>A: â™»ï¸ Return older cache
            A->>W: ğŸ“‚ Restore to path
        else No match at all
            A->>W: ğŸš« No cache restored
            W->>N: ğŸ“¦ Install dependencies
        end
    end

    Note over W: Job runs using restored or fresh dependencies

    alt Cache key not used before
        W->>A: ğŸ’¾ Save cache with key
        A->>S: â¬†ï¸ Upload archive
    else Key already used
        A->>W: ğŸš« Skip saving (duplicate key)
    end
```

</div>

---

## ğŸ§° **Common Examples by Language**

### Node.js

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-npm-
```

### Python

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
    restore-keys: |
      ${{ runner.os }}-pip-
```

### Java / Maven

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.m2/repository
    key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
    restore-keys: |
      ${{ runner.os }}-maven-
```

### Gradle

```yaml
- uses: actions/cache@v4
  with:
    path: |
      ~/.gradle/caches
      ~/.gradle/wrapper
    key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
```

### .NET

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
    restore-keys: |
      ${{ runner.os }}-nuget-
```

---

## ğŸ§© **Fallbacks Using Restore Keys**

Restore keys are like **backup patterns** in case the exact key isnâ€™t found.

Example:

```yaml
restore-keys: |
  ubuntu-npm-
```

If your cache key is `ubuntu-npm-abcdef`, but it doesnâ€™t exist,
GitHub will look for any cache starting with `ubuntu-npm-`.

This ensures partial reuse even when lockfiles change slightly.

---

## ğŸ“Š **Caching Strategy Example (Multi-Stage Workflow)**

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
      - run: npm ci
      - run: npm run build
```

**How it helps:**

- First run installs packages normally and saves cache.
- Subsequent runs restore from cache â€” skipping `npm install`.

Average speed improvement: **50â€“70% faster builds**.

---

## ğŸ§  **Best Practices**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Tip                            | Explanation                                                   |
| ------------------------------ | ------------------------------------------------------------- |
| Always use lock files          | Ensures deterministic cache keys                              |
| Use OS in key                  | Avoids cross-platform cache conflicts                         |
| Avoid caching build outputs    | Thatâ€™s for artifacts, not caches                              |
| Donâ€™t overwrite cache keys     | Each key is immutable; use prefixes for new ones              |
| Compress large caches manually | Especially for multi-gigabyte dependencies                    |
| Verify with logging            | Use `actions/cache@v4` output messages to confirm hits/misses |

</div>

---

## ğŸš¨ **Limitations**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Type                  | Limit                                                        |
| --------------------- | ------------------------------------------------------------ |
| Max cache size        | 10 GB per cache entry                                        |
| Total caches per repo | 10 GB Ã— number of keys (shared quota)                        |
| Expiration            | Automatically deleted after 7 days if unused                 |
| Immutability          | Existing cache cannot be updated, only replaced with new key |

</div>

---

If your cache exceeds 10 GB, it will fail silently â€” zip big directories manually if needed.

---

## ğŸ§¹ **Clearing Cache**

You can manually delete caches from:

> **Repository â†’ Actions â†’ Caches â†’ Delete**

Or programmatically via the **GitHub REST API**:

```bash
curl -X DELETE \
  -H "Authorization: token <PAT>" \
  https://api.github.com/repos/<owner>/<repo>/actions/caches/<cache_id>
```

---

## ğŸ§© **Cache + Artifact Hybrid Example**

When both are used together:

```yaml
- name: Cache Dependencies
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}

- name: Upload Build Output
  uses: actions/upload-artifact@v4
  with:
    name: webapp
    path: dist/
```

**Logic:**

- Cache speeds up dependency installs.
- Artifact persists the _resulting_ build files.

**Rule of Thumb:**

> Cache = â€œDonâ€™t redo workâ€
> Artifact = â€œKeep results of workâ€

---

## ğŸ§© **Debugging Caches**

To see whatâ€™s happening under the hood:

```yaml
- name: Debug cache status
  run: echo "Cache key: ${{ steps.cache.outputs.cache-hit }}"
```

If it prints `true`, your cache was restored successfully.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A[ğŸ”¹ Step 1: Workflow starts fresh] --> B[ğŸ”¹ Check cache key match]
    B -->|Found| C[âœ… Restore cache]
    B -->|Not found| D[ğŸ“¦ Install dependencies]
    D --> E[ğŸ’¾ Save new cache]
    C --> F[ğŸš€ Continue build faster]
```

</div>

---

## ğŸ“˜ **Summary Table**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept            | Description                              |
| ------------------ | ---------------------------------------- |
| **Purpose**        | Reuse dependencies between workflow runs |
| **Action**         | `actions/cache@v4`                       |
| **Best Use Cases** | npm, pip, Maven, Gradle, NuGet           |
| **Key Mechanism**  | Unique key + fallback restore keys       |
| **Expiration**     | 7 days after last use                    |
| **Storage**        | GitHub cache backend                     |
| **Limit**          | 10 GB per cache entry                    |
| **Do Not Use For** | Build outputs or runtime artifacts       |

</div>

---

## ğŸ§  **Final Thoughts**

Caching is one of the easiest ways to cut your workflow runtime by half â€” but itâ€™s not a silver bullet.
It shines when:

- Dependencies donâ€™t change often.
- You hash deterministic lockfiles.
- You separate cache (speed) from artifacts (storage).

Once you grasp this, your CI/CD pipelines go from _â€œcoffee break slowâ€_ to _â€œblink-and-itâ€™s-deployedâ€_ fast.

---

Would you like me to continue next with **â€œAdvanced Cache Key Strategies & Conditional Cache Updatesâ€** â€” where Iâ€™ll show smart ways to handle cache invalidation, multi-language caching, and combining caches across matrices (e.g., Node + Python + OS)?
