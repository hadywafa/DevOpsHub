# üóÇÔ∏è **GitHub Actions: File & Repo Structure**

```ini
<repo-root>/
‚îú‚îÄ .github/
‚îÇ  ‚îú‚îÄ workflows/                  # All workflow YAMLs live here
‚îÇ  ‚îÇ  ‚îú‚îÄ ci.yml
‚îÇ  ‚îÇ  ‚îî‚îÄ release.yml
‚îÇ  ‚îú‚îÄ actions/                    # (Optional) Local actions you author
‚îÇ  ‚îÇ  ‚îî‚îÄ my-composite-action/
‚îÇ  ‚îÇ     ‚îú‚îÄ action.yaml           # Required manifest for any action
‚îÇ  ‚îÇ     ‚îî‚îÄ README.md
‚îÇ  ‚îú‚îÄ ISSUE_TEMPLATE/             # Not actions, but often nearby
‚îÇ  ‚îú‚îÄ PULL_REQUEST_TEMPLATE.md
‚îÇ  ‚îî‚îÄ CODEOWNERS
‚îú‚îÄ src/                           # Your application code
‚îú‚îÄ package.json / pom.xml / ...
‚îî‚îÄ README.md
```

- **Workflows** live in **`.github/workflows/*.yml|*.yaml`**. Each file = one workflow.
- **Local (private) actions** live under **`.github/actions/<action-name>/action.yaml`** (or `action.yml`).

  - You can `uses: ./.github/actions/<action-name>` to call them.

- **Reusable workflows** live in `.github/workflows/` too, but are invoked with `uses: owner/repo/.github/workflows/<file>@ref`.

---

## üß¨ **Workflow YAML Schema** (top-level keys)

> A workflow file is a YAML document with these common top-level keys:

- `name: string` ‚Äì Human-friendly workflow name.
- `run-name: string with expressions` ‚Äì Per-run dynamic name.
  Example: `run-name: "Build #${{ github.run_number }} for ${{ github.ref_name }}"`
- `on:` ‚Äì **Triggers** (events) that start the workflow.
- `permissions:` ‚Äì Fine-grained default token scopes for this workflow.
- `env:` ‚Äì Global env vars available to all jobs/steps (can be overridden).
- `defaults:` ‚Äì Default `run` options (shell, working-directory) for all steps.
- `concurrency:` ‚Äì Prevents overlapping runs of the same group; supports cancelation.
- `jobs:` ‚Äì One or more jobs to execute (possibly in parallel).

### ‚úÖ Full list of commonly used top-level keys & value shapes

```yaml
name: "string"
run-name: "string with ${{ expressions }}"
on:
  # see the ‚ÄúEvents & Filters‚Äù section below
permissions: # choose one:
  # 1) Global shortcuts
  #   read-all | write-all
  # 2) Fine-grained scopes (recommended)
  actions: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: read|write|none
  issues: read|write|none
  packages: read|write|none
  pull-requests: read|write|none
  repository-projects: read|write|none
  security-events: read|write|none
  statuses: read|write|none
env:
  KEY: "value"
defaults:
  run:
    shell: bash|sh|pwsh|powershell|cmd|python # default depends on runner OS
    working-directory: path-string
concurrency:
  group: "string with ${{ expressions }}"
  cancel-in-progress: true|false
jobs:
  # see the ‚ÄúJobs‚Äù section below
```

---

## üö¶ **Events & Filters** (`on:`)

You can trigger workflows on events. Each event supports filters. The most common:

```yaml
on:
  push:
    branches: ["main", "release/*"] # or branches-ignore: [...]
    tags: ["v*", "!v0.*"] # or tags-ignore: [...]
    paths: ["src/**", "!docs/**"] # or paths-ignore: [...]
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled, ready_for_review]
    branches: ["main"]
    paths: ["src/**"]
  workflow_dispatch: # manual trigger
    inputs:
      env:
        description: "Target environment"
        required: true
        type: choice
        options: [dev, qa, prod]
        default: dev
      dry_run:
        description: "Skip deployment?"
        required: false
        type: boolean
        default: false
  schedule: # CRON in UTC
    - cron: "0 5 * * 1-5" # 05:00 UTC on weekdays
  workflow_call: # Reusable workflow API
    inputs:
      app: { required: true, type: string }
      retries: { required: false, type: number, default: 2 }
      promote: { required: false, type: boolean, default: false }
    secrets:
      TOKEN: { required: true }
    outputs:
      imageTag:
        description: "Image tag produced"
        value: ${{ jobs.build.outputs.imageTag }}
  repository_dispatch: # External API trigger
    types: ["sync-docs", "reindex"]
  release:
    types: [created, published, prereleased]
  pull_request_target: {} # runs in base repo context (be careful)
```

**Notes:**

- `paths`/`paths-ignore` are **glob** patterns. Negation is supported as shown.
- `schedule.cron` uses **UTC**.
- `workflow_dispatch.inputs[].type` supports `string|choice|boolean|environment` (environment is for environment pickers).
- `workflow_call` makes the workflow callable from other workflows (great for platform templates).

---

## üß± **Jobs** (the real work)

Jobs define execution units. They run in parallel by default, unless you add dependencies.

```yaml
jobs:
  build:
    name: "Build on ${{ matrix.os }} ‚Ä¢ Node ${{ matrix.node }}"
    if: ${{ github.event_name != 'release' }}
    needs: [lint]
    permissions: # override top-level if needed
      contents: read
      packages: write
    runs-on: # runner selection
      - ubuntu-latest # or: windows-latest, macos-latest
      # self-hosted runners:
      # - self-hosted
      # - linux
      # - x64
      # in array: all labels must match
    environment: # environment gates & secrets
      name: prod
      url: https://app.example.com
    concurrency:
      group: build-${{ github.ref_name }}
      cancel-in-progress: true
    timeout-minutes: 30
    continue-on-error: false | ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      max-parallel: 4
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [18, 20]
        include:
          - os: ubuntu-latest
            node: 22
            experimental: true
        exclude:
          - os: windows-latest
            node: 18
    container: # run the job inside a container
      image: node:20-bullseye
      credentials:
        username: ${{ secrets.DOCKERHUB_USER }}
        password: ${{ secrets.DOCKERHUB_PAT }}
      env:
        NPM_CONFIG_FUND: "false"
      volumes:
        - /cache/npm:/home/runner/.npm
      options: --cpus 2
    services: # sidecar containers
      redis:
        image: redis:7
        ports: ["6379:6379"]
        options: --health-cmd "redis-cli ping" --health-interval 5s
        env:
          ALLOW_EMPTY_PASSWORD: "yes"
    outputs:
      imageTag: ${{ steps.build.outputs.imageTag }}
    env:
      CI: "true"
      NODE_ENV: production
    defaults:
      run:
        shell: bash
        working-directory: ./app
    steps:
      # see ‚ÄúSteps‚Äù next
```

**Common job-level keys & values:**

- `name: string`
- `if: expression`
- `needs: [job-id, ...]`
- `permissions: (scoped map like top-level)`
- `runs-on: string | [label, ...]`
- `environment: string | { name: string, url: string }`
- `concurrency.group: string`, `cancel-in-progress: bool`
- `timeout-minutes: number`
- `continue-on-error: bool | expression`
- `strategy.matrix / include / exclude / fail-fast / max-parallel`
- `container.image|credentials|env|volumes|options`
- `services.<name>.image|ports|env|options|credentials`
- `outputs: { <name>: ${{ steps.<id>.outputs.<stepOut> }}`
- `env: map`
- `defaults.run.shell|working-directory`
- `steps: array`

---

## ü™ú **Steps** (within a job)

Each step either **uses** an action or **runs** a command. You can mix both.

```yaml
steps:
  - name: Checkout
    uses: actions/checkout@v4
    with:
      fetch-depth: 0

  - name: Setup Node
    uses: actions/setup-node@v4
    with:
      node-version: ${{ matrix.node }}
      cache: npm

  - name: Install
    run: npm ci
    shell: bash # override default if needed
    working-directory: ./app # override default if needed
    env:
      NPM_CONFIG_AUDIT_LEVEL: low
    timeout-minutes: 10

  - name: Lint
    id: lint
    run: npm run lint -- --format stylish

  - name: Build
    id: build
    run: |
      echo "imageTag=web-${{ github.run_number }}" >> "$GITHUB_OUTPUT"

  - name: Upload artifact
    uses: actions/upload-artifact@v4
    with:
      name: web-dist
      path: app/dist/

  - name: Always run cleanup
    if: ${{ always() }}
    run: rm -rf ~/.cache/something

  - name: Conditional debug (only on failure)
    if: ${{ failure() }}
    run: |
      echo "Previous steps failed" >&2
```

**Step keys & values:**

- `name: string`
- `id: string` (to expose `steps.<id>.outputs` and `steps.<id>.conclusion`)
- `if: expression`
- **EITHER** `uses: owner/repo@ref | ./.github/actions/name | docker://image:tag`
  **OR** `run: string | multiline block`
- `with: map` (for `uses`)
- `env: map`
- `shell: bash|sh|pwsh|powershell|cmd|python|<custom>`
- `working-directory: path`
- `timeout-minutes: number`
- `continue-on-error: bool | expression`

> **Output from a step** (for job/reusable outputs): write to `$GITHUB_OUTPUT`

```bash
echo "myOutput=value" >> "$GITHUB_OUTPUT"
```

---

## üß∞ **Reusable Workflows** (`workflow_call`) & How to Invoke

**Reusable workflow**: `.github/workflows/build-image.yml`

```yaml
name: "Build Image"
on:
  workflow_call:
    inputs:
      app: { type: string, required: true }
      tag: { type: string, required: false, default: latest }
    secrets:
      REGISTRY_TOKEN: { required: true }
    outputs:
      imageRef:
        description: "Built image reference"
        value: ${{ jobs.build.outputs.imageRef }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      imageRef: ${{ steps.meta.outputs.imageRef }}
    steps:
      - uses: actions/checkout@v4

      - id: meta
        run: |
          echo "imageRef=registry.example.com/${{ inputs.app }}:${{ inputs.tag }}" >> "$GITHUB_OUTPUT"

      - name: Login & Push
        run: |
          echo "${{ secrets.REGISTRY_TOKEN }}" | docker login registry.example.com -u token --password-stdin
          docker build -t "${{ steps.meta.outputs.imageRef }}" .
          docker push "${{ steps.meta.outputs.imageRef }}"
```

**Caller workflow** (in another repo or same repo):

```yaml
name: "App CI"
on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Image tag"
        type: string
        default: latest

jobs:
  build-image:
    uses: owner/repo/.github/workflows/build-image.yml@main
    with:
      app: web-frontend
      tag: ${{ inputs.tag }}
    secrets: inherit # OR map specific secrets if not inheriting
    # secrets:
    #   REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
```

**Notes:**

- `secrets: inherit` passes **all** caller secrets to the callee.
- Prefer mapping only required secrets for tighter security when possible.

---

## ü™ù **Expression Language & Contexts** (the brain of conditions)

Use `${{ ... }}` for expressions in keys like `if:`, `run-name:`, `with:`, etc.

**Common contexts:**

- `github` ‚Äì event metadata (`github.event`, `github.ref`, `github.actor`, `github.sha`, `github.ref_name`, ‚Ä¶)
- `env` ‚Äì current environment variables
- `secrets` ‚Äì repository/organization/environment secrets
- `vars` ‚Äì repository/organization/environment **variables** (not secrets)
- `inputs` ‚Äì `workflow_dispatch`/`workflow_call` inputs
- `runner` ‚Äì runner info (`os`, `arch`, `temp`, `workspace`‚Ä¶)
- `matrix` ‚Äì strategy matrix values
- `jobs`, `steps` ‚Äì job/step-level metadata

**Common functions:**

- `startsWith(string, search)`, `endsWith(string, search)`, `contains(haystack, needle)`
- `format("Hello {0}", var)`, `join(array, sep)`
- `toJSON(obj)`, `fromJSON(string)`
- `hashFiles(glob)` ‚Äì deterministic hash for file set
- Status checks: `success()`, `failure()`, `cancelled()`, `always()`

**Examples:**

```yaml
if: ${{ startsWith(github.ref, 'refs/tags/') }}
run-name: "Publish ${{ github.ref_name }} ‚Ä¢ build #${{ github.run_number }}"
```

---

## üîê **Secrets**, **Variables**, and **Environments** (how values flow)

- **Secrets**: `${{ secrets.MY_TOKEN }}` ‚Äì masked in logs; set at repo/org/environment level.
- **Variables**: `${{ vars.MY_FLAG }}` ‚Äì non-secret config; set at repo/org/environment.
- **Environments**: Gate deployments with approvals, attach env-scoped vars/secrets, and show `environment.url` in the UI.

```yaml
jobs:
  deploy:
    environment:
      name: prod
      url: https://app.example.com
    steps:
      - run: echo "Deploying to ${{ vars.REGION }}"
      - run: ./deploy.sh
        env:
          TOKEN: ${{ secrets.DEPLOY_TOKEN }}
```

---

## üß± **Local (Composite) Actions** (reusable building blocks inside your repo)

**Folder:** `.github/actions/my-composite-action/action.yaml`

```yaml
name: "My Composite Action"
description: "Runs lint & tests consistently"
inputs:
  working-directory:
    required: false
    default: "."
  node:
    required: false
    default: "20"
outputs:
  passed:
    description: "true/false if tests passed"
    value: ${{ steps.mark.outputs.passed }}
runs:
  using: "composite"
  steps:
    - uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node }}

    - run: npm ci
      working-directory: ${{ inputs.working-directory }}
      shell: bash

    - run: npm test
      working-directory: ${{ inputs.working-directory }}
      shell: bash

    - id: mark
      run: |
        echo "passed=true" >> "$GITHUB_OUTPUT"
```

**Use it in a workflow:**

```yaml
- uses: ./.github/actions/my-composite-action
  with:
    working-directory: ./app
    node: "20"
```

> Other action types:
>
> - **JavaScript action**: `runs.using: node20` + `main: dist/index.js`
> - **Docker action**: `runs.using: docker` + `image: Dockerfile` + `args: [...]`

---

## ‚úçüèª **Typical CI Workflow** (end-to-end example)

```yaml
# .github/workflows/ci.yml
name: "CI"
run-name: "CI ‚Ä¢ ${{ github.ref_name }} #${{ github.run_number }}"
on:
  push:
    branches: [main]
    paths-ignore: ["docs/**"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

env:
  CI: "true"

defaults:
  run:
    shell: bash

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run lint

  test:
    needs: [lint]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        node: [18, 20]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
          cache: npm
      - run: npm ci
      - run: npm test -- --reporter=junit
      - uses: actions/upload-artifact@v4
        if: ${{ always() }}
        with:
          name: junit-${{ matrix.node }}
          path: reports/junit.xml

  build:
    needs: [test]
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - id: meta
        run: echo "image=ghcr.io/${{ github.repository }}:sha-${{ github.sha }}" >> "$GITHUB_OUTPUT"
      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - run: docker build -t "${{ steps.meta.outputs.image }}" .
      - run: docker push "${{ steps.meta.outputs.image }}"

  deploy:
    if: ${{ github.ref == 'refs/heads/main' && github.event_name != 'pull_request' }}
    needs: [build]
    runs-on: ubuntu-latest
    environment:
      name: prod
      url: https://app.example.com
    steps:
      - run: |
          echo "Deploying ${{ needs.build.outputs.image }} to prod..."
          ./scripts/deploy.sh "${{ needs.build.outputs.image }}"
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
```

---

## üßØ **Caching, Artifacts**, & Common Building Blocks

**Cache (node example):**

```yaml
- uses: actions/setup-node@v4
  with:
    node-version: 20
    cache: npm # automagic
```

or with `actions/cache`:

```yaml
- uses: actions/cache@v4
  with:
    path: ~/.npm
    key: npm-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      npm-${{ runner.os }}-
```

**Artifacts:**

```yaml
- uses: actions/upload-artifact@v4
  with:
    name: dist
    path: dist/
# later
- uses: actions/download-artifact@v4
  with:
    name: dist
    path: ./dist
```

---

## üîí **Permissions Best Practice** (least privilege)

- Set **top-level `permissions:`** to the minimum (often `contents: read`).
- Override per-job if a job needs more (e.g., `packages: write` for pushing images).
- If using OIDC to cloud (AWS/Azure/GCP), ensure `id-token: write`.

Example:

```yaml
permissions:
  contents: read
  id-token: write
```

---

## üß± **Self-Hosted Runners** (label matching)

```yaml
runs-on:
  - self-hosted
  - linux
  - gpu
```

> The job runs on a self-hosted runner that has **all** these labels.

---

## üß™ **Quick Reference**: Common ‚ÄúAll Possible‚Äù Values (cheat sheet)

**Top-level:**

- `on:` push, pull_request, pull_request_target, workflow_dispatch (inputs), workflow_call (inputs/secrets/outputs), schedule (cron), workflow_run, release, repository_dispatch, issues, issue_comment, check_suite, check_run, deployment, deployment_status, create, delete, fork, star, watch, discussion, etc.
- `permissions:` read-all | write-all **or** map of scopes (actions, checks, contents, deployments, id-token, issues, packages, pull-requests, repository-projects, security-events, statuses).
- `defaults.run.shell:` bash | sh | pwsh | powershell | cmd | python (plus custom).
- `concurrency:` `{ group: <string>, cancel-in-progress: <bool> }`

**Jobs:**

- `runs-on:` ubuntu-latest | windows-latest | macos-latest | self-hosted (+labels)
- `strategy.matrix:` arrays & `include`/`exclude` maps; `fail-fast: bool`; `max-parallel: int`
- `container:` image, credentials, env, volumes, options
- `services:` map of service containers with image, ports, env, options
- `environment:` string or `{ name, url }`
- `timeout-minutes: number`
- `continue-on-error: bool|expression`

**Steps:**

- `uses:` remote action (`owner/repo@ref`), local path (`./path`), or `docker://image:tag`
- `run:` command or `|` multiline
- `with:` inputs map
- `if:` expression; `env:` map; `shell:` ‚Ä¶; `id:` string; `timeout-minutes:` number

**Reusable workflows:**

- `workflow_call.inputs[]` types: `string | number | boolean`
- `secrets:` per-name `required: true|false`
- `outputs:` referenced via `$${{ jobs.<id>.outputs.<name> }}`

---

## üß† **Pro Tips & Patterns**

- **Pin actions** to exact versions/tags/SHAs (e.g., `@v4` or SHA) for supply-chain safety.
- Use **`concurrency`** to avoid duplicate deployments on rapid pushes.
- **`paths` / `paths-ignore`** to run only when relevant code changes.
- Put shared logic in **composite actions** or **reusable workflows** (platform engineering mindset).
- Use **`secrets: inherit`** carefully; prefer explicit mapping for least privilege.
- Prefer **matrix** only where it adds value (e.g., OS/Node versions).
- For cloud auth, use **OIDC** (`id-token: write`) instead of long-lived keys.

---

## üß© **Minimal Starter Templates**

### 1) Quick CI on PRs

```yaml
name: PR Check
on:
  pull_request:
    branches: [main]
permissions:
  contents: read
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: npm }
      - run: npm ci
      - run: npm test
```

### 2) Nightly Cron

```yaml
name: Nightly Audit
on:
  schedule:
    - cron: "0 2 * * *" # 02:00 UTC daily
jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm audit --audit-level=high || true
```

### 3) Manual Dispatch with Inputs

```yaml
name: Manual Deploy
on:
  workflow_dispatch:
    inputs:
      env:
        description: "Which environment?"
        type: choice
        options: [dev, qa, prod]
        default: dev
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.env }}
    steps:
      - run: ./deploy.sh "${{ inputs.env }}"
        env:
          TOKEN: ${{ secrets.DEPLOY_TOKEN }}
```
