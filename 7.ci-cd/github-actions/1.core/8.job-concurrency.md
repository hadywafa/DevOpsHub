# âš™ï¸ **GitHub Actions Job Concurrency**

## ğŸ“˜ Official Definition

> **Concurrency** in GitHub Actions controls how many workflow runs can execute simultaneously in a given scope.
>
> It ensures that **only one run of a specific type (e.g., branch, environment, service)** is active at a time â€” older runs can be **canceled** or **queued** automatically.

In other words:

> Itâ€™s your workflowâ€™s â€œtraffic controllerâ€ ğŸ¦º that prevents two jobs from clashing when they modify the same resource.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ‘¨â€ğŸ’» Dev pushes code"]
    B["ğŸ—ï¸ Build Job #1"]
    C["ğŸ—ï¸ Build Job #2"]
    D["ğŸš¦ Concurrency Group"]

    A --> B
    A --> C
    B --> D
    C --> D
    D -->|"Keeps only 1 active"| B
```

</div>

---

## ğŸ¯ Why We Need Concurrency

Without concurrency control, this can happen ğŸ‘‡

- You push multiple commits rapidly to `main`.
- Each push triggers a new workflow run.
- All of them **build** and **deploy** at the same time ğŸ¤¯
- Result: race conditions, broken environments, or half-deployed systems.

Concurrency prevents that mess.

It allows you to:

- Cancel outdated runs automatically
- Prevent overlapping deploys
- Control resources when you have limited runners

---

## ğŸ§© Syntax

You add concurrency at either **workflow** or **job** level:

```yaml
concurrency:
  group: <string>
  cancel-in-progress: <boolean>
```

---

### Example 1 â€” Basic Concurrency

```yaml
name: ğŸš€ Deploy

on:
  push:
    branches: [main]

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying production..."
```

ğŸ§  What happens:

- If a new commit comes to `main` while another deploy is running,
  â†’ the **previous one gets canceled** (`cancel-in-progress: true`).
- Only one job in the **group â€œproduction-deployâ€** runs at a time.

âœ… Ideal for production or staging deployments.

---

### Example 2 â€” Dynamic Group Names

You can make concurrency smarter using **expressions**:

```yaml
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true
```

ğŸ’¡ This creates unique concurrency groups per branch or environment:

<div align="center" style="background:#343739ff; border-radius:20px">

| Branch | Concurrency Group      |
| ------ | ---------------------- |
| main   | deploy-refs/heads/main |
| dev    | deploy-refs/heads/dev  |

</div>

---

Now, `main` and `dev` can deploy independently, but **only one deploy per branch** at a time.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph LR
    subgraph Branches
      M["main"]
      D["dev"]
    end
    subgraph Groups
      G1["deploy-main"]
      G2["deploy-dev"]
    end
    M --> G1
    D --> G2
    G1 -.blocks.-> G1
    G2 -.blocks.-> G2
```

</div>

---

### Example 3 â€” Per Job Concurrency

You can also define concurrency at the **job level**, not globally:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    concurrency:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - run: npm ci && npm run build

  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-${{ github.environment }}
      cancel-in-progress: false
    steps:
      - run: ./deploy.sh
```

âœ… Different jobs can have different concurrency behavior:

- Build â†’ cancels older builds per branch
- Deploy â†’ queued, never canceled (safe for production rollouts)

---

## ğŸ§  Example 4 â€” Concurrency per Environment

```yaml
jobs:
  deploy:
    environment: production
    concurrency:
      group: production-deploy
      cancel-in-progress: false
```

ğŸ§© GitHub automatically enforces concurrency for **environments** (like â€œstagingâ€, â€œprodâ€)
but setting it explicitly gives you more control.

---

## ğŸ§± Example 5 â€” Combining with Matrix Strategy

Letâ€™s say you have a matrix build:

```yaml
jobs:
  build:
    strategy:
      matrix:
        node: [16, 18, 20]
    concurrency:
      group: build-${{ matrix.node }}
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - run: echo "Building Node ${{ matrix.node }}"
```

ğŸ§© Each Node version will run in its own concurrency group:

- build-16
- build-18
- build-20

They run **independently** without blocking each other.

---

## ğŸ’£ Example 6 â€” Without Concurrency (Chaos Mode ğŸ˜ˆ)

```yaml
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - run: ./deploy.sh
```

You push 3 commits quickly:

- 3 deploys start simultaneously
- The newest may finish first, and the oldest overwrites it
- Production now runs an older build ğŸš¨

Concurrency fixes this instantly.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
sequenceDiagram
    participant Dev as ğŸ‘©â€ğŸ’» Dev pushes commits
    participant Queue as âš™ï¸ GitHub Queue
    participant Job1 as ğŸ—ï¸ Job #1
    participant Job2 as ğŸ—ï¸ Job #2
    participant Job3 as ğŸ—ï¸ Job #3

    Dev->>Queue: push commit 1
    Dev->>Queue: push commit 2
    Dev->>Queue: push commit 3
    Queue->>Job1: Start Job #1
    Queue->>Job2: Cancel Job #1, start Job #2
    Queue->>Job3: Cancel Job #2, start Job #3
```

</div>

---

## ğŸ§  Advanced Tip â€” Use Context Variables for Smart Groups

Dynamic concurrency group example:

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true
```

âœ… Each PR gets its own concurrency group.
So builds for different PRs donâ€™t block each other â€” but each PR cancels its own previous run when updated.

---

## âš™ï¸ Example 7 â€” Queued (Instead of Canceled)

You can keep older runs waiting until the current one finishes:

```yaml
concurrency:
  group: nightly-builds
  cancel-in-progress: false
```

ğŸ•“ Meaning:

- If a run is active, new runs are **queued**.
- When the first one finishes, the next starts.

Best for **nightly jobs**, **batch processing**, or **non-destructive updates**.

---

## ğŸ§­ Real-World Use Cases

<div align="center" style="background:#343739ff; border-radius:20px">

| Use Case             | Concurrency Setup                                   | Why                                  |
| -------------------- | --------------------------------------------------- | ------------------------------------ |
| Production Deploy    | `cancel-in-progress: true`                          | Prevents overlapping deploys         |
| Branch Build         | `group: build-${{ github.ref }}`                    | Each branch has isolated concurrency |
| PR Validation        | `group: pr-${{ github.event.pull_request.number }}` | Cancels outdated PR checks           |
| Nightly Jobs         | `cancel-in-progress: false`                         | Queue next after completion          |
| Environment Rollouts | `group: deploy-${{ github.environment }}`           | One deploy per environment           |

</div>

---

## ğŸ’¬ TL;DR by Your Human Mentor

> Think of **concurrency** like a â€œbouncerâ€ at your CI/CD nightclub ğŸ¸.
>
> It lets one workflow in, and if another shows up too soon â€” either makes it wait (queued) or kicks it out (cancel-in-progress).
>
> Use it to prevent:
>
> - double deployments ğŸ§¨
> - wasted builds ğŸ’¸
> - chaos in shared environments ğŸŒªï¸

When used properly, it keeps your pipelines **disciplined, efficient, and predictable**.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ—ï¸ Workflow Run 1"]
    B["ğŸ—ï¸ Workflow Run 2"]
    C["ğŸ—ï¸ Workflow Run 3"]
    D["ğŸš¦ Concurrency Group: deploy-prod"]

    A --> D
    B --> D
    C --> D
    D -->|"Only 1 active at a time"| A
```

</div>

---

## âœ… Summary Table

<div align="center" style="background:#343739ff; border-radius:20px">

| Property             | Description                                                              |
| -------------------- | ------------------------------------------------------------------------ |
| `group`              | Defines which runs belong to the same concurrency group                  |
| `cancel-in-progress` | Cancels running jobs when a new one in the same group starts             |
| `queued behavior`    | When `false`, new runs wait until current one completes                  |
| **Scope**            | Can be defined at workflow or job level                                  |
| **Dynamic Values**   | Supports `${{ github.ref }}`, `${{ github.workflow }}`, PR numbers, etc. |
| **Main Benefit**     | Prevents overlapping or duplicate runs in CI/CD pipelines                |

</div>

---

Would you like me to continue next with â€œConcurrency + Deployment Protection Rulesâ€ (how concurrency interacts with environments, approvals, and protection gates)?
