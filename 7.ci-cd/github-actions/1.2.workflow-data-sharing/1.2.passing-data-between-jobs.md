# ðŸ›³ï¸ **Passing data between jobs**

## ðŸ§± **Basic Syntax**

Hereâ€™s the clean pattern:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - id: build_step
        run: echo "version=1.0.${{ github.run_number }}" >> "$GITHUB_OUTPUT"
    outputs:
      version: ${{ steps.build_step.outputs.version }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo "Deploying version ${{ needs.build.outputs.version }}"
```

âœ… Output example:

```ini
Deploying version 1.0.15
```

---

## ðŸ§© **Step-by-Step Breakdown**

### ðŸ”¹ Step 1 â€” Create a step output

Inside a job, a **step** writes a key/value pair to `$GITHUB_OUTPUT`:

```yaml
- id: build_step
  run: echo "version=1.0.15" >> "$GITHUB_OUTPUT"
```

This means `steps.build_step.outputs.version = "1.0.15"`

---

### ðŸ”¹ Step 2 â€” Expose it as a **job output**

The job collects it under the `outputs:` section:

```yaml
outputs:
  version: ${{ steps.build_step.outputs.version }}
```

Now other jobs can access it.

---

### ðŸ”¹ Step 3 â€” Reference it in another job

The dependent job adds:

```yaml
needs: build
```

and can read:

```yaml
${{ needs.build.outputs.version }}
```

> ðŸš¨ **You must still use** `needs.job_1.outputs.version`, even though job_2 already declares `needs: job_1`.

---

## ðŸ§° **Multi-Output Example (real-world pattern)**

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - id: meta
        run: |
          echo "tag=app-${{ github.run_number }}" >> "$GITHUB_OUTPUT"
          echo "image=ghcr.io/${{ github.repository }}:${{ github.run_number }}" >> "$GITHUB_OUTPUT"
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      image: ${{ steps.meta.outputs.image }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: |
          echo "Deploying image: ${{ needs.build.outputs.image }}"
          echo "Tag: ${{ needs.build.outputs.tag }}"
```

âœ… Output:

```ini
Deploying image: ghcr.io/username/repo:15
Tag: app-15
```

---

## ðŸ”„ **Chaining Multiple Jobs**

You can chain multiple jobs â€” e.g. `build â†’ test â†’ deploy`

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - id: pkg
        run: echo "artifact=dist.zip" >> "$GITHUB_OUTPUT"
    outputs:
      artifact: ${{ steps.pkg.outputs.artifact }}

  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - id: tests
        run: |
          echo "result=passed" >> "$GITHUB_OUTPUT"
    outputs:
      result: ${{ steps.tests.outputs.result }}

  deploy:
    needs: [build, test]
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Deploying ${{ needs.build.outputs.artifact }}"
          echo "Test result: ${{ needs.test.outputs.result }}"
```

âœ… Output:

```ini
Deploying dist.zip
Test result: passed
```

---

## ðŸ§  **Important Rules**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Rule                                                     | Explanation                                   |
| -------------------------------------------------------- | --------------------------------------------- |
| ðŸ”¹ Job A must finish successfully                        | Otherwise dependent job wonâ€™t get its outputs |
| ðŸ”¹ You must use `id:` for the step that sets outputs     | Without it, you canâ€™t reference it            |
| ðŸ”¹ `outputs:` only visible to jobs that `need:` that job | Not global                                    |
| ðŸ”¹ You canâ€™t `needs:` future jobs                        | Only earlier ones                             |
| ðŸ”¹ Each job runs on a separate runner VM                 | No shared filesystem unless you use artifacts |
| ðŸ”¹ Use artifacts for files, outputs for strings          | Outputs are meant for small textual data only |

</div>

---

## ðŸ“¦ **When to Use `outputs` vs `artifacts`**

| Use Case                                  | Use Outputs | Use Artifacts |
| ----------------------------------------- | ----------- | ------------- |
| Pass small values (tags, versions, URLs)  | âœ… Yes      | ðŸš« No         |
| Pass files (ZIPs, reports, build results) | ðŸš« No       | âœ… Yes        |
| Pass JSON or strings < 1MB                | âœ… Yes      | ðŸš« No         |

Example â€” combine both:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - id: build
        run: |
          echo "version=v${{ github.run_number }}" >> "$GITHUB_OUTPUT"
          zip -r dist.zip .
      - uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist.zip
    outputs:
      version: ${{ steps.build.outputs.version }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: dist
      - run: echo "Deploying version ${{ needs.build.outputs.version }}"
```

---

## ðŸ” **Using Outputs Securely (Secrets & Tokens)**

- You canâ€™t store **secrets** in `$GITHUB_OUTPUT` â€” it will be masked if it matches a known secret value.
- If your value contains sensitive data, prefer environment secrets or use `actions/upload-artifact` for secure storage.
- Never echo secret data in logs:

  ```yaml
  run: echo "::add-mask::$SECRET_VALUE"
  ```

---

## ðŸ§© **Realistic CI/CD Example**

```yaml
name: Full Pipeline
on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - id: meta
        run: echo "image_tag=myapp:${{ github.run_number }}" >> "$GITHUB_OUTPUT"
      - run: docker build -t myapp:${{ github.run_number }} .
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - id: test
        run: |
          echo "passed=true" >> "$GITHUB_OUTPUT"
          echo "Testing image ${{ needs.build.outputs.image_tag }}"
    outputs:
      passed: ${{ steps.test.outputs.passed }}

  deploy:
    runs-on: ubuntu-latest
    needs: [build, test]
    if: ${{ needs.test.outputs.passed == 'true' }}
    steps:
      - run: echo "Deploying ${{ needs.build.outputs.image_tag }} to production"
```

âœ… Flow:

1. `build` job builds Docker image and outputs `image_tag`
2. `test` job reads that image and outputs test result
3. `deploy` runs _only if_ test passed

---

## ðŸ§± **Advanced: Dynamic Job Outputs from Reusable Workflows**

If your workflow calls a reusable workflow, you can also expose **outputs** from it.

**Reusable workflow (`.github/workflows/build.yml`):**

```yaml
on:
  workflow_call:
    outputs:
      tag:
        value: ${{ jobs.build.outputs.tag }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
    steps:
      - id: meta
        run: echo "tag=v${{ github.run_number }}" >> "$GITHUB_OUTPUT"
```

**Caller workflow:**

```yaml
jobs:
  call-build:
    uses: ./.github/workflows/build.yml

  deploy:
    needs: call-build
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying tag ${{ needs.call-build.outputs.tag }}"
```

âœ… Result:

```ini
Deploying tag v22
```

---

## ðŸ§© **Debugging Outputs**

If your outputs arenâ€™t showing up:

```yaml
- run: |
    echo "Debugging Outputs"
    echo "Steps outputs:"
    echo "${{ toJSON(steps) }}"
    echo "Needs outputs:"
    echo "${{ toJSON(needs) }}"
```

That will print the entire JSON context, so you can verify names.

---

## âš¡ **Common Mistakes**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Mistake                         | Symptom                                                                      | Fix                                                         |
| ------------------------------- | ---------------------------------------------------------------------------- | ----------------------------------------------------------- |
| Forgetting `id:`                | Canâ€™t access step outputs                                                    | Always use `id:` for any step writing to `$GITHUB_OUTPUT`   |
| Missing `outputs:` at job level | Job outputs undefined                                                        | Add `outputs:` section referencing step outputs             |
| Missing `needs:`                | Downstream job canâ€™t access upstream outputs                                 | Add `needs:` to job dependencies                            |
| Typo in job ID                  | `${{ needs.buld.outputs.version }}` fails                                    | Check job names carefully                                   |
| Quoting wrong variable type     | `${{ steps.build.outputs.version }}` inside `run:` without env interpolation | Use `echo "${{ ... }}"`, not `$steps.build.outputs.version` |

</div>

---

## ðŸ§­ **Mental Model Summary**

```mermaid
flowchart TD
  subgraph Job 1
    A[Step 1] --> B[Step 2 writes to $GITHUB_OUTPUT]
    B -->|outputs| O1[outputs: version]
  end

  subgraph Job 2
    C[needs: Job1] --> D[Use ${{ needs.Job1.outputs.version }}]
  end
```

âœ… `$GITHUB_OUTPUT` connects steps â†’ job outputs connect jobs.

---

## âœ… Final Summary Table

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Level               | Mechanism                | Used For                  | Syntax                                         |
| ------------------- | ------------------------ | ------------------------- | ---------------------------------------------- |
| Step â†’ Step         | `$GITHUB_OUTPUT`         | Passing within a job      | `${{ steps.<id>.outputs.<key> }}`              |
| Job â†’ Job           | `outputs:` + `needs:`    | Passing across jobs       | `${{ needs.<job>.outputs.<key> }}`             |
| Workflow â†’ Workflow | `workflow_call.outputs:` | Passing between workflows | `${{ needs.<called-workflow>.outputs.<key> }}` |

</div>
