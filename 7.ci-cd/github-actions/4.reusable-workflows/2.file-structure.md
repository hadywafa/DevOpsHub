# âš™ï¸ **Reusable Workflow Structure**

## ğŸ“˜ Official Definition

> A **reusable workflow structure** defines how a workflow can receive data (`inputs`), access secure credentials (`secrets`), and return results (`outputs`) when invoked by another workflow via `workflow_call`.

In short, weâ€™re designing **interfaces** between workflows â€” think of them as _APIs for your CI/CD_.

---

## ğŸ§© Anatomy of a Reusable Workflow

Hereâ€™s the basic skeleton â€” the â€œAPI contractâ€ of a reusable workflow.

ğŸ“„ `.github/workflows/build.yml`

```yaml
name: ğŸ”§ Reusable Build Workflow

on:
  workflow_call:
    inputs:
      node-version:
        required: true
        type: string
      environment:
        required: false
        type: string
        default: "dev"
    secrets:
      TOKEN:
        required: true
    outputs:
      build-artifact:
        description: "The name of the build artifact"
        value: ${{ jobs.build.outputs.artifact-name }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      artifact-name: ${{ steps.build.outputs.artifact }}
    steps:
      - uses: actions/checkout@v4

      - name: ğŸ—ï¸ Build app
        id: build
        run: |
          echo "myapp-${{ inputs.environment }}" > artifact.txt
          echo "artifact=myapp-${{ inputs.environment }}" >> $GITHUB_OUTPUT

      - name: ğŸ“¦ Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build.outputs.artifact }}
          path: artifact.txt
```

---

## ğŸ§  Letâ€™s Decode It Like Engineers

<div align="center" style="background:#343739ff; border-radius:20px">

| Section               | Description                                                 |
| --------------------- | ----------------------------------------------------------- |
| `on: workflow_call`   | Defines it as reusable                                      |
| `inputs`              | Parameters passed from the caller (like function arguments) |
| `secrets`             | Secure values injected by the caller (like API tokens)      |
| `outputs`             | Values the reusable workflow returns to the caller          |
| `jobs`                | Contains the logic you want to share                        |
| `outputs` (under job) | Connects internal job results to global workflow outputs    |

</div>

---

## ğŸ§ª How a Caller Workflow Uses It

ğŸ“„ `.github/workflows/main.yml`

```yaml
name: ğŸ§© Main Workflow

on:
  push:
    branches: [ main ]

jobs:
  call-build:
    uses: ./.github/workflows/build.yml
    with:
      node-version: 20
      environment: "staging"
    secrets:
      TOKEN: ${{ secrets.MY_TOKEN }}

  show-result:
    runs-on: ubuntu-latest
    needs: call-build
    steps:
      - name: ğŸ“¢ Show returned artifact name
        run: echo "Artifact name: ${{ needs.call-build.outputs.build-artifact }}"
```

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
sequenceDiagram
    participant Caller as ğŸ§© main.yml
    participant Reusable as ğŸ”§ build.yml
    participant Runner as âš™ï¸ GitHub Runner

    Caller->>Reusable: Pass inputs + secrets
    Reusable->>Runner: Run build steps
    Runner-->>Reusable: Output artifact name
    Reusable-->>Caller: Return output (build-artifact)
    Caller->>Runner: Use output in next job
```

</div>

---

## ğŸ§± Inputs â€” Your Workflowâ€™s â€œFunction Parametersâ€

Inputs make your workflow flexible and configurable.

### âœ… Supported Input Types

<div align="center" style="background:#343739ff; border-radius:20px">

| Type      | Example   | Description                 |
| --------- | --------- | --------------------------- |
| `string`  | `"prod"`  | Default type                |
| `boolean` | `true`    | True/false toggles          |
| `number`  | `42`      | Used for numeric parameters |
| `choice`  | See below | Limit options (advanced)    |

</div>

### ğŸ§© Example of Choice Inputs

```yaml
inputs:
  environment:
    type: choice
    options:
      - dev
      - staging
      - prod
    default: dev
```

This helps enforce controlled environments across teams.

---

## ğŸ” Secrets â€” Injecting Secure Credentials

Secrets are **not hardcoded**; they must be passed explicitly from the caller.

```yaml
on:
  workflow_call:
    secrets:
      TOKEN:
        required: true
```

Caller:

```yaml
jobs:
  call-workflow:
    uses: ./.github/workflows/build.yml
    secrets:
      TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
```

ğŸ§  You canâ€™t access organization-level secrets _inside reusable workflows_ unless theyâ€™re passed from the caller â€” this is a deliberate security boundary.

---

## ğŸ§¾ Outputs â€” Returning Values Like a Pro

You can output anything:

- a build artifact name
- a version string
- a computed tag
- test results summary

Hereâ€™s how the data flows ğŸ‘‡

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ—ï¸ Step Output (GITHUB_OUTPUT)"] --> B["ğŸ“¦ Job Outputs"]
    B --> C["ğŸ§© Workflow Outputs"]
    C --> D["ğŸš€ Caller Workflow"]
```

</div>

---

### ğŸ“¦ Example Flow in Code

1ï¸âƒ£ Inside your step:

```bash
echo "version=1.2.3" >> $GITHUB_OUTPUT
```

2ï¸âƒ£ Expose it at job level:

```yaml
outputs:
  version: ${{ steps.build.outputs.version }}
```

3ï¸âƒ£ Expose it at workflow level:

```yaml
outputs:
  app-version:
    value: ${{ jobs.build.outputs.version }}
```

4ï¸âƒ£ Use it in caller:

```yaml
run: echo "App version is ${{ needs.build.outputs.app-version }}"
```

---

## ğŸ§° Putting It All Together (Mini Real Example)

Letâ€™s simulate a company pipeline:

- Build workflow (shared)
- Deployment workflow (calls build and uses its output)

ğŸ“„ `.github/workflows/build.yml`

```yaml
on:
  workflow_call:
    outputs:
      image-tag:
        value: ${{ jobs.build.outputs.tag }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set.outputs.tag }}
    steps:
      - id: set
        run: echo "tag=v1.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
```

ğŸ“„ `.github/workflows/deploy.yml`

```yaml
jobs:
  call-build:
    uses: ./.github/workflows/build.yml

  deploy:
    needs: call-build
    runs-on: ubuntu-latest
    steps:
      - name: ğŸš€ Deploy using tag
        run: echo "Deploying version ${{ needs.call-build.outputs.image-tag }}"
```

Result â¡ï¸ â€œDeploying version v1.0.25â€

---

## ğŸ§  Real-World Analogy

Reusable workflows are like **microservices for CI/CD**:

- Inputs = API parameters
- Outputs = Response payload
- Secrets = Auth headers
- Jobs = Implementation logic

They make pipelines modular, maintainable, and scalable across repos.

---

## âœ… Summary: Reusable Workflow Blueprint

<div align="center" style="background:#343739ff; border-radius:20px">

| Concept         | Purpose                    | Example                          |
| --------------- | -------------------------- | -------------------------------- |
| `inputs`        | Pass dynamic configuration | `node-version`, `env`            |
| `secrets`       | Pass credentials securely  | `TOKEN`, `AWS_KEY`               |
| `outputs`       | Return computed results    | artifact name, version           |
| `workflow_call` | Makes it callable          | entry point of reusable workflow |

</div>
