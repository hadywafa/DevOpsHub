# ğŸ§­ **Calling a Reusable Workflow (Same Repo, Cross Repo & Org-Level)**

## ğŸ“˜ Official Definition

> You can call a reusable workflow using the `uses:` keyword inside a job.  
> The reference can be:
>
> - **local** (via `./`),
>   - eg. `./.github/workflows/build.yml`
> - **remote** (via repo path),
>   - eg. `myorg/myrepo/.github/workflows/build.yml`
> - **organization-wide** (via `.github` repository)
>   - ,eg `.github/workflows/build.yml`.

Think of it like calling a shared â€œlibrary functionâ€ in programming.
You just import it using the correct path or reference tag.

---

## ğŸ§© Syntax Overview

```yaml
jobs:
  <job_id>:
    uses: <owner>/<repo>/.github/workflows/<workflow_file>@<ref>
```

Or for local workflows:

```yaml
jobs:
  <job_id>:
    uses: ./.github/workflows/<workflow_file>
```

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ§© main.yml (caller)"]
    B["ğŸ—ï¸ build.yml (same repo)"]
    C["ğŸš€ deploy.yml (cross repo)"]
    D["ğŸ¢ org-level workflow (.github repo)"]

    A --> B
    A --> C
    A --> D
```

</div>

---

## ğŸ  1. Calling a Reusable Workflow in the **Same Repository**

This is the simplest and most common case â€” ideal for monorepos or internal pipelines.

ğŸ“ **Repository Structure**

```ini
.github/
â”œâ”€â”€ workflows/
â”‚   â”œâ”€â”€ build.yml       â† reusable workflow
â”‚   â””â”€â”€ main.yml        â† calling workflow
```

ğŸ“„ **main.yml**

```yaml
name: ğŸ§© Local Call Example

on:
  push:
    branches: [main]

jobs:
  build-job:
    uses: ./.github/workflows/build.yml
    with:
      node-version: 20
    secrets:
      TOKEN: ${{ secrets.MY_TOKEN }}
```

### âœ… Key Notes

- No `@ref` is needed (because itâ€™s local).
- You can use relative paths (`./.github/workflows/...`).
- Great for keeping your repo modular but self-contained.

---

## ğŸŒ 2. Calling a Workflow from **Another Repository**

Now we level up â€” this allows teams to share a common workflow across projects.

ğŸ“ **Reference Syntax**

```yaml
uses: <owner>/<repo>/.github/workflows/<workflow_file>@<ref>
```

Example:

```yaml
jobs:
  shared-build:
    uses: my-org/devops/.github/workflows/build.yml@main
    with:
      node-version: 18
    secrets:
      TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
```

### ğŸ’¡ Parameters Explained

<div align="center" style="background:#343739ff; border-radius:20px">

| Field                   | Meaning                                                               |
| ----------------------- | --------------------------------------------------------------------- |
| `<owner>`               | Organization or user name                                             |
| `<repo>`                | Repository name containing workflow                                   |
| `.github/workflows/...` | Path to workflow file                                                 |
| `@<ref>`                | Branch, tag, or commit SHA (recommended: tag or SHA for immutability) |

</div>

### ğŸ§  Best Practice

Use a **version tag or commit SHA** instead of `@main`:

```yaml
uses: my-org/devops/.github/workflows/build.yml@v1.0.0
```

â¡ï¸ This ensures your pipeline doesnâ€™t break if someone updates the reusable workflowâ€™s `main` branch.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
sequenceDiagram
    participant Caller as ğŸ§© Repo A (caller)
    participant Reusable as ğŸ—ï¸ Repo B (shared)
    participant Runner as âš™ï¸ GitHub Runner

    Caller->>Reusable: uses my-org/devops/.github/workflows/build.yml@v1
    Reusable->>Runner: Executes shared build logic
    Runner-->>Reusable: Returns results
    Reusable-->>Caller: Outputs returned to Repo A
```

</div>

---

## ğŸ¢ 3. Calling a Reusable Workflow from an **Org-Level `.github` Repository**

GitHub offers a special **`.github` repository** at the organization level
â€” a hidden gem for large enterprises ğŸ¢.

ğŸ“ **Example structure**

```ini
my-org/.github/
â””â”€â”€ workflows/
    â”œâ”€â”€ build.yml
    â”œâ”€â”€ test.yml
    â””â”€â”€ deploy.yml
```

These workflows become **globally available** to all repositories under the org.

ğŸ“„ **Caller Example**

```yaml
jobs:
  org-build:
    uses: my-org/.github/.github/workflows/build.yml@v1
    with:
      node-version: 18
    secrets:
      TOKEN: ${{ secrets.ORG_DEPLOY_TOKEN }}
```

This means you can:

- Standardize CI/CD logic across all teams
- Update logic in one place
- Avoid repo-specific duplication

---

## ğŸ”’ Permissions Required

Calling reusable workflows across repos or orgs **requires permission**.

- The **caller** must have **read access** to the reusable workflowâ€™s repo.
- The workflow file must exist in a **public repo** (or private with same org).
- The reusable workflow must be in **default branch** unless you specify a ref.

**Cross-repo calling does _not_ work across organizations** unless the reusable repo is public.

---

## ğŸ§  How GitHub Executes This (Under the Hood)

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph LR
    A["Caller Workflow (main.yml)"]
    --> B["GitHub Action Engine"]
    --> C["Reusable Workflow (build.yml)"]
    --> D["Runner Executes Jobs"]
    --> E["Results returned to caller"]
```

</div>

GitHub essentially **imports** the reusable workflow definition,  
executes it within the callerâ€™s permission context,  
and returns outputs + statuses back to the parent.

---

## âš™ï¸ Combining Inputs, Secrets, and Outputs Across Scopes

Hereâ€™s a _cross-repo_ example with everything combined ğŸ‘‡

ğŸ“„ **caller.yml (in app repo)**

```yaml
jobs:
  build:
    uses: my-org/devops/.github/workflows/build.yml@v2
    with:
      environment: prod
    secrets:
      DEPLOY_TOKEN: ${{ secrets.MY_DEPLOY_TOKEN }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying artifact ${{ needs.build.outputs.build-artifact }}"
```

ğŸ“„ **reusable build.yml (in devops repo)**

```yaml
on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    secrets:
      DEPLOY_TOKEN:
        required: true
    outputs:
      build-artifact:
        value: ${{ jobs.build.outputs.artifact }}
```

---

## ğŸ§± Versioning Strategy (Best Practices)

<div align="center" style="background:#343739ff; border-radius:20px">

| Approach       | Description                | Example          |
| -------------- | -------------------------- | ---------------- |
| **Branch ref** | Uses a branch (not stable) | `@main`          |
| **Tag ref**    | Stable reference           | `@v1`, `@v2.3.0` |
| **Commit SHA** | Immutable (most secure)    | `@a1b2c3d4`      |

</div>

---

âœ… Use **tags** for versioned workflows  
âœ… Pin to **SHAs** for high-security environments  
âš ï¸ Avoid `@main` for production workflows

---

## ğŸ§© Pro Tip â€” Combine with Workflow Dispatch

You can also manually trigger reusable workflows from the caller by chaining `workflow_dispatch` events.  
This is useful for environment promotion pipelines (e.g., staging â†’ prod).

---

## ğŸ’¬ Real-World Example: Centralized Build System

**Scenario:**  
Your company has 50 microservices.  
All need the same build + test workflow.

ğŸ“ **Org-level `.github` repo**

```ini
workflows/
â”œâ”€â”€ build.yml
â””â”€â”€ test.yml
```

ğŸ“„ **Each service repo uses:**

```yaml
jobs:
  build:
    uses: my-org/.github/.github/workflows/build.yml@v1
    with:
      node-version: 18
```

Boom ğŸ’¥ â€” instant org-wide CI/CD standardization.

---

## âœ… Summary: Workflow Calling Scopes

<div align="center" style="background:#343739ff; border-radius:20px">

| Scope      | Syntax                                       | Use Case                   |
| ---------- | -------------------------------------------- | -------------------------- |
| Same repo  | `uses: ./.github/workflows/...`              | Modular monorepo           |
| Cross repo | `uses: org/repo/.github/workflows/...@v1`    | Shared between teams       |
| Org-level  | `uses: org/.github/.github/workflows/...@v1` | Enterprise standardization |

</div>
