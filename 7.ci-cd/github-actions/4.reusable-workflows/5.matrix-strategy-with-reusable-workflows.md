# âš™ï¸ Using Matrix Strategy with Reusable Workflows

## ğŸ“˜ Official Definition

> A **matrix strategy** allows you to define multiple configurations (like different environments, OS versions, or runtimes) and run jobs in parallel for each one.
>
> When combined with **reusable workflows**, it lets you reuse the same workflow for many test/build variations dynamically.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ§© Caller Workflow"]
    B1["ğŸ—ï¸ Reusable Workflow (Node 16)"]
    B2["ğŸ—ï¸ Reusable Workflow (Node 18)"]
    B3["ğŸ—ï¸ Reusable Workflow (Node 20)"]

    A --> B1
    A --> B2
    A --> B3
    B1 & B2 & B3 --> C["âš™ï¸ Matrix Execution in Parallel"]
```

</div>

---

## ğŸ§± Why Use Matrix with Reusable Workflows?

Letâ€™s say your reusable workflow defines how to build a Node.js app.
But you want to:

- Test on **multiple Node versions**
- Run on **different OSes**
- Deploy to **multiple environments**

Instead of writing 10 jobs manually â€” you use a **matrix**.

---

## ğŸ§© Example 1: Local Reusable Workflow + Matrix in Caller

ğŸ“„ `.github/workflows/build.yml` (Reusable)

```yaml
name: ğŸ”§ Reusable Build Workflow

on:
  workflow_call:
    inputs:
      node-version:
        required: true
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
      - name: ğŸ—ï¸ Build
        run: |
          echo "Building with Node ${{ inputs.node-version }}"
```

ğŸ“„ `.github/workflows/main.yml` (Caller)

```yaml
name: ğŸ§© Matrix Example

on:
  push:
    branches: [main]

jobs:
  matrix-build:
    strategy:
      matrix:
        node-version: [16, 18, 20]
    uses: ./.github/workflows/build.yml
    with:
      node-version: ${{ matrix.node-version }}
```

âœ… Result:
Three builds run **in parallel**:

```ini
Building with Node 16
Building with Node 18
Building with Node 20
```

Boom ğŸ’¥ â€” you just parallelized your reusable workflow across environments.

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
sequenceDiagram
    participant Caller as ğŸ§© main.yml
    participant Runner as âš™ï¸ GitHub Runner
    participant Build as ğŸ—ï¸ Reusable Workflow

    loop For each Node version (16,18,20)
        Caller->>Build: Call reusable workflow with node-version
        Build->>Runner: Run build steps
        Runner-->>Build: Return build logs
        Build-->>Caller: Complete one matrix job
    end
```

</div>

---

## ğŸ§  Example 2: Multi-Dimension Matrix (OS Ã— Node Version)

ğŸ“„ **main.yml**

```yaml
name: ğŸ§© Multi-Dimension Matrix

on: [push]

jobs:
  build-matrix:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [16, 18]
    uses: ./.github/workflows/build.yml
    with:
      node-version: ${{ matrix.node }}
    runs-on: ${{ matrix.os }}
```

ğŸ§© What Happens:

| OS             | Node |
| -------------- | ---- |
| ubuntu-latest  | 16   |
| ubuntu-latest  | 18   |
| windows-latest | 16   |
| windows-latest | 18   |

4 builds run simultaneously âš™ï¸

---

## ğŸ’¡ Pro Tip: Control Parallelism

By default, matrix runs **all combinations in parallel**.
You can **limit concurrency**:

```yaml
strategy:
  matrix:
    node: [16, 18, 20]
  max-parallel: 2
```

This runs 2 jobs at a time â€” great for managing runner costs.

---

## ğŸ§© Example 3: Returning Outputs per Matrix Job

You can collect **outputs** from each matrix execution and use them later.

ğŸ“„ **Reusable Workflow**

```yaml
on:
  workflow_call:
    inputs:
      node-version:
        required: true
        type: string
    outputs:
      build-name:
        value: ${{ jobs.build.outputs.name }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      name: ${{ steps.name.outputs.value }}
    steps:
      - id: name
        run: |
          echo "value=app-node${{ inputs.node-version }}" >> $GITHUB_OUTPUT
```

ğŸ“„ **Caller Workflow**

```yaml
jobs:
  matrix-build:
    strategy:
      matrix:
        node-version: [16, 18, 20]
    uses: ./.github/workflows/build.yml
    with:
      node-version: ${{ matrix.node-version }}

  collect:
    runs-on: ubuntu-latest
    needs: matrix-build
    steps:
      - run: |
          echo "âœ… Build outputs collected!"
          echo "${{ toJson(needs.matrix-build.outputs) }}"
```

âœ… Output Example:

```json
{
  "16": { "build-name": "app-node16" },
  "18": { "build-name": "app-node18" },
  "20": { "build-name": "app-node20" }
}
```

---

## ğŸ§© Example 4: Cross-Repo Matrix with Reusable Workflow

You can even call reusable workflows **from another repo** in a matrix â€” it scales beautifully.

```yaml
jobs:
  build:
    strategy:
      matrix:
        environment: [dev, staging, prod]
    uses: my-org/devops/.github/workflows/deploy.yml@v2
    with:
      environment: ${{ matrix.environment }}
    secrets:
      TOKEN: ${{ secrets.ORG_TOKEN }}
```

ğŸ¯ Perfect for org-wide deployment pipelines:

- Each environment runs in parallel
- Reusable deploy logic stays centralized

---

## ğŸ§  Understanding Execution Context

<div align="center" style="background:#343739ff; border-radius:20px">

| Concept                     | Description                                   |
| --------------------------- | --------------------------------------------- |
| `matrix.<var>`              | Represents one combination of the matrix      |
| `${{ matrix.os }}`          | Used inside the reusable workflowâ€™s `runs-on` |
| `${{ matrix.node }}`        | Passed as input to reusable workflow          |
| `${{ strategy.job-index }}` | (Optional) index of job in matrix             |

</div>

---

> Each job is **isolated** â€” they donâ€™t share the workspace, context, or outputs unless you explicitly aggregate them later.

---

## ğŸ§± Example 5: Dynamic Matrix Inputs from JSON

Sometimes you want to generate your matrix dynamically (e.g., from an API or script).

```yaml
jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate.outputs.matrix }}
    steps:
      - id: generate
        run: |
          echo 'matrix={"environment":["dev","qa","prod"]}' >> $GITHUB_OUTPUT

  build:
    needs: generate-matrix
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ matrix.environment }}
```

ğŸ’¡ This lets you build a **fully dynamic pipeline** controlled by runtime data.

---

## ğŸ§° Common Mistakes and Fixes

<div align="center" style="background:#343739ff; border-radius:20px">

| Issue                           | Cause                                                  | Fix                                          |
| ------------------------------- | ------------------------------------------------------ | -------------------------------------------- |
| Workflow fails to expand matrix | Invalid syntax or `fromJson` missing                   | Ensure proper JSON format                    |
| Outputs not available           | Reusable workflow didnâ€™t define workflow-level outputs | Add `on.workflow_call.outputs`               |
| All jobs share same config      | Forgot to use `matrix.var` in inputs                   | Use `${{ matrix.var }}` for parameterization |
| Too many parallel jobs          | No `max-parallel` set                                  | Add concurrency limits                       |

</div>

---

## ğŸ§© Real-World Example â€” Multi-Env Deployments

Imagine a DevOps org pipeline that builds Docker images for all environments in parallel:

```yaml
jobs:
  deploy:
    strategy:
      matrix:
        env: [dev, staging, prod]
    uses: my-org/.github/.github/workflows/deploy.yml@v1
    with:
      environment: ${{ matrix.env }}
    secrets:
      TOKEN: ${{ secrets.DEPLOY_TOKEN }}
```

âœ… Results:

```ini
Deploying to dev ğŸš€
Deploying to staging ğŸš€
Deploying to prod ğŸš€
```

3 environments deployed simultaneously using one shared workflow ğŸ’¯

---

<div align="center" style="background:#343739ff; border-radius:20px">

```mermaid
graph TD
    A["ğŸ§© Caller (main.yml)"]
    B1["ğŸ§± Reusable build.yml â†’ env: dev"]
    B2["ğŸ§± Reusable build.yml â†’ env: staging"]
    B3["ğŸ§± Reusable build.yml â†’ env: prod"]

    A --> B1
    A --> B2
    A --> B3
    B1 & B2 & B3 --> C["ğŸš€ Multi-env deploys in parallel"]
```

</div>

---

## âœ… Summary

<div align="center" style="background:#343739ff; border-radius:20px">

| Concept               | Description                                               |
| --------------------- | --------------------------------------------------------- |
| **Matrix**            | Runs jobs in parallel with variable combinations          |
| **Reusable workflow** | Shared build/test/deploy logic                            |
| **Combination**       | Modular + parallel pipelines                              |
| **Use cases**         | Multi-OS builds, multi-version testing, multi-env deploys |
| **Bonus**             | Dynamic JSON-based matrices for adaptive workflows        |

</div>

---

## ğŸ’¬ TL;DR by Your Human Mentor

> Matrix + reusable workflows = _parallel universes of CI/CD_.  
> Each job gets its own dimension (Node version, OS, or environment) but shares one brain â€” your reusable workflow.
>
> Congratulations, youâ€™ve officially become a **CI/CD multiverse architect. ğŸ§ âœ¨**
