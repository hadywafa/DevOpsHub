# ‚öôÔ∏è GitHub Actions Internals

## üß≠ **High-Level Architecture: How a Workflow Executes**

Let‚Äôs visualize what happens when a workflow runs.

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
flowchart TD
  A[Workflow YAML] --> B[Runner Setup]
  B --> C[Job 1]
  C --> D["Step 1 (Action)"]
  C --> E["Step 2 (run command)"]
  C --> F["Step 3 (Action)"]
  C -->|outputs| G[Job 2]
  G --> H[Runner Environment 2]
```

</div>

---

- Each **job** runs on its own **runner** (VM or container).
- Inside the job, each **step** runs in sequence.
- Environment variables, outputs, and artifacts are how steps pass info.
- Between jobs, data must be explicitly shared via `outputs:` or `artifacts:` (not automatically shared).

---

## üß© **The Runner Environment**

When GitHub starts your job, it launches a **runner** (Ubuntu, Windows, or macOS VM) and:

- Exports environment variables like `GITHUB_WORKSPACE`, `GITHUB_REF`, `GITHUB_SHA`
- Checks out your code (if you use `actions/checkout`)
- Runs each `step` in order

Every **step** runs in a fresh shell, but **some files persist** between steps for communication.

---

## üß∞ **Special System Files (how data is shared)**

GitHub Actions uses **magic file interfaces** to share data between steps:

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| File                   | Purpose                                          | Access               |
| ---------------------- | ------------------------------------------------ | -------------------- |
| `$GITHUB_ENV`          | Set environment variables for later steps        | Write `KEY=value`    |
| `$GITHUB_OUTPUT`       | Define outputs from a step                       | Write `key=value`    |
| `$GITHUB_PATH`         | Add directories to the `PATH`                    | Write directory path |
| `$GITHUB_STATE`        | Store temporary state (used by pre/post actions) | Write key/value      |
| `$GITHUB_STEP_SUMMARY` | Append Markdown to the workflow summary page     | Write Markdown text  |

</div>

---

### üß± `$GITHUB_ENV` ‚Äî Share Environment Variables Across Steps üåç

Each step gets its own shell, so if you just `export MYVAR=value`, it disappears in the next step.

To persist it, write to `$GITHUB_ENV`:

```yaml
steps:
  - name: Set Env Var
    run: echo "MY_NAME=Batman" >> "$GITHUB_ENV"

  - name: Use Env Var
    run: echo "Hello $MY_NAME"
```

‚úÖ Output:

```ini
Hello Batman
```

üß† **Behind the scenes:**
GitHub appends your line into a temp file that the runner later sources for every new step.

---

### üì§ `$GITHUB_OUTPUT` ‚Äî Pass Data Between Steps (step outputs)

If you want a step to produce a value other steps can consume:

```yaml
steps:
  - name: Generate Version
    id: version
    run: echo "version=1.2.${{ github.run_number }}" >> "$GITHUB_OUTPUT"

  - name: Print Version
    run: echo "App version is ${{ steps.version.outputs.version }}"
```

‚úÖ Output:

```ini
App version is 1.2.15
```

This is how `outputs:` in composite or reusable workflows work internally.
Each step can write a key/value pair to `$GITHUB_OUTPUT`, and later steps access it using the `steps.<id>.outputs.<name>` syntax.

---

### üß≠ `$GITHUB_PATH` ‚Äî Modify PATH Dynamically üß©

Need to add a custom binary folder so your later steps can find an executable?

```yaml
steps:
  - name: Add custom tool
    run: echo "/opt/mytools" >> "$GITHUB_PATH"

  - name: Verify
    run: which mytool
```

‚úÖ This modifies the system PATH for the **rest of the job**.

---

### üîÅ `$GITHUB_STATE` ‚Äî Save Data Between Pre/Post Actions

Only relevant if you‚Äôre writing a **custom action** (Node or Docker).
You can store temporary state that‚Äôs restored later in a ‚Äúpost‚Äù script.

Example (inside Node action):

```js
const fs = require("fs");
fs.appendFileSync(process.env.GITHUB_STATE, `TMP_FILE=/tmp/cache.txt\n`);
```

In your **post** script:

```js
console.log(process.env.STATE_TMP_FILE);
```

üß© Used by `actions/cache` to clean up temporary directories after a workflow ends.

---

### ü™Ñ `$GITHUB_STEP_SUMMARY` ‚Äî Write Rich Markdown to Workflow Summary

Ever seen a nice Markdown summary at the end of a workflow? That‚Äôs this file.

```yaml
steps:
  - name: Add Markdown Summary
    run: |
      echo "### ‚úÖ Test Results" >> "$GITHUB_STEP_SUMMARY"
      echo "- Passed: 120" >> "$GITHUB_STEP_SUMMARY"
      echo "- Failed: 2" >> "$GITHUB_STEP_SUMMARY"
```

The Markdown appears under the **‚ÄúSummary‚Äù** tab of the workflow run.

---

## üß± **Job Outputs ‚Äî Share Data Between Jobs**

You can use `$GITHUB_OUTPUT` + `jobs.<id>.outputs` to pass values to another job:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
    steps:
      - id: meta
        run: echo "tag=build-${{ github.run_number }}" >> "$GITHUB_OUTPUT"

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo "Deploying tag ${{ needs.build.outputs.image_tag }}"
```

‚úÖ Output:

```ini
Deploying tag build-12
```

---

## üß© **Workflow Environment Variables (Auto-Populated)**

These are **built-in** env vars you can use anywhere.

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Variable            | Description                                      |
| ------------------- | ------------------------------------------------ |
| `GITHUB_WORKSPACE`  | Directory where your repo is cloned              |
| `GITHUB_REF`        | The branch or tag that triggered the workflow    |
| `GITHUB_REF_NAME`   | The short name of the branch or tag              |
| `GITHUB_SHA`        | Commit SHA that triggered the workflow           |
| `GITHUB_REPOSITORY` | `owner/repo`                                     |
| `GITHUB_ACTOR`      | Username who triggered the workflow              |
| `GITHUB_RUN_ID`     | Unique ID for the workflow run                   |
| `GITHUB_RUN_NUMBER` | Incremental number for this workflow             |
| `GITHUB_EVENT_NAME` | Name of the event (`push`, `pull_request`, etc.) |
| `GITHUB_EVENT_PATH` | JSON file path containing the webhook payload    |
| `RUNNER_OS`         | `Linux`, `Windows`, or `macOS`                   |
| `RUNNER_TEMP`       | Temp directory path                              |
| `RUNNER_TOOL_CACHE` | Path where setup actions store tools             |

</div>

---

## üß© **Communication Flow Inside Runner**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
  participant WF as Workflow
  participant R as Runner
  participant S1 as Step 1 (Action)
  participant S2 as Step 2 (Run Command)

  WF->>R: Start Job
  R->>S1: Execute Action
  S1->>R: Write output ‚Üí $GITHUB_OUTPUT
  R->>S2: Inject outputs/env vars
  S2->>R: Uses env/outputs
  R->>WF: Send logs + summary
```

</div>

---

> üí° The runner orchestrates everything. You don‚Äôt directly ‚Äúexport‚Äù variables ‚Äî you write to these system files so the runner can manage them.

---

## üß∞ **`$GITHUB_ENV` vs `$GITHUB_OUTPUT` ‚Äî Know the Difference**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Use Case                                         | Variable         | Effect                                       |
| ------------------------------------------------ | ---------------- | -------------------------------------------- |
| Make data available to later steps (as env vars) | `$GITHUB_ENV`    | Good for static config (like `APP_ENV=prod`) |
| Make data available as structured outputs        | `$GITHUB_OUTPUT` | Best for computed values (`version=1.0.5`)   |

</div>

---

**Example:**

```yaml
- id: build
  run: |
    echo "APP_ENV=prod" >> "$GITHUB_ENV"
    echo "tag=app-${{ github.run_number }}" >> "$GITHUB_OUTPUT"
```

Then later:

```yaml
- run: echo "Environment: $APP_ENV"
- run: echo "Tag: ${{ steps.build.outputs.tag }}"
```

---

## ‚öôÔ∏è **Expressions and Contexts: How Data Is Injected**

When you reference `${{ steps.build.outputs.tag }}`,  
GitHub‚Äôs runner parses the YAML, identifies dependencies, and evaluates these expressions **before** step execution.

Context hierarchy (priority order):

```ini
env ‚Üí vars ‚Üí inputs ‚Üí secrets ‚Üí github ‚Üí job ‚Üí steps ‚Üí runner
```

---

## üß© **\$GITHUB_ACTION_PATH ‚Äî Inside Custom Actions**

When writing your own action, `$GITHUB_ACTION_PATH` tells you where your action‚Äôs files are.

For example, if your composite action has scripts in the same folder:

```yaml
- run: bash $GITHUB_ACTION_PATH/setup.sh
```

This ensures the action runs its own local script path even when used in another repo.

---

## üß± **How Composite Actions Share Data Internally**

Composite actions also use `$GITHUB_OUTPUT` and `$GITHUB_ENV` internally.
For example, your composite action can pass data back to the caller:

```yaml
runs:
  using: "composite"
  steps:
    - id: set_version
      run: echo "version=2.1" >> "$GITHUB_OUTPUT"
outputs:
  version:
    value: ${{ steps.set_version.outputs.version }}
```

Then from a workflow:

```yaml
- uses: ./.github/actions/my-action
  id: myact
- run: echo "Got version ${{ steps.myact.outputs.version }}"
```

---

## üß† **Putting It All Together: Real Example**

```yaml
name: Advanced Data Flow
on: [push]

jobs:
  example:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set dynamic env
        run: echo "DEPLOY_ENV=prod" >> "$GITHUB_ENV"

      - name: Build App
        id: build
        run: echo "artifact=web-${{ github.run_number }}" >> "$GITHUB_OUTPUT"

      - name: Print everything
        run: |
          echo "Environment: $DEPLOY_ENV"
          echo "Artifact: ${{ steps.build.outputs.artifact }}"
          echo "Workspace: $GITHUB_WORKSPACE"
```

‚úÖ Output:

```ini
Environment: prod
Artifact: web-15
Workspace: /home/runner/work/myrepo/myrepo
```

---

## üîê **Security Notes**

- **Never echo secrets** directly to `$GITHUB_ENV` or `$GITHUB_OUTPUT` without masking.
- GitHub automatically masks any secret that matches an existing secret value.
- You can manually mask logs:

  ```yaml
  run: echo "::add-mask::mysecretvalue"
  ```

---

## üß© **Debugging Environment Issues**

To debug what‚Äôs available in the runner:

```yaml
- run: env | sort
- run: cat "$GITHUB_ENV"
```

Or enable debug logging globally:

1. Go to **Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables**
2. Add variable: `ACTIONS_STEP_DEBUG=true`
3. Re-run the workflow ‚Üí gets verbose step logs

---

## üß† **Summary**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Mechanism              | Purpose                        | Used For                     |
| ---------------------- | ------------------------------ | ---------------------------- |
| `$GITHUB_ENV`          | Persist env vars between steps | ‚ÄúGlobal‚Äù environment values  |
| `$GITHUB_OUTPUT`       | Create step/job outputs        | Structured data sharing      |
| `$GITHUB_PATH`         | Extend PATH                    | CLI tools                    |
| `$GITHUB_STEP_SUMMARY` | Add Markdown to summary        | Reports and dashboards       |
| `$GITHUB_STATE`        | Save data for post scripts     | Advanced custom actions      |
| `$GITHUB_ACTION_PATH`  | Action‚Äôs local folder          | Custom scripts inside action |

</div>
