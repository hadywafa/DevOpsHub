# üß© Monorepo + Multiple Docker Images ‚Äî Best Practices (Q&A)

## ‚ùì 1. Scenario: I have a monorepo with many projects. How should I structure it?

**Example structure:**

```text
repo-root/
  services/
    users-api/
      Dockerfile
      src/...
    payments-api/
      Dockerfile
      src/...
    orders-worker/
      Dockerfile
      src/...
  .github/
    workflows/
      ci-build-images.yml
```

**Best practice ideas:**

- One folder per service under `services/`.
- Each service has:

  - Its own `Dockerfile`
  - Its own `src`, tests, configs, etc.

- Image names usually follow:
  `ghcr.io/<org>/<service-name>` or `registry.example.com/<team>/<service-name>`

---

## ‚ùì 2. What‚Äôs the best practice to build & push multiple images from one repo?

**Short answer:**

‚û°Ô∏è Use **one workflow with a matrix job** that loops over services and builds/pushes an image per service.

This gives you:

- One centralized workflow.
- Parallel builds for multiple services.
- Easy to add/remove services.

---

## ‚ùì 3. How would that look in GitHub Actions?

Here‚Äôs a clean **matrix-based example** üîß

> üìù This builds/pushes **3 services** from a monorepo to **GitHub Container Registry (GHCR)**.

```yaml
# .github/workflows/build-images.yml
name: Build & Push Service Images

on:
  push:
    branches: [main]
    paths:
      - "services/**"
      - ".github/workflows/build-images.yml"

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        service: ["users-api", "payments-api", "orders-worker"]

    env:
      REGISTRY: ghcr.io
      ORG: your-org-name

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: ./services/${{ matrix.service }}
          file: ./services/${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.ORG }}/${{ matrix.service }}:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.ORG }}/${{ matrix.service }}:main
```

### üîç What‚Äôs happening here?

- `matrix.service`: loops through `users-api`, `payments-api`, `orders-worker`.
- For each service:

  - `context` = `./services/<service-name>`
  - `Dockerfile` = `./services/<service-name>/Dockerfile`
  - Two tags:

    - `:SHA` (immutable, exact version)
    - `:main` (movable tag for ‚Äúlatest from main‚Äù)

This is a **very common pattern** in real companies using monorepos + microservices.

---

## ‚ùì 4. How do I avoid building _all_ images when only _one_ service changed?

This is the next level of ‚Äúsenior DevOps‚Äù thinking. üòé

**Best practice:**

- Use **path filters** to detect changed services.
- Generate the matrix dynamically only for changed services.

A simple (conceptual) approach:

1. Use an action like `dorny/paths-filter` to know which service folders changed.
2. Build a JSON array of changed services.
3. Feed that array into `strategy.matrix`.

Conceptual snippet (simplified):

```yaml
jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-matrix.outputs.services }}
    steps:
      - uses: actions/checkout@v4

      - name: Detect changed services
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            users-api:
              - 'services/users-api/**'
            payments-api:
              - 'services/payments-api/**'
            orders-worker:
              - 'services/orders-worker/**'

      - name: Build matrix JSON
        id: set-matrix
        run: |
          changed=()
          if [[ "${{ steps.changes.outputs.users-api }}" == 'true' ]]; then changed+=("users-api"); fi
          if [[ "${{ steps.changes.outputs.payments-api }}" == 'true' ]]; then changed+=("payments-api"); fi
          if [[ "${{ steps.changes.outputs.orders-worker }}" == 'true' ]]; then changed+=("orders-worker"); fi

          # Convert Bash array ‚Üí JSON
          json=$(printf '%s\n' "${changed[@]}" | jq -R . | jq -s .)
          echo "services=$json" >> $GITHUB_OUTPUT

  build-and-push:
    needs: detect-changes
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    steps:
      # same as previous example...
```

Now you get:

- If only `users-api` changed ‚Üí only that image gets built & pushed.
- Saves time, cost, and registry noise.

---

## ‚ùì 5. How should I tag images from a monorepo?

Good tagging strategy is very important. Common best practices:

‚úÖ **Always have an immutable tag** ‚Äì usually `git SHA`
‚úÖ Optionally add:

- Branch/tag name (`:main`, `:develop`)
- Semantic version (`:1.2.0`) for releases
- Environment (`:staging`, `:prod`) only if you keep it very clean

Example tags per service:

- `ghcr.io/org/users-api:3f8a1c9` (exact commit)
- `ghcr.io/org/users-api:main` (latest from main)
- `ghcr.io/org/users-api:v1.4.0` (release tag)

---

## ‚ùì 6. What do real companies usually do with monorepo + multiple images?

Patterns you‚Äôll see in most mature teams:

- **Monorepo for many services** (backend, workers, frontends).
- **Matrix build** per service:

  - Build & push a separate image per service.

- **Path-based filtering**:

  - Only build images whose folders changed.

- **Reusable workflow**:

  - They create a generic `build-docker-image.yml` called via `workflow_call` from other workflows.

- **GitOps or CD tool**:

  - ArgoCD/Flux/ADO Release/GitHub Actions deployment workflows use the new image tags to deploy.

---

## ‚ùì 7. What answer can I give in an interview as a ‚Äúsenior DevOps‚Äù for this topic?

Something like:

> ‚ÄúIn a monorepo with multiple services, I treat each service as its own image. I organize the repo with `services/<service-name>` folders, each with a Dockerfile.
>
> In CI, I use a matrix job in GitHub Actions, where each matrix entry is a service. The workflow builds and pushes images like `ghcr.io/org/service-name:<sha>` and `:main`.
>
> For efficiency, I usually add path-based detection so that only services that changed in the PR are built. This keeps builds fast and reduces registry noise.
>
> This pattern scales well for microservices and is common in companies using monorepos.‚Äù

That sounds **practical, real-world, and senior**. ‚úÖ

---

If you want next, I can:

- Turn this into a **‚ÄúPR ‚Üí validate ‚Üí main ‚Üí build & push multi-images ‚Üí deploy‚Äù** full pipeline,
- Or add an example where **backend + frontend + worker** are all built & pushed in one workflow.
