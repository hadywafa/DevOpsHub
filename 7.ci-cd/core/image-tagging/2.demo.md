# ✍🏻 **Hands-on CI/CD for ASP.NET Core Web API**

awesome — here’s a **complete, runnable** example for a tiny **ASP.NET Core Web API** with a **Dockerfile**, plus **CI/CD YAML** that implements the best-practice image strategy we discussed:

- build on PRs (optional push for previews),
- build once on `dev` after merge (canonical artifact),
- PR `dev → main` creates **RC tag** (no rebuild),
- merge to `main` promotes the **same digest** to release tags,
- **deploy by digest** (Helm).

I’ll use **Azure DevOps + ACR + Kubernetes (Helm)** in the example. If you prefer GitHub Actions or plain Kubernetes manifests, I can translate it.

---

## 📂 **Repository layout**

```ini
ordersvc/
├── src/
│   └── Orders.Api/
│       ├── Orders.Api.csproj
│       ├── Program.cs
│       └── appsettings.json
├── Dockerfile
├── charts/
│   └── ordersvc/
│       ├── Chart.yaml
│       ├── values.yaml              # only repo (no tag); we pass digest during deploy
│       └── templates/
│           └── deployment.yaml
└── .azure-pipelines/
    ├── pr.yml
    ├── dev.yml
    ├── rc.yml
    └── release.yml
```

---

## 🧑🏻‍💻 **Minimal ASP.NET Core Web API** (real)

### `src/Orders.Api/Program.cs`

```csharp
using Microsoft.AspNetCore.Mvc;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();
app.UseSwagger();
app.UseSwaggerUI();

app.MapGet("/", () => new { service = "ordersvc", status = "ok" });

app.MapGet("/api/orders/{id:int}", ([FromRoute] int id) =>
{
    var order = new { id, total = 199.99, currency = "USD", date = DateTime.UtcNow };
    return Results.Ok(order);
});

app.Run();
```

### `src/Orders.Api/Orders.Api.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.6.2" />
  </ItemGroup>
</Project>
```

### `src/Orders.Api/appsettings.json`

```json
{
  "Logging": {
    "LogLevel": { "Default": "Information", "Microsoft.AspNetCore": "Warning" }
  },
  "AllowedHosts": "*"
}
```

---

## 🐬 **Dockerfile (multi-stage, small image)**

**`Dockerfile`** (at repo root)

```dockerfile
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ./src/Orders.Api/ ./Orders.Api/
RUN dotnet restore ./Orders.Api/Orders.Api.csproj
RUN dotnet publish ./Orders.Api/Orders.Api.csproj -c Release -o /app/publish --no-restore

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
WORKDIR /app
COPY --from=build /app/publish .
EXPOSE 8080
ENV ASPNETCORE_URLS=http://+:8080
ENTRYPOINT ["dotnet", "Orders.Api.dll"]
```

You can test locally:

```bash
docker build -t ordersvc:local .
docker run -p 8080:8080 ordersvc:local
# browse http://localhost:8080/swagger
```

---

## 🪖 **Helm chart (deploy `by digest`)**

### `charts/ordersvc/Chart.yaml`

```yaml
apiVersion: v2
name: ordersvc
version: 0.1.0
appVersion: "1.0.0"
```

### `charts/ordersvc/values.yaml`

```yaml
replicaCount: 1
image:
  repository: contoso.azurecr.io/ordersvc
  # DO NOT set tag here. We pass an image digest at deploy time.
  # digest is provided via --set image.digest="sha256:...." in the pipeline
service:
  type: ClusterIP
  port: 80
containerPort: 8080
```

### `charts/ordersvc/templates/deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: { { include "ordersvc.fullname" . } }
spec:
  replicas: { { .Values.replicaCount } }
  selector:
    matchLabels: { app: { { include "ordersvc.name" . } } }
  template:
    metadata:
      labels: { app: { { include "ordersvc.name" . } } }
    spec:
      containers:
        - name: ordersvc
          image: "{{ .Values.image.repository }}@{{ .Values.image.digest }}"
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: { { .Values.containerPort } }
          readinessProbe:
            httpGet: { path: /, port: { { .Values.containerPort } } }
            initialDelaySeconds: 5
            periodSeconds: 5
          livenessProbe:
            httpGet: { path: /, port: { { .Values.containerPort } } }
            initialDelaySeconds: 10
            periodSeconds: 10
```

> Note: we **don’t use tags** in the deployment image reference; we pass the **digest** during `helm upgrade --install`.

---

## 📃 **Azure DevOps pipelines** (4 YAMLs)

You’ll need service connections/variables for:

- `ACR_NAME=contoso`
- `ACR_LOGIN_SERVER=contoso.azurecr.io`
- `IMAGE=contoso.azurecr.io/ordersvc`
- `KUBE_CONTEXT` (your AKS context configured on agent or via `azure/k8s` tasks)
- Helm installed on the agent (or use Helm task).

### 1️⃣ PR Validation — `.azure-pipelines/pr.yml`

Pragmatic policy (what I recommend)

**Default PRs:**

- ✅ Build the code (dotnet build/test)
- ✅ Static scans: SAST (Semgrep), secrets (gitleaks), dep/SCA (Trivy on **filesystem**), IaC (tfsec/Checkov)
- ✅ (Optional) **Build an image locally but don’t push** — catches Dockerfile issues & lets you scan the built image layers
- ❌ Don’t push to registry
- ❌ Don’t deploy previews

**Opt-in previews (only when needed):**

- If the PR is labeled `preview` (or a comment like `/preview`), then:

  - 🟡 Build **and push** `:pr-<id>` + `:git-<sha>`
  - 🟡 (Optional) Deploy a temporary environment by **digest**

- Remove the label → previews stop

**After merge to `dev`:**

- 🟢 Build **once**, push `:git-<sha>` (+ optional `:dev`), scan image, and deploy to Dev **by digest**
- 🟢 This is your canonical promotable artifact

**PR `dev → main` and merge to `main`:**

- 🟢 **No rebuilds** — just tag the same digest (`:1.4.0-rc.N` then `:1.4.0`, `:1.4`, `:1`, `:stable`) and deploy by digest

#### Why this is a sweet spot

- Cuts registry churn & costs (no pushes for every PR tweak)
- Keeps fast feedback (build errors, tests, SAST/secret/IaC issues)
- Still catches Dockerfile breakage (local image build in CI, no push)
- Gives product folks previews **only** when they ask

#### Optional performance tweaks

- Use BuildKit cache to speed the **post-merge** build without publishing artifacts:

  - `docker buildx build --cache-to type=registry,mode=max,ref=$IMAGE:cache --cache-from type=registry,ref=$IMAGE:cache`

- Cancel in-progress PR runs on new commits (concurrency / “cancel previous”)
- Trigger PR builds only when relevant paths change (e.g., ignore docs)

#### Minimal Azure DevOps sketch

**PR (default) – build & scan, no push:**

```yaml
pr:
  branches: [dev]
jobs:
  - job: pr_validate
    pool: { vmImage: "ubuntu-latest" }
    steps:
      - script: dotnet build src/Orders.Api/Orders.Api.csproj -c Release
      - script: dotnet test  src/Orders.Api/Orders.Api.csproj -c Release --no-build
      - script: |
          # SAST / secrets / IaC / SCA (filesystem)
          semgrep --config p/ci
          gitleaks detect --no-banner
          checkov -d .
          trivy fs --exit-code 1 --severity HIGH,CRITICAL .
        displayName: Static scans
      - script: |
          # Build image locally to catch Dockerfile issues & scan it (no push)
          IMG="contoso.azurecr.io/ordersvc"
          SHORT=$(echo $(Build.SourceVersion) | cut -c1-8)
          docker build -t $IMG:git-$SHORT .
          trivy image --exit-code 1 --severity HIGH,CRITICAL $IMG:git-$SHORT
        displayName: Build image (no push) + scan
```

**PR (opt-in preview) – push only when labeled**
(You can model this as a separate pipeline that runs when a variable is set, or via a manual stage.)

```yaml
# Run this stage only if variable PREVIEW == 'true' (set by UI or label hook)
- job: pr_preview
  condition: and(succeeded(), eq(variables['PREVIEW'], 'true'))
  steps:
    - script: |
        az acr login -n contoso
        IMG="contoso.azurecr.io/ordersvc"
        SHORT=$(echo $(Build.SourceVersion) | cut -c1-8)
        PRID=$(System.PullRequest.PullRequestId)
        docker push $IMG:git-$SHORT
        docker tag  $IMG:git-$SHORT $IMG:pr-$PRID
        docker push $IMG:pr-$PRID
        DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMG:git-$SHORT)
        echo $DIGEST > image_digest.txt
    - publish: image_digest.txt
      artifact: pr_image
    # (optional) deploy preview by digest here
```

**After merge to `dev` – canonical build + push + deploy by digest**
(As in the earlier full example you have.)

---

### 2️⃣ Dev (canonical artifact) — `.azure-pipelines/dev.yml`

- Triggers on merges to `dev`.
- Builds once; pushes `git-<sha>` and `dev` pointer.
- Deploys to Dev **by digest**.

```yaml
trigger:
  branches: { include: [dev] }

pool: { vmImage: "ubuntu-latest" }

variables:
  ACR_NAME: "contoso"
  IMAGE: "contoso.azurecr.io/ordersvc"
  RELEASE_NAME: "ordersvc-dev" # Helm release

stages:
  - stage: BuildPush
    jobs:
      - job: BuildPush
        steps:
          - task: Bash@3
            displayName: Build & Push Dev Image
            inputs:
              targetType: inline
              script: |
                set -e
                SHORT_SHA=$(echo $(Build.SourceVersion) | cut -c1-8)
                docker build -t $(IMAGE):git-$SHORT_SHA .
                az acr login -n $(ACR_NAME)
                docker push $(IMAGE):git-$SHORT_SHA
                DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $(IMAGE):git-$SHORT_SHA)
                echo $DIGEST > image_digest.txt
                docker tag  $(IMAGE):git-$SHORT_SHA $(IMAGE):dev
                docker push $(IMAGE):dev
          - publish: image_digest.txt
            artifact: image

  - stage: DeployDev
    dependsOn: BuildPush
    jobs:
      - job: DeployDev
        steps:
          - download: current
            artifact: image
          - task: Bash@3
            displayName: Helm Upgrade (Dev) by Digest
            inputs:
              targetType: inline
              script: |
                set -e
                DIGEST=$(cat $(Pipeline.Workspace)/image/image_digest.txt)
                # DIGEST looks like: contoso.azurecr.io/ordersvc@sha256:xxxx
                PURE=${DIGEST#*@}
                helm upgrade --install $(RELEASE_NAME) charts/ordersvc \
                  --set image.repository="$(IMAGE)" \
                  --set image.digest="$PURE"

# NOTE:
# 1. $(Build.SourceVersion) == git commit SHA-1
# 2. `echo "abcdefghijklm" | cut -c1-8` -> abcdefgh
# 3. docker inspect --format='{{index .RepoDigests 0}}' image:tag -> image@sha256:...
```

### 3️⃣ RC (PR `dev → main`) — `.azure-pipelines/rc.yml`

- **No rebuild**. Tags RC on the **same digest**.

```yaml
trigger: none
pr:
  branches: { include: [main] }

pool: { vmImage: "ubuntu-latest" }

variables:
  ACR_NAME: "contoso"
  IMAGE: "contoso.azurecr.io/ordersvc"
  RC_TAG: "1.4.0-rc.1"
  RELEASE_NAME: "ordersvc-staging"

stages:
  - stage: TagRC
    jobs:
      - job: TagRC
        steps:
          - task: Bash@3
            displayName: Tag RC
            inputs:
              targetType: inline
              script: |
                set -e
                SHORT_SHA=$(echo $(Build.SourceVersion) | cut -c1-8)
                az acr login -n $(ACR_NAME)
                docker pull $(IMAGE):git-$SHORT_SHA
                docker tag  $(IMAGE):git-$SHORT_SHA $(IMAGE):$(RC_TAG)
                docker push $(IMAGE):$(RC_TAG)
                DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $(IMAGE):git-$SHORT_SHA)
                echo $DIGEST > image_digest.txt
          - publish: image_digest.txt
            artifact: rc_image

  - stage: DeployStaging
    dependsOn: TagRC
    jobs:
      - job: DeployStaging
        steps:
          - download: current
            artifact: rc_image
          - task: Bash@3
            displayName: Helm Upgrade (Staging) by Digest
            inputs:
              targetType: inline
              script: |
                set -e
                DIGEST=$(cat $(Pipeline.Workspace)/rc_image/image_digest.txt)
                PURE=${DIGEST#*@}
                helm upgrade --install $(RELEASE_NAME) charts/ordersvc \
                  --set image.repository="$(IMAGE)" \
                  --set image.digest="$PURE"
```

### 4️⃣ Release (merge to `main`) — `.azure-pipelines/release.yml`

- **No rebuild**. Promote same digest to version tags and deploy to prod **by digest**.

```yaml
trigger:
  branches: { include: [main] }

pool: { vmImage: "ubuntu-latest" }

variables:
  ACR_NAME: "contoso"
  IMAGE: "contoso.azurecr.io/ordersvc"
  VERSION: "1.4.0"
  RELEASE_NAME: "ordersvc-prod"

stages:
  - stage: Promote
    jobs:
      - job: PromoteTags
        steps:
          - task: Bash@3
            displayName: Tag release (no rebuild)
            inputs:
              targetType: inline
              script: |
                set -e
                SHORT_SHA=$(echo $(Build.SourceVersion) | cut -c1-8)
                az acr login -n $(ACR_NAME)
                docker pull $(IMAGE):git-$SHORT_SHA
                for T in $(VERSION) ${VERSION%.*} ${VERSION%%.*} stable; do
                  docker tag  $(IMAGE):git-$SHORT_SHA $(IMAGE):$T
                  docker push $(IMAGE):$T
                done
                DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $(IMAGE):git-$SHORT_SHA)
                echo $DIGEST > image_digest.txt
          - publish: image_digest.txt
            artifact: prod_image

  - stage: DeployProd
    dependsOn: Promote
    jobs:
      - job: DeployProd
        steps:
          - download: current
            artifact: prod_image
          - task: Bash@3
            displayName: Helm Upgrade (Prod) by Digest
            inputs:
              targetType: inline
              script: |
                set -e
                DIGEST=$(cat $(Pipeline.Workspace)/prod_image/image_digest.txt)
                PURE=${DIGEST#*@}
                helm upgrade --install $(RELEASE_NAME) charts/ordersvc \
                  --set image.repository="$(IMAGE)" \
                  --set image.digest="$PURE"
```

---

## 👀 **What you’ll see** (sample tags & digests)

Assume the **dev build** commit short SHA is `9a8b7c6d` and its digest is:

```ini
contoso.azurecr.io/ordersvc@sha256:222bbbcccdde1122...
```

- After **dev** pipeline:

  - `ordersvc:git-9a8b7c6d` → `sha256:222bbb...`
  - `ordersvc:dev` → `sha256:222bbb...`

- After **RC** pipeline (PR `dev → main`):

  - `ordersvc:1.4.0-rc.1` → `sha256:222bbb...`

- After **release** (merge to `main`):

  - `ordersvc:1.4.0` → `sha256:222bbb...`
  - `ordersvc:1.4` → `sha256:222bbb...`
  - `ordersvc:1` → `sha256:222bbb...`
  - `ordersvc:stable` → `sha256:222bbb...`

And all **deployments** (Dev/Staging/Prod) use:

```ini
image: contoso.azurecr.io/ordersvc@sha256:222bbb...
```

---

## 🚬 **Local smoke test of the digest flow** (optional)

```bash
ACR=contoso.azurecr.io
IMG=$ACR/ordersvc
SHORT=9a8b7c6d

# build and push
docker build -t $IMG:git-$SHORT .
az acr login -n contoso
docker push $IMG:git-$SHORT

# get digest and “promote” locally
DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMG:git-$SHORT)
echo "Digest is $DIGEST"
docker tag  $IMG:git-$SHORT $IMG:1.4.0
docker push $IMG:1.4.0

# run by digest
docker run --rm -p 8080:8080 "$IMG@${DIGEST#*@}"
```

---

## 🛡️ **Security & metadata** (quick wins)

- **Sign images**: `cosign sign $IMG@sha256:...` and verify in admission.
- **SBOM**: generate with Syft and attach as artifact.
- **OCI labels**: bake commit/build URL into the image for traceability:

  ```dockerfile
  LABEL org.opencontainers.image.source="https://dev.azure.com/org/project/_build/results?buildId=$(Build.BuildId)"
  LABEL org.opencontainers.image.revision="$SHORT_SHA"
  ```

---

## 🏁 **TL;DR**

- Minimal ASP.NET Core API ✅
- Dockerfile (multi-stage) ✅
- Helm chart that **deploys by digest** ✅
- Azure DevOps pipelines for **PR**, **Dev**, **RC**, **Release** ✅
- Clear, concrete tag/digest lifecycle ✅
