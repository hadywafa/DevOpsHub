# üß† **LogQL (Loki Query Language)**

_(Everything you need for day-to-day Loki usage)!_

> **LogQL** is the query language of **Grafana Loki**, inspired by PromQL.
> It is used to **select log streams using labels**, then **filter, parse, and optionally turn logs into metrics**.

---

![Image](https://miro.medium.com/1%2AmjBhl49_TNNJqZmOc8dQpw.png?utm_source=chatgpt.com)

![Image](https://grafana.com/media/docs/loki/getting-started-loki-stack-3.png?utm_source=chatgpt.com)

![Image](https://miro.medium.com/v2/resize%3Afit%3A2000/1%2AmTQZijSrIXBp6FSmF7V_jw.png?utm_source=chatgpt.com)

---

## üß† One-Sentence Mental Model (Critical)

> **LogQL = ‚ÄúSelect streams first, then process log lines.‚Äù**

If you remember this, you will never write a broken query.

---

## üß© LogQL Has **Two Query Types**

| Type               | Purpose                |
| ------------------ | ---------------------- |
| **Log queries**    | View / filter raw logs |
| **Metric queries** | Turn logs into metrics |

We start with **log queries** (most common).

---

## üîπ PART 1: LOG QUERIES (RAW LOGS)

## 1Ô∏è‚É£ **Label Selector (MANDATORY FIRST STEP)**

Every LogQL query **must start with labels**.

```logql
{namespace="prod", app="api"}
```

### Rules:

- Labels are **indexed**
- Faster = more selective labels
- Avoid `{}` alone in production (very slow)

---

### üî¥ Bad (slow)

```logql
{}
```

### üü¢ Good

```logql
{namespace="prod"}
```

---

## 2Ô∏è‚É£ **Line Filters (Text Matching)**

After labels, you filter **log content**.

---

### üîç Contains (`|=`)

```logql
{app="api"} |= "error"
```

‚Üí log line contains `"error"`

---

### ‚ùå Does NOT contain (`!=`)

```logql
{app="api"} != "healthcheck"
```

---

### üîÅ Regex match (`|~`)

```logql
{app="api"} |~ "timeout|failed|panic"
```

---

### üö´ Regex exclude (`!~`)

```logql
{app="api"} !~ "debug|trace"
```

---

## üß† Golden Rule (Memorize)

> **Labels reduce data, filters scan data**

Always **filter with labels first**, then content.

---

## 3Ô∏è‚É£ **Combining Multiple Filters**

```logql
{namespace="prod", app="api"}
|= "error"
!= "timeout"
```

Read it as English:

> Give me prod api logs that contain error but not timeout

---

## üîπ PART 2: PARSING LOG CONTENT

Most real apps log **JSON**.
LogQL lets you **parse inside the query**.

---

## 4Ô∏è‚É£ **JSON Parsing (`| json`)**

```logql
{app="api"} | json
```

This extracts fields like:

- `level`
- `message`
- `status`
- `userId`

---

### Access parsed fields

```logql
{app="api"} | json | level="error"
```

---

### Numeric comparison

```logql
{app="api"} | json | status >= 500
```

---

## 5Ô∏è‚É£ **Logfmt Parsing (`| logfmt`)**

For logs like:

```ini
level=error msg="failed" status=500
```

```logql
{app="api"} | logfmt | status >= 500
```

---

## 6Ô∏è‚É£ **Regex Extraction (`| regexp`)**

```logql
{app="api"}
| regexp "user=(?P<user>[a-z0-9]+)"
```

Creates a field called `user`.

---

## üß† Parsing Rule

> Parsing happens **after filtering**, not before.

---

## üîπ PART 3: FORMATTING OUTPUT

## 7Ô∏è‚É£ **Line Formatting**

```logql
{app="api"} | json | line_format "{{.level}} - {{.message}}"
```

Output:

```ini
ERROR - database connection failed
```

---

## 8Ô∏è‚É£ **Label Formatting**

```logql
| label_format service="{{.app}}-svc"
```

Creates new labels dynamically (use carefully).

---

## üîπ PART 4: METRICS FROM LOGS (POWER FEATURE)

This is where LogQL becomes **PromQL-like**.

## 9Ô∏è‚É£ **Range Queries (Time Window)**

```logql
{app="api"} |= "error" [5m]
```

This is now **logs over time**, not raw logs.

---

## üî¢ Core Metric Functions (MEMORIZE THESE)

---

### üîπ `count_over_time` (MOST USED)

```logql
count_over_time({app="api"} |= "error" [5m])
```

‚Üí Number of error logs in last 5 minutes

---

### üîπ `rate`

```logql
rate({app="api"} |= "error" [1m])
```

‚Üí Errors per second

---

### üîπ `sum by`

```logql
sum by (namespace)(
  count_over_time({app="api"} |= "error" [5m])
)
```

---

### üîπ `topk`

```logql
topk(5,
  count_over_time({app="api"} |= "error" [5m])
)
```

---

## üîπ PART 5: REAL-WORLD QUERY PATTERNS (IMPORTANT)

---

### üü¢ **All pod logs**

```logql
{namespace="default"}
```

---

### üü¢ **Errors in prod**

```logql
{namespace="prod"} |~ "(?i)error|fail|panic"
```

---

### üü¢ **HTTP 5xx**

```logql
{app="api"} | json | status >= 500
```

---

### üü¢ **Logs for a specific pod**

```logql
{pod="api-7fbdc"}
```

---

### üü¢ **Errors per service**

```logql
sum by (app)(
  count_over_time({namespace="prod"} |= "error" [5m])
)
```

---

### üü¢ **Slow requests**

```logql
{app="api"} | json | duration_ms > 1000
```

---

### üü¢ **User-specific logs**

```logql
{app="api"} | json | userId="123"
```

---

## üî¥ COMMON MISTAKES (VERY IMPORTANT)

| Mistake                   | Why bad        |
| ------------------------- | -------------- |
| `{}`                      | Full scan      |
| Filtering before labels   | Impossible     |
| Regex on huge streams     | Slow           |
| High-cardinality labels   | Explodes index |
| Long ranges + weak labels | Pain           |

---

## üß† PERFORMANCE RULES (MEMORIZE)

1. **Labels first**
2. **Short time range**
3. **Avoid regex if possible**
4. **Don‚Äôt create labels dynamically unless needed**
5. **Prefer parsing in Alloy, not LogQL, for hot paths**

---

## üß† Cheat Sheet (Core Syntax)

```logql
{label="value"}                # stream selector
|= "text"                      # contains
|~ "regex"                     # regex
| json                          # parse json
| status >= 500                # filter parsed fields
| line_format "{{.msg}}"       # format output
count_over_time(...[5m])       # logs ‚Üí metrics
```

---

## üß† Memorization Block (VERY IMPORTANT)

### üîë Mnemonic: **S-F-P-M**

| Step  | Meaning                 |
| ----- | ----------------------- |
| **S** | Select streams (labels) |
| **F** | Filter lines            |
| **P** | Parse content           |
| **M** | Metric (optional)       |

If a query fails ‚Üí check **S-F-P-M** order.

---

## üß† Final Takeaway

- LogQL is **simple by design**
- 90% of usage = labels + `|=` + `json`
- Metrics from logs are **first-class**
- Performance depends on **label quality**
- If you think in pipelines, LogQL feels natural

> **If PromQL is math on metrics, LogQL is math on text.**
