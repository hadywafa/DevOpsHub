# ðŸ§  **Loki Index Types â€“ Deep Dive**

_(boltdb-shipper vs TSDB)!_

> **Loki index types define how Loki maps label queries to log chunks stored in object storage.**
> They do **not change how logs are written**, only **how they are indexed, compacted, and queried**.

---

![Image](https://miro.medium.com/v2/resize%3Afit%3A2000/1%2AmTQZijSrIXBp6FSmF7V_jw.png?utm_source=chatgpt.com)

![Image](https://taisho6339.gitbook.io/grafana-loki-deep-dive/~gitbook/image?dpr=4&quality=100&sign=302a761b&sv=2&url=https%3A%2F%2F4170524052-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FDRpfk9p4pUyymE3xFYsU%252Fuploads%252Fgit-blob-9d4af0c42732845ce68fa0ea67f4aef2c94eea40%252Fboltdb-shipper-overview.png%3Falt%3Dmedia&width=768&utm_source=chatgpt.com)

![Image](https://miro.medium.com/1%2AJ7i8947vXeSGDyafYIONVg.gif?utm_source=chatgpt.com)

---

## ðŸ§  One-Sentence Mental Model (Critical)

> **The index is Lokiâ€™s â€œtable of contentsâ€; chunks are the pages.**
> boltdb-shipper and TSDB are **two different ways to build that table of contents**.

---

## ðŸ”´ **Why Loki Needs an Index at All**

Loki stores **log data (chunks)** in object storage, but object storage cannot answer questions like:

```ini
{namespace="prod", app="api"} last 1h
```

So Loki must maintain an **index** that answers:

- Which label sets exist?
- Which time ranges do they cover?
- Which chunks should be fetched?

---

## ðŸ§± **Loki Storage Model (Invariant)**

This never changes, regardless of index type:

| Layer          | Role                   |
| -------------- | ---------------------- |
| Log chunks     | Compressed log content |
| Object storage | Durable, cheap storage |
| Index          | Maps labels â†’ chunks   |
| Cache          | Speeds up queries      |

ðŸ‘‰ Only the **index implementation** differs.

---

## ðŸŸ¥ **Index Type 1: boltdb-shipper (Legacy, Still Supported)**

### ðŸ§  Definition

> **boltdb-shipper** stores the index as **BoltDB files**, built locally by ingesters and **shipped to object storage**.

---

### ðŸ§± Architecture

<div align="center" style="background-color:#1f2a2aff;border-radius:10px;border:2px solid">

```mermaid
graph LR
    A[ðŸ§± Ingester]
    B[(ðŸ“ Local BoltDB Index)]
    C[(ðŸ“¦ Object Storage)]
    D[ðŸ” Querier]

    A --> B --> C
    D --> C
```

</div>

---

### ðŸ§  How boltdb-shipper Works

1. Ingester writes log chunks
2. Ingester builds BoltDB index locally
3. Periodically uploads index files
4. Querier downloads index files
5. Querier scans index â†’ fetches chunks

---

### âœ… Pros

- Simple
- Stable
- Well-understood
- Works well at smallâ€“medium scale

---

### âŒ Cons

- Large index files
- Expensive scans
- Slower queries at scale
- Inefficient for high cardinality
- Heavy object storage reads

---

### ðŸŸ¢ When boltdb-shipper Is OK

- Existing clusters
- Small environments
- Low cardinality labels
- Legacy deployments

---

## ðŸŸ¦ **Index Type 2: TSDB (Modern, Recommended)**

### ðŸ§  Definition

> **TSDB index** uses a **Prometheus-style time-series index**, optimized for **label lookups and time-bounded queries**.

---

### ðŸ§± Architecture

<div align="center" style="background-color:#232b2dff;border-radius:10px;border:2px solid">

```mermaid
graph LR
    A[ðŸ§± Ingester]
    B[(ðŸ“Š TSDB Blocks)]
    C[(ðŸ“¦ Object Storage)]
    D[ðŸ” Querier]

    A --> B --> C
    D --> C
```

</div>

---

### ðŸ§  How TSDB Index Works

1. Logs grouped into streams
2. Streams indexed by labels + time
3. Index blocks created (time-partitioned)
4. Blocks uploaded to object storage
5. Querier fetches **only relevant blocks**

---

### ðŸ”‘ Key Difference (Very Important)

| boltdb-shipper    | TSDB                |
| ----------------- | ------------------- |
| Scan index files  | Binary-search index |
| File-based lookup | Block-based lookup  |
| Broad scans       | Narrow time windows |

---

### âœ… Pros

- Much faster queries
- Lower object storage IO
- Better cache efficiency
- Handles high cardinality better
- Scales to very large clusters

---

### âŒ Cons

- Slightly more complex
- Newer (but now stable)
- Requires newer Loki versions

---

### ðŸŸ¢ When TSDB Is the Right Choice

âœ” Production
âœ” Medium â†’ large scale
âœ” Kubernetes workloads
âœ” High label cardinality
âœ” Long retention

> **TSDB is the present and the future of Loki indexing.**

---

## ðŸ§  **Side-by-Side Comparison (Memorize This)**

| Feature               | boltdb-shipper | TSDB        |
| --------------------- | -------------- | ----------- |
| Status                | Legacy         | Recommended |
| Query speed           | Slow at scale  | Fast        |
| Index size            | Large          | Compact     |
| Object storage IO     | High           | Lower       |
| Cardinality tolerance | Low            | High        |
| Future investment     | âŒ             | âœ…          |

---

## ðŸ”´ **Why Grafana Moved to TSDB**

Real-world pain with boltdb-shipper:

- Queries touching days of data
- Thousands of index files per query
- Expensive S3/MinIO reads
- Slow dashboards

TSDB fixed this by:

- Time partitioning
- Better caching
- Efficient label lookup

---

## ðŸ§  **Does Index Type Affect Writes?**

âŒ No.

Writes always:

- Hit ingesters
- Create chunks
- Replicate via ring

Index type affects:

- Query planning
- Index storage
- Compaction behavior

---

## ðŸ§  **Compactor Behavior (Important)**

| Index          | Compactor Role    |
| -------------- | ----------------- |
| boltdb-shipper | Merge index files |
| TSDB           | Compact blocks    |

TSDB compaction is:

- Faster
- More predictable
- Less IO-heavy

---

## ðŸŸ¢ **What You Should Use Today**

> **Use TSDB unless you have a very specific reason not to.**

Grafanaâ€™s own guidance:

- New installs â†’ TSDB
- Existing installs â†’ migrate when possible

---

## ðŸ§  **Migration (High-Level)**

- You **cannot mix** index types
- Migration requires:

  - New schema
  - New index prefix

- Old data remains readable
- New data uses TSDB

(We can deep dive this separately.)

---

## ðŸ§  Memorization Block (Critical)

### ðŸ”‘ Mnemonic: **F-S-T**

| Letter | Meaning            |
| ------ | ------------------ |
| **F**  | Files (boltdb)     |
| **S**  | Scans              |
| **T**  | TSDB = Time blocks |

If queries are slow â†’ **index choice matters**.

---

## ðŸ§  Final Takeaway (Very Important)

- Index â‰  data
- boltdb-shipper is legacy
- TSDB is optimized for:

  - Kubernetes
  - Labels
  - Time

- Most Loki performance issues are **index-related**
- Choosing TSDB early avoids pain later

> **Chunks store logs. Index decides speed.**
