# ğŸ§© Prometheus Metrics with Multiple Labels â€” Complete Q&A Topic

## â“Q1. What is a â€œmulti-label metricâ€ in Prometheus?

**ğŸŸ¢ Answer:**
A _multi-label metric_ is one metric name that has multiple **label dimensions** to describe specific characteristics of whatâ€™s being measured.

Example:

```text
http_requests_total{method="GET", path="/login", status="200"} 15234
```

Here, `http_requests_total` is the metric name, and the labels (`method`, `path`, `status`) describe which requests those numbers refer to.

Each **unique combination of label values** becomes a _separate time series_ in Prometheus.

---

## â“Q2. Does Prometheus create separate time series for each label combination?

**ğŸŸ¢ Yes â€” exactly.**

Every unique label combination creates an independent time series.

Example:

```text
http_requests_total{method="GET", path="/login", status="200"} 100
http_requests_total{method="GET", path="/login", status="400"} 5
http_requests_total{method="POST", path="/checkout", status="200"} 10
```

Prometheus stores these as **three different series** internally:

- (GET, /login, 200)
- (GET, /login, 400)
- (POST, /checkout, 200)

They each evolve independently over time â€” separate samples, separate timestamps, separate rates.

---

## â“Q3. How are multi-label metrics stored in the appâ€™s memory?

**ğŸ§  Answer:**
When you use a Prometheus client library, the app holds a **metric registry** in memory.
Each label combination is a _metric object_ (usually a counter, gauge, histogram, or summary).

For example (Python style):

```python
from prometheus_client import Counter
HTTP_REQUESTS = Counter("http_requests_total", "desc", ["method", "path", "status"])
```

When you do:

```python
HTTP_REQUESTS.labels("GET", "/login", "400").inc()
```

the library creates (or reuses) an in-memory object representing that label set and increments it.
That object stays in memory as long as the process lives â€” not per-request.

---

## â“Q4. Does Prometheus scrape all label combinations each interval?

**ğŸŸ¢ Yes.**

Every time Prometheus scrapes the `/metrics` endpoint, the application exports _all current label/value pairs_ it knows about.

So if your app exposes:

```text
http_requests_total{method="GET",path="/login",status="400"} 5
http_requests_total{method="POST",path="/checkout",status="200"} 10
```

then **both** of those lines are returned during _every scrape_ (even if they didnâ€™t change).

---

## â“Q5. What if a specific label (like `/login`, status=400) had no requests during that 15-second interval?

**ğŸŸ¢ Answer:**
It still appears â€” with the same value as before.

Prometheus doesnâ€™t skip or hide unchanged metrics.
If `/login 400` was 5 at t=0s and still 5 at t=15s, both scrapes will include it with value 5.

Thatâ€™s how Prometheus knows that nothing new happened for that label combination.

---

## â“Q6. What if a _new_ label combination appears between scrapes?

**ğŸ§© Answer:**
When a new label appears (say, a new endpoint or status code), the client library creates a _new time series_ in memory.
At the next scrape, Prometheus sees this new combination for the first time and begins tracking it.

Example:

```ini
Before: /login only
After: /checkout appears â†’ new series created
```

From that moment on, `/checkout` is a permanent time series until the app stops or deletes it.

---

## â“Q7. Does Prometheus remove old label combinations automatically?

**ğŸ”´ No.**
Once a label combination has been scraped at least once, Prometheus keeps its data forever (until data retention expires).
Even if the app stops exporting that label later, the historical samples remain in the time-series database.

However, if the metric **no longer appears in scrapes**, Prometheus will mark the series as â€œstaleâ€ after about 5 minutes of silence, so queries stop returning live values.

---

## â“Q8. Can multi-label metrics cause high memory or storage usage?

**âš ï¸ Yes â€” through â€œcardinality explosion.â€.**

Each label combination = a new time series.
If you have unbounded labels (like `user_id`, `session`, `url_query`), you can easily create millions of series.

Example (bad):

```text
http_requests_total{user_id="12345",path="/home"} 1
```

Now every user_id creates a new time series â†’ huge memory load, slow scrapes.

Best practice:

- Keep labels **low-cardinality** (small set of possible values).
- Avoid unique identifiers in labels.

---

## â“Q9. When Prometheus scrapes, how does it know which label series changed?

**ğŸ§® Answer:**
It doesnâ€™t need to.
Prometheus just pulls _all current values_ again.
It then compares them to previous samples to compute rates or increases when you query.

You can check change rate with PromQL:

```promql
rate(http_requests_total{path="/login",status="400"}[1m])
```

This calculates per-second increase of that exact label combination over 1 minute.

---

## â“Q10. If a metric with specific labels hasnâ€™t changed, does Prometheus store a new sample anyway?

**ğŸ”µ Yes, but only if scraped successfully.**

Prometheus stores one sample per time series per scrape.
If the value hasnâ€™t changed, it still records it (though it compresses identical values efficiently).

Thatâ€™s why `scrape_interval` impacts disk usage â€” not just metric updates.

---

## â“Q11. Are label values dynamic or fixed?

**ğŸ§  Both â€” depends on your app logic.**

- **Static labels:** constant values like `instance`, `job`, `environment`.
- **Dynamic labels:** change depending on requests (`status`, `path`, etc.).

Prometheus sees them all as equal â€” just more dimensions of the same metric name.

---

## â“Q12. What if I have multiple labels (method, path, status)?

Can I aggregate across some of them?

**ğŸŸ¢ Absolutely.**
PromQL lets you aggregate on any label subset.

Examples:

```promql
# Sum over all paths
sum(rate(http_requests_total[5m])) by (status)

# Sum only across status but keep path
sum(rate(http_requests_total[5m])) by (path)
```

PromQLâ€™s `by()` and `without()` operators let you choose how to collapse or keep dimensions.

---

## â“Q13. How does label ordering affect Prometheus?

**âš™ï¸ It doesnâ€™t.**
Labels are a **set**, not an ordered list.
The following two metrics are identical:

```ini
http_requests_total{path="/login",status="400"}
http_requests_total{status="400",path="/login"}
```

Prometheus internally hashes labels as unordered key-value pairs.

---

## â“Q14. Can labels change meaning between scrapes?

**âš ï¸ They _can_, but thatâ€™s dangerous.**

If you reuse the same label combination to mean something different (e.g., `path="/user/123"` now means a different user later), Prometheus will still treat it as the same time series.
That corrupts your data interpretation.

Best practice â†’ label values should represent **consistent, stable categories**.

---

## â“Q15. TL;DR Summary â€” Multi-Label Metric Behavior

| Behavior                                  | Explanation                                   |
| ----------------------------------------- | --------------------------------------------- |
| Each unique label combo = one time series | `/login 400` and `/login 200` are independent |
| All label series scraped each interval    | Exported every time, changed or not           |
| New label â†’ new series                    | Automatically added next scrape               |
| Old label gone â†’ stale after few minutes  | Data remains in history                       |
| No requests â†’ value remains same          | Still scraped and visible                     |
| High label variety â†’ memory risk          | Keep labels low-cardinality                   |
| PromQL aggregation                        | Use `sum()` / `by()` / `without()` to combine |
| Label order irrelevant                    | Treated as unordered pairs                    |
