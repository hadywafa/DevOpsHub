# ‚úçüèª **Hands On Prometheus Authentication**

> Note: many popular exporters (e.g., `node_exporter`, `blackbox_exporter`) **don‚Äôt ship full auth**. The most reliable pattern is to **put a proxy (Nginx/Traefik/Caddy/Envoy) in front** or implement auth in your **app exporter code**. TLS/mTLS is typically done at the proxy or service mesh.

---

## 1. üîê **Basic Authentication (username/password)**

### üìå **Option A** ‚Äî Reverse proxy (Nginx) in front of any exporter

_Works for node_exporter and others that lack built-in auth._

**1) Create credentials (bcrypt):**

```bash
sudo apt-get install -y apache2-utils
sudo htpasswd -c -B /etc/nginx/.htpasswd prometheus
```

**2) Nginx vhost protecting `/metrics`:**

```nginx
# /etc/nginx/conf.d/exporter.conf
server {
  listen 9101 ssl http2;
  server_name exporter.local;

  ssl_certificate     /etc/nginx/exp.crt;   # use real certs in prod
  ssl_certificate_key /etc/nginx/exp.key;

  location = /metrics {
    auth_basic "Protected Metrics";
    auth_basic_user_file /etc/nginx/.htpasswd;

    proxy_pass http://127.0.0.1:9100/metrics;  # exporter bound to localhost
    proxy_read_timeout 10s;
  }
}
```

**3) Prometheus scrape (client side):**

```yaml
scrape_configs:
  - job_name: "node_exporter_secure"
    scheme: https
    static_configs: [{ targets: ["exporter.local:9101"] }]
    basic_auth:
      username: "prometheus"
      password: "<YOUR_PASSWORD>"
    tls_config:
      ca_file: "/etc/prometheus/ca.crt"
```

---

### üìå **Option B** ‚Äî App-level **Basic Auth** (ASP.NET Core Minimal API)

_Use when you own the exporter code (C#). Keeps `/metrics` private without a proxy._

**Packages (optional):** none required (built-in HTTP auth header parsing).
**Secrets:** store in environment variables or appsettings (don‚Äôt hardcode).

```csharp
// Program.cs (net8.0)
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Text;
using Microsoft.AspNetCore.Http.Extensions;
using Prometheus; // dotnet add package prometheus-net

var builder = WebApplication.CreateBuilder(args);

// Recommended: pull from env or secrets
var user = builder.Configuration["METRICS_USER"] ?? "prometheus";
var pass = builder.Configuration["METRICS_PASS"] ?? "s3cr3t";

var app = builder.Build();

// Expose default process metrics, GC, etc.
app.UseHttpMetrics();

bool CheckBasic(HttpRequest req)
{
    if (!req.Headers.TryGetValue("Authorization", out var auth)) return false;

    if (!AuthenticationHeaderValue.TryParse(auth!, out var header)) return false;
    if (!"Basic".Equals(header.Scheme, StringComparison.OrdinalIgnoreCase)) return false;

    var raw = Convert.FromBase64String(header.Parameter ?? "");
    var decoded = Encoding.UTF8.GetString(raw);
    var parts = decoded.Split(':', 2);
    if (parts.Length != 2) return false;

    // Constant-time compare to avoid timing leaks
    return CryptographicOperations.FixedTimeEquals(
        Encoding.UTF8.GetBytes(parts[0]), Encoding.UTF8.GetBytes(user)
    ) && CryptographicOperations.FixedTimeEquals(
        Encoding.UTF8.GetBytes(parts[1]), Encoding.UTF8.GetBytes(pass)
    );
}

app.MapGet("/metrics", (HttpContext ctx) =>
{
    if (!CheckBasic(ctx.Request))
    {
        ctx.Response.Headers["WWW-Authenticate"] = @"Basic realm=""Metrics""";
        return Results.Unauthorized();
    }
    return Results.Extensions.PrometheusExporter(); // exposes metrics
});

app.Run();
```

**Prometheus scrape:**

```yaml
scrape_configs:
  - job_name: "app_exporter_basic"
    static_configs: [{ targets: ["app-host:8000"] }]
    basic_auth:
      username: "prometheus"
      password: "s3cr3t"
```

> Tip: for higher security, hash the password and compare hashes; or integrate with a secret manager.

---

### üìå **Option C** ‚Äî Kubernetes Ingress (Nginx) Basic Auth

_No code changes; protect `/metrics` at the edge._

```bash
htpasswd -c -B ./auth prometheus
kubectl create secret generic exporter-basic-auth -n observability --from-file=auth=./auth
```

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: exporter-basic
  namespace: observability
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: exporter-basic-auth
    nginx.ingress.kubernetes.io/auth-realm: "Protected Metrics"
spec:
  tls:
    - hosts: ["exporter.example.com"]
      secretName: exporter-tls
  rules:
    - host: exporter.example.com
      http:
        paths:
          - path: /metrics
            pathType: Exact
            backend:
              service:
                name: node-exporter
                port:
                  number: 9100
```

**Prometheus scrape** = same as in Option A (Basic + HTTPS).

---

## 2. ü™™ **Bearer Token (API key / JWT)**

### üìå **Option A** ‚Äî App-level **Bearer token** (ASP.NET Core Minimal API)

**Static token (simplest):**

```csharp
// Program.cs
using System.Text;
using Microsoft.Net.Http.Headers;
using Prometheus;

var builder = WebApplication.CreateBuilder(args);
var token = builder.Configuration["METRICS_BEARER"] ?? "replace-me-token";

var app = builder.Build();
app.UseHttpMetrics();

app.MapGet("/metrics", (HttpContext ctx) =>
{
    var auth = ctx.Request.Headers.Authorization.ToString();
    if (!auth.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase) ||
        auth["Bearer ".Length..] != token)
    {
        return Results.Unauthorized();
    }
    return Results.Extensions.PrometheusExporter();
});

app.Run();
```

**Prometheus scrape (file-based token is safer):**

```yaml
scrape_configs:
  - job_name: "app_exporter_token"
    static_configs: [{ targets: ["app-host:8000"] }]
    bearer_token_file: "/etc/prometheus/tokens/app-metrics.jwt"
```

**JWT validation (server-side) using `JwtBearer`:**

```csharp
// Program.cs
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using Prometheus;

var builder = WebApplication.CreateBuilder(args);

builder.Services
  .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
  .AddJwtBearer(options =>
  {
      options.Authority = builder.Configuration["JWT:Authority"]; // e.g., https://login.microsoftonline.com/<tenant>/v2.0
      options.Audience  = builder.Configuration["JWT:Audience"];  // e.g., "prometheus"
      options.TokenValidationParameters = new TokenValidationParameters
      {
          ValidateIssuer = true,
          ValidateAudience = true,
          ValidateLifetime = true
      };
  });

var app = builder.Build();
app.UseAuthentication();
app.UseAuthorization();
app.UseHttpMetrics();

app.MapGet("/metrics", (HttpContext ctx) =>
{
    // Require authenticated principal
    if (!ctx.User.Identity?.IsAuthenticated ?? true)
        return Results.Unauthorized();

    return Results.Extensions.PrometheusExporter();
}).RequireAuthorization();

app.Run();
```

**Prometheus scrape:**

```yaml
scrape_configs:
  - job_name: "app_exporter_jwt"
    static_configs: [{ targets: ["app-host:8000"] }]
    bearer_token_file: "/etc/prometheus/tokens/prometheus.jwt" # Minted for 'Audience' above
    tls_config:
      ca_file: "/etc/prometheus/ca.crt" # if your Authority/JWKS requires custom CA
```

---

## 3. üîí **TLS / mTLS (certificates)**

### üìå **Option A** ‚Äî Nginx TLS termination + optional **mTLS**

_Encrypt traffic and (optionally) require Prometheus client certs._

```nginx
server {
  listen 8443 ssl http2;
  server_name exporter.local;

  ssl_certificate     /etc/nginx/server.crt;
  ssl_certificate_key /etc/nginx/server.key;

  # mTLS (optional): require Prometheus client cert
  # ssl_client_certificate /etc/nginx/ca.crt;
  # ssl_verify_client on;

  location = /metrics {
    proxy_pass http://127.0.0.1:8000/metrics;  # your ASP.NET exporter
  }
}
```

**Prometheus scrape (mTLS):**

```yaml
scrape_configs:
  - job_name: "app_exporter_mtls"
    scheme: https
    static_configs: [{ targets: ["exporter.local:8443"] }]
    tls_config:
      ca_file: "/etc/prometheus/certs/ca.crt"
      cert_file: "/etc/prometheus/certs/prom-client.crt"
      key_file: "/etc/prometheus/certs/prom-client.key"
```

### üìå **Option B** ‚Äî ASP.NET Core **HTTPS / Kestrel** (server cert)

_Run HTTPS directly in your exporter without a proxy; mTLS also possible._

**appsettings.json:**

```json
{
  "Kestrel": {
    "Endpoints": {
      "Https": {
        "Url": "https://0.0.0.0:8443",
        "Certificate": {
          "Path": "/certs/server.pfx",
          "Password": "changeit"
        }
      }
    }
  }
}
```

**Program.cs (Kestrel + optional mTLS):**

```csharp
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using Prometheus;

var builder = WebApplication.CreateBuilder(args);

// Optional: enforce client certificates (mTLS)
builder.WebHost.ConfigureKestrel(options =>
{
    options.ConfigureHttpsDefaults(https =>
    {
        // Require client certs? uncomment:
        // https.ClientCertificateMode = Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode.RequireCertificate;
        // https.SslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13;
    });
});

var app = builder.Build();
app.UseHttpMetrics();

// If mTLS enabled, validate client cert in middleware:
// app.Use(async (ctx, next) => {
//     var cert = await ctx.Connection.GetClientCertificateAsync();
//     if (cert is null || !IsTrusted(cert)) { ctx.Response.StatusCode = 401; return; }
//     await next();
// });

app.MapGet("/metrics", () => Results.Extensions.PrometheusExporter());
app.Run();
```

> In mTLS mode, implement `IsTrusted(cert)` (thumbprint/issuer/chain validation) or use a reverse proxy / service mesh to offload that logic.

### üìå **Option C** ‚Äî Service Mesh mTLS (Istio/Linkerd)

_Zero app changes; mesh injects sidecars and enforces TLS + identity._

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata: { name: default, namespace: observability }
spec: { mtls: { mode: STRICT } }

---
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata: { name: allow-prometheus, namespace: observability }
spec:
  selector: { matchLabels: { app: app-exporter } }
  rules:
    - from:
        - source:
            principals: ["cluster.local/ns/monitoring/sa/prometheus"]
      to:
        - operation: { methods: ["GET"], paths: ["/metrics"] }
```

**Prometheus scrape:** no auth headers needed; the mesh authenticates and encrypts.

---

## üèÅ **Quick chooser**

- **Simplest & strong:** App-level **Basic** or **Bearer** in ASP.NET Core (above) + **HTTPS** (Kestrel or proxy).
- **Enterprise / zero-trust:** **mTLS** (Nginx/Envoy or service mesh) + optional **Bearer**/Basic for layered defense.
- **Kubernetes-native:** Ingress (Basic/TLS) or Mesh mTLS; keep app code minimal.

---

### ü§ì **Prometheus-side reminders**

- Prefer `bearer_token_file` and `tls_config` with real CAs (not `insecure_skip_verify`).
- Keep secrets out of Git; mount via Kubernetes Secrets or OS secret stores.
- Rotate tokens/certs on a schedule.
