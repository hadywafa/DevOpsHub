# ğŸ§© Understanding `summary` in Prometheus

## ğŸ’¬ What Is a Summary?

A **Summary** in Prometheus is a metric type that measures:

> ğŸ’¡ â€œHow long things takeâ€ (latency) or â€œhow big things areâ€ (sizes),
> and **calculates quantiles (like p90, p95, p99)** **directly inside the client application** before Prometheus even scrapes it.

Think of it like this:

> A **Histogram** stores _raw bucket data_ for Prometheus to calculate percentiles later.
> A **Summary** calculates those percentiles itself before exporting them.

---

<div align="center" style="background-color: #11171F; border-radius: 10px; border: 2px solid">
    <img src="image/1762539619855.png" alt="Instant Vector" style="width: 60%">
</div>

---

## â‰ï¸ How a Summary Metric Looks

Letâ€™s say your code measures request duration like this:

```go
requestDuration := prometheus.NewSummary(prometheus.SummaryOpts{
    Name: "http_request_duration_seconds",
    Help: "Request duration in seconds.",
})
```

Prometheus will expose **three types of time series** for this metric:

| Metric Name                                      | Meaning                       |
| ------------------------------------------------ | ----------------------------- |
| `http_request_duration_seconds_sum`              | Total sum of all observations |
| `http_request_duration_seconds_count`            | Number of observations        |
| `http_request_duration_seconds{quantile="0.5"}`  | 50th percentile (median)      |
| `http_request_duration_seconds{quantile="0.9"}`  | 90th percentile               |
| `http_request_duration_seconds{quantile="0.99"}` | 99th percentile               |

---

## ğŸ“ Example Output

```ini
http_request_duration_seconds{quantile="0.5"}  0.245
http_request_duration_seconds{quantile="0.9"}  0.512
http_request_duration_seconds{quantile="0.99"} 1.221
http_request_duration_seconds_sum  1234.56
http_request_duration_seconds_count  5021
```

Interpretation:

- 50% of requests finished in â‰¤ 0.245s
- 90% finished in â‰¤ 0.512s
- 99% finished in â‰¤ 1.221s

Prometheus just scrapes those numbers â€” it doesnâ€™t calculate them.

---

## âš™ï¸ How Summaries Work Internally

Summaries use an **algorithm** (like _CKMS Quantile Estimation_) inside the app to approximate quantiles.

- They maintain a sliding window of observations (default 10 min).
- When scraped, they expose the quantiles you configured (e.g., 0.5, 0.9, 0.99).
- The calculation happens _before_ Prometheus gets the data.

> ğŸ§® You canâ€™t change the quantiles later â€” theyâ€™re baked into the metric at export time.

---

## ğŸ§  Why Summaries Exist

Summaries are useful when:

- You only care about latency percentiles _for that instance_.
- You donâ€™t need to aggregate across multiple instances or jobs.
- You want **precise per-process quantiles** (not bucket-based approximations).

---

## âš”ï¸ Histogram vs Summary â€” The Ultimate Comparison

<div align="center" style="background-color: #11171F; border-radius: 10px; border: 2px solid">
    <img src="image/1762539602503.png" alt="Instant Vector" style="width: 60%">
</div>

---

| Feature                           | **Histogram**                                                                                | **Summary**                                                              |
| --------------------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **Calculation location**          | Prometheus calculates percentiles (using `histogram_quantile()`)                             | The **client app** calculates percentiles                                |
| **Quantile flexibility**          | You can compute _any_ quantile later (`0.5`, `0.95`, `0.99`, etc.)                           | Quantiles are fixed when instrumented (e.g., `0.9`, `0.99`)              |
| **Aggregatable across instances** | âœ… Yes (because buckets can be summed)                                                       | âŒ No (quantiles canâ€™t be averaged or combined)                          |
| **Metric names**                  | `*_bucket`, `*_sum`, `*_count`                                                               | `*_sum`, `*_count`, `{quantile="..."}`                                   |
| **Function used**                 | `histogram_quantile()`                                                                       | Directly scrape `quantile="..."` metrics                                 |
| **Accuracy**                      | Approximate (depends on bucket setup)                                                        | More precise (depends on algorithm)                                      |
| **Configuration complexity**      | You choose bucket boundaries                                                                 | You define quantile values & error                                       |
| **When to use**                   | When you need **global**, **aggregated**, or **flexible** quantiles                          | When you need **local**, **precise**, or **instance-specific** quantiles |
| **Example**                       | `histogram_quantile(0.95, sum by (le, job)(rate(http_request_duration_seconds_bucket[5m])))` | `http_request_duration_seconds{quantile="0.95"}`                         |

---

## ğŸ§  Visual Comparison

```mermaid
flowchart TD
    A["App A Histogram (buckets)"] -->|scrape| P[Prometheus]
    B["App B Histogram (buckets)"] -->|scrape| P
    P -->|combine buckets| C["histogram_quantile() âœ Global p95"]

    subgraph "Histogram Flow"
    A
    B
    P
    end

    D["App A Summary (calculates p95)"] -->|scrape quantiles| X[Prometheus]
    E["App B Summary (calculates p95)"] -->|scrape quantiles| X
    X -->|âŒ cannot aggregate| Y["No global p95 possible"]

    subgraph "Summary Flow"
    D
    E
    X
    end
```

---

## ğŸ’¬ Example Use Cases

| Scenario                                                 | Best Choice  | Why                                          |
| -------------------------------------------------------- | ------------ | -------------------------------------------- |
| You want **global p95 latency across all pods**          | ğŸŸ© Histogram | Prometheus can merge buckets                 |
| You want **per-instance accurate latency p95**           | ğŸŸ¦ Summary   | Direct, no aggregation                       |
| You want **flexible percentiles (p50, p90, p99)** later  | ğŸŸ© Histogram | You can choose Ï† on demand                   |
| You want **simple metrics in a single binary**           | ğŸŸ¦ Summary   | No external function required                |
| You use **Kubernetes + Prometheus + Grafana dashboards** | ğŸŸ© Histogram | Easier to aggregate across pods and services |

---

## ğŸ’¡ Quick Example of Each

### ğŸŸ¦ Summary

Client-side quantile estimation:

```promql
http_request_duration_seconds{quantile="0.95"}
```

### ğŸŸ© Histogram

Server-side quantile calculation:

```promql
histogram_quantile(
  0.95,
  sum by (le, job) (rate(http_request_duration_seconds_bucket[5m]))
)
```

Both give a number like â€œp95 latency = 0.85sâ€
â€”but only the histogram version can be aggregated globally.

---

## âš ï¸ Common Mistakes

### âŒ Trying to aggregate summaries

```promql
avg(http_request_duration_seconds{quantile="0.95"})  # meaningless
```

Each appâ€™s quantile algorithm uses different data â€” you canâ€™t average p95s.

### âŒ Mixing histogram and summary data

They represent different collection methods; treat them separately.

---

## ğŸ§© Summary (pun intended ğŸ˜„)

| Concept                                | Histogram                              | Summary       |
| -------------------------------------- | -------------------------------------- | ------------- |
| **Where quantiles are calculated**     | In Prometheus (`histogram_quantile()`) | In client app |
| **Can aggregate?**                     | âœ… Yes                                 | âŒ No         |
| **Can choose Ï† later?**                | âœ… Yes                                 | âŒ No         |
| **Used for global dashboards**         | âœ… Ideal                               | ğŸš« Not ideal  |
| **Used for single instance precision** | âš™ï¸ Okay                                | âœ… Perfect    |
| **Has buckets?**                       | âœ… Yes (`_bucket`)                     | âŒ No         |
| **Needs configuration**                | Buckets                                | Quantiles     |

---

## ğŸ§  TL;DR (Remember This!)

| Metric Type   | Best For                                    | Aggregation | Quantile Flexibility      |
| ------------- | ------------------------------------------- | ----------- | ------------------------- |
| **Histogram** | Aggregated metrics, dashboards, global SLOs | âœ… Yes      | âœ… Any quantile (runtime) |
| **Summary**   | Precise local metrics, simple services      | âŒ No       | âŒ Fixed quantiles only   |

---

ğŸ’¬ **Human Analogy:**

- **Histogram**: You record how many people finished a race under 5, 10, 15 minutes, etc.
  Later, you can compute any percentile you want.
- **Summary**: The runner tells you, â€œMy 95th percentile speed was X.â€
  You canâ€™t recompute it or merge it with others.
