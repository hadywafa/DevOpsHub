# üéØ PromQL Selectors, Filtering & Matchers

Prometheus collects millions of time series like:

```ini
node_cpu_seconds_total{instance="server1", job="node", cpu="0"}
```

When you query PromQL, you **select** 3975which of these time series to include using **selectors** and **label matchers**.

---

## üß© 1. Metric Selector (Base Query)

A **metric selector** is the simplest possible query ‚Äî just the metric name.

### Example:

```promql
up
```

‚úÖ Means: ‚ÄúGet the latest value for _all_ time series of the metric `up`.‚Äù

Returns something like:

| instance | job  | value |
| -------- | ---- | ----- |
| srv1     | node | 1     |
| srv2     | node | 0     |
| srv3     | node | 1     |

Here, Prometheus finds **every** `up` metric (one per target).
That‚Äôs an **instant vector** because it returns one sample per time series.

---

## üéØ 2. Label Matchers ‚Äî Filtering with `{}`

To narrow down which time series you want, you add a **label selector**.

### Syntax:

```promql
metric_name{label_name="value"}
```

PromQL uses the labels that were scraped with each metric (like `job`, `instance`, `cpu`, `mode`, etc).

---

### Example 1:

```promql
up{job="node"}
```

‚û°Ô∏è Only returns metrics where the label `job` equals `"node"`.

| instance | job  | value |
| -------- | ---- | ----- |
| srv1     | node | 1     |
| srv2     | node | 0     |

---

### Example 2:

```promql
node_cpu_seconds_total{instance="server1", cpu="0"}
```

‚û°Ô∏è Returns **only** time series from **server1**, **CPU 0**.

---

## üßÆ 3. Multiple Label Filters

You can combine filters inside `{}` by separating them with commas.

```promql
node_cpu_seconds_total{instance="server1", cpu="0", mode="idle"}
```

Prometheus applies **AND logic** for multiple filters ‚Äî
so it must match _all_ of them.

---

## ‚öôÔ∏è 4. Label Matcher Operators

PromQL supports **four types of matchers** ‚Äî exact and regex-based.

| Operator | Meaning         | Example            | Description            |     |
| -------- | --------------- | ------------------ | ---------------------- | --- |
| `=`      | Equal to        | `job="api"`        | Exact match            |     |
| `!=`     | Not equal       | `instance!="srv1"` | Exclude one value      |     |
| `=~`     | Regex match     | `job=~"api | db"`  | Matches _any_ in regex |
| `!~`     | Regex not match | `job!~"api | db"`  | Excludes regex matches |

---

### üß± Examples

**1. Exact match:**

```promql
up{job="node"}
```

‚úÖ Matches only metrics where job = node.

---

**2. Not equal:**

```promql
up{instance!="srv1"}
```

‚úÖ Returns everything except srv1.

---

**3. Regex match:**

```promql
up{job=~"api|frontend|backend"}
```

‚úÖ Matches all jobs named api, frontend, or backend.

---

**4. Regex not match:**

```promql
up{job!~"test|staging"}
```

‚úÖ Excludes jobs for test and staging environments.

---

## üß† 5. Combining Metric + Range + Filters

You can use **label filters** with both **instant** and **range vectors**.

### Instant Vector Example:

```promql
up{job="node"}
```

‚Üí Current status for node jobs.

### Range Vector Example:

```promql
http_requests_total{job="frontend"}[5m]
```

‚Üí All request count samples for the past 5 minutes from frontend job.

---

## üîç 6. No Metric Name = ‚ÄúAll Metrics‚Äù

You can even query **only by labels** (not recommended, but possible):

```promql
{instance="srv1"}
```

‚û°Ô∏è Returns **every metric** that has that label.
Useful for quick debugging ‚Äî but heavy on the server.

---

## üß± 7. Matchers in Real-Life Example

Let‚Äôs say you have this metric:

```ini
node_cpu_seconds_total{job="node", instance="srv1", cpu="0", mode="idle"}
```

Now check what happens with each matcher üëá

| Query                                           | Result                          |
| ----------------------------------------------- | ------------------------------- |
| `node_cpu_seconds_total`                        | All CPUs, all servers           |
| `node_cpu_seconds_total{instance="srv1"}`       | All CPUs from server1           |
| `node_cpu_seconds_total{mode="idle"}`           | Only idle mode                  |
| `node_cpu_seconds_total{cpu="0", mode!="idle"}` | CPU 0 but not idle              |
| `node_cpu_seconds_total{instance=~"srv.*"}`     | All servers starting with "srv" |

---

## ‚ö° 8. Chaining Matchers with Functions

You can combine matchers inside PromQL functions:

```promql
rate(node_cpu_seconds_total{mode!="idle"}[5m])
```

‚û°Ô∏è Calculates CPU usage rate (ignoring idle time).

---

## üßÆ 9. Common Mistake: Forgetting `{}`

‚ùå Wrong:

```promql
up=~"api"
```

‚úÖ Right:

```promql
up{job=~"api"}
```

Without `{}`, PromQL thinks you‚Äôre comparing a metric ‚Äî which causes an error.

---

## üß≠ 10. Think of It Like SQL

| SQL Concept                  | PromQL Equivalent  |
| ---------------------------- | ------------------ |
| `SELECT * FROM table`        | `metric_name`      |
| `WHERE column=value`         | `{label="value"}`  |
| `WHERE column LIKE '%text%'` | `{label=~"regex"}` |
| `WHERE column <> value`      | `{label!="value"}` |

---

## ‚úÖ Summary Table

| Concept         | Example        | Meaning                               |
| --------------- | -------------- | ------------------------------------- |
| Metric Selector | `up`           | Select all time series of that metric |
| Label Filter    | `{job="node"}` | Filter time series by label           |
| Range Selector  | `[5m]`         | Select data points over time range    |
| Exact Match     | `=`            | Match exact value                     |
| Not Match       | `!=`           | Exclude value                         |
| Regex Match     | `=~`           | Match using regex                     |
| Regex Not Match | `!~`           | Exclude using regex                   |

---

## üß† Mental Model

> PromQL selection = **Find the right time series before calculating anything.**

So:

1. Start with a metric name ‚Üí `http_requests_total`
2. Filter with labels ‚Üí `{job="api", instance!="test"}`
3. Add time range ‚Üí `[5m]`
4. Apply a function ‚Üí `rate(...[5m])`
5. Aggregate ‚Üí `sum(rate(...[5m])) by (job)`

---

Would you like me to continue next with **aggregation operators** (`sum`, `avg`, `min`, `max`, `count`, `by`, `without`)?
That‚Äôs the next natural step after selection and filtering.
