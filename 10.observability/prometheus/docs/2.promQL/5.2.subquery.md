# ğŸ” **PromQL Subqueries** â€” The Power of Querying a Query

## ğŸ’¬ **The Simple Idea**

A **subquery** is when you take a normal PromQL expression  
ğŸ‘‰ wrap it with `[range:step]`  
ğŸ‘‰ and then query it _over time_, instead of _at a single point_.

> In short: â€œLetâ€™s evaluate this query over time, not just once.â€

Think of it like watching **how your graph itself changes** over time.

---

### ğŸ”¹ Without Subquery

You might run:

```promql
rate(http_requests_total[5m])
```

This gives the **current per-second rate**, averaged over the last 5 minutes.

Thatâ€™s fine â€” but itâ€™s _just one moment_.  
What if you want to see how that rate has been changing for the past **2 hours**?

---

### ğŸ”¹ With Subquery

Boom ğŸ’¥ â€” thatâ€™s where you use a subquery:

```promql
rate(http_requests_total[5m])[2h:1m]
```

Now youâ€™re saying:

> â€œCalculate the 5-minute rate for every 1-minute step across the last 2 hours.â€

So Prometheus will:

1. Go back 2 hours in time
2. At every 1-minute step, calculate `rate(http_requests_total[5m])`
3. Return all those results as a **range vector** you can then analyze further!

---

<div align="center" style="background-color: #11171F; border-radius: 10px; border: 2px solid">
    <img src="image/1762536288717.png" alt="Instant Vector" style="width: 60%">
</div>

---

## âš™ï¸ **The Syntax**

```promql
<expression>[<range>:<resolution>]
```

- `<expression>` â†’ any PromQL query
- `<range>` â†’ how far back you want to look
- `<resolution>` â†’ how often to evaluate it (the â€œstepâ€)

**Example:**

```promql
rate(node_cpu_seconds_total[5m])[1h:30s]
```

â¡ï¸ â€œOver the last 1 hour, every 30 seconds, compute the 5-minute rate.â€

---

## ğŸ¯ **Why We Use Subqueries**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Use Case                | Description                                                         |
| ----------------------- | ------------------------------------------------------------------- |
| **Trend analysis**      | See how a metric evolves, not just its current rate                 |
| **Rolling averages**    | Smooth out noisy metrics with functions like `avg_over_time()`      |
| **Nested aggregations** | First compute per-second rate, then average that over a longer time |
| **Alert stability**     | Reduce false alarms by applying range functions to subqueries       |

</div>

---

## ğŸ” **Real Example â€” Nested Rate Analysis**

You want to know:

> â€œWhatâ€™s the average _request rate_ over the last 1 hour, based on 5-minute windows?â€

```promql
avg_over_time(rate(http_requests_total[5m])[1h:1m])
```

Letâ€™s decode it:

| Part                            | Meaning                                                     |
| ------------------------------- | ----------------------------------------------------------- |
| `rate(http_requests_total[5m])` | Get the per-second rate (smooth trend)                      |
| `[1h:1m]`                       | Recalculate that rate every 1 minute for the past hour      |
| `avg_over_time(...)`            | Take all those recalculated rates and compute their average |

So instead of a single static rate, you get a **1-hour rolling average of rates** â€” ultra-smooth and perfect for dashboards.

---

## ğŸ§© **Visual Explanation**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
    participant Prometheus
    participant Query
    participant Subquery
    Query->>Prometheus: rate(http_requests_total[5m])
    Note right of Query: Single evaluation<br/>Current value only
    Subquery->>Prometheus: rate(http_requests_total[5m])[1h:1m]
    Note right of Subquery: Evaluate rate() at <br/>every 1m step across 1h
```

</div>

---

## ğŸ§ª **Letâ€™s Compare: Normal Query vs Subquery**

### ğŸ”¸ Normal query:

```promql
rate(http_requests_total[5m])
```

â¡ï¸ One line per instance â†’ current rate.

### ğŸ”¸ Subquery:

```promql
rate(http_requests_total[5m])[2h:1m]
```

â¡ï¸ Each instance now has **a full time series** of its rate over 2 hours.

---

## ğŸ§  **You Can Nest Subqueries Too**

Yup. You can get wild like this:

```promql
max_over_time(
  avg(rate(http_requests_total[1m])[30m:1m])[2h:5m]
)
```

Hereâ€™s what happens:

1. `rate()` â†’ short-term request rate
2. `avg(...)[30m:1m]` â†’ average that rate over rolling 30-minute windows
3. `max_over_time(...)[2h:5m]` â†’ find the maximum of those rolling averages in the past 2 hours

Result: â€œThe highest 30-min average request rate in the last 2 hours.â€

---

## ğŸ”´ **Use Case**

### âŒ Without Subquery

<div align="center" style="background-color: #11171F; border-radius: 10px; border: 2px solid">
    <img src="image/1762535965438.png" alt="Instant Vector" style="width: 60%">
</div>

---

### âœ… With Subquery

<div align="center" style="background-color: #11171F; border-radius: 10px; border: 2px solid">
    <img src="image/1762536110067.png" alt="Instant Vector" style="width: 60%">
</div>

---

## ğŸ§° **Common Range Functions Used with Subqueries**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Function             | Purpose                     |
| -------------------- | --------------------------- |
| `avg_over_time()`    | Smooth out trends           |
| `max_over_time()`    | Find peaks                  |
| `min_over_time()`    | Find dips                   |
| `stddev_over_time()` | Measure volatility          |
| `count_over_time()`  | Count samples in the window |

</div>

---

These are usually combined **after** a subquery â€” to summarize trends over time.

---

## âš ï¸ **Important Notes (Gotchas)**

### 1. â± Donâ€™t confuse `[range]` vs `[range:step]`

- `[range]` â†’ Range selector (used inside functions like `rate()`)
- `[range:step]` â†’ Subquery (evaluate the expression multiple times)

### 2. ğŸ§® Be mindful of step size

- A too-small `:step` (like `1s`) â†’ too many samples â†’ heavy Prometheus load.
  Start with 1m or 5m steps.

### 3. ğŸ’¾ Subqueries consume more memory

- They calculate results for each step in your range â†’ more data in memory.

### 4. ğŸ§± Works on **instant vectors**, not range vectors directly

- Subqueries apply to queries that normally return instant vectors (like `rate()`), not range vectors.

---

## âœ… **Real Dashboard Use Case**

Imagine your serviceâ€™s request rate fluctuates wildly.  
You want to smooth it over 30 minutes and alert if it stays high.

```promql
avg_over_time(rate(http_requests_total[1m])[30m:1m]) > 10
```

Interpretation:

> â€œIf the _average_ of the per-second request rate (calculated every minute)  
> over the last 30 minutes is greater than 10 â†’ fire alert.â€

âœ… Smooth  
âœ… Accurate  
âœ… No false spikes

---

## ğŸ§¾ **TL;DR Summary**

<div align="center" style="background-color: #141a19ff;color: #a8a5a5ff; border-radius: 10px; border: 2px solid">

| Concept         | Meaning                                               |
| --------------- | ----------------------------------------------------- |
| **Subquery**    | Runs a query repeatedly over time                     |
| **Syntax**      | `<query>[range:step]`                                 |
| **Use it when** | You need to analyze how a metric evolves over time    |
| **Good for**    | Trends, smoothing, stable alerts                      |
| **Avoid if**    | You just need a single current value                  |
| **Example**     | `avg_over_time(rate(http_requests_total[5m])[1h:1m])` |

</div>

---

## ğŸ§  **Human Analogy**

> A normal query is a _snapshot_ â€” one photo.
>
> A subquery is a _timelapse video_ â€” many photos stitched together
> so you can see how things changed over time.
