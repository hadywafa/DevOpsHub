# ðŸŽ¯ `histogram_quantile()` â€” Turning Buckets into Percentiles

## ðŸ’¬ What It Does (in one line)

> The `histogram_quantile()` function estimates a **quantile (percentile)** (like p90, p95, p99)
> from **Prometheus histogram buckets** â€” typically produced by your app or exporters (e.g., latency histograms).

So instead of just â€œaverage latencyâ€, you can say:

> â€œ95% of requests complete in under _X seconds_.â€

Thatâ€™s a **p95 (95th percentile)** â€” and `histogram_quantile()` gives it to you.

---

## ðŸ§  Why We Need It

A simple `avg()` hides outliers:

- 99 fast requests (10ms)
- 1 slow request (10 seconds)
  â†’ Average â‰ˆ 0.1 second â€” looks fine, but your users are screaming. ðŸ˜…

**Percentiles** reveal the _worst-case user experience_:

- p50 (median) â†’ typical user
- p95 â†’ 95% of users faster than this
- p99 â†’ 99% faster than this (top 1% slowest)

Thatâ€™s what `histogram_quantile()` computes.

---

## ðŸ“¦ Where Data Comes From â€” The Histogram Metric

Applications instrumented with Prometheus client libraries expose **histogram metrics**.
Example metric name:

```ini
http_request_duration_seconds_bucket
```

They come with **buckets**, like this:

| Label                     | Meaning                            |
| ------------------------- | ---------------------------------- |
| `le` (less than or equal) | Upper bound of each latency bucket |
| `_count`                  | Total number of observations       |
| `_sum`                    | Sum of all observed values         |

### Example data

| Metric                                          | Value | description         |
| ----------------------------------------------- | ----- | ------------------- |
| http_request_duration_seconds_bucket{le="0.1"}  | 100   | 100 requests â‰¤ 0.1s |
| http_request_duration_seconds_bucket{le="0.5"}  | 350   | 350 requests â‰¤ 0.5s |
| http_request_duration_seconds_bucket{le="1"}    | 480   | 480 requests â‰¤ 1s   |
| http_request_duration_seconds_bucket{le="2"}    | 490   | 490 requests â‰¤ 2s   |
| http_request_duration_seconds_bucket{le="+Inf"} | 500   | 500 requests total  |

---

## ðŸ“ˆ How `histogram_quantile()` Works (step-by-step)

### Step 1: Find the right bucket range

We want, say, the **95th percentile** (p95).
Total = 500 â†’ 95% = 475th observation.

Between which buckets does it lie?

- 480 requests â‰¤ 1s
- 350 requests â‰¤ 0.5s
  â†’ 475th observation lies **between 0.5s and 1s**.

---

### Step 2: Interpolate between the buckets

Find where between the buckets the 95th percentile falls.

Use linear interpolation:
[
quantile_value = lower_bound + (upper_bound - lower_bound) * (target_count - lower_count) / (upper_count - lower_count)
]

Plug in:

- lower = 0.5s
- upper = 1s
- target = 475
- lower_count = 350
- upper_count = 480

---

$$
\begin{align*}
& 0.5 + (1 - 0.5) \cdot \frac{475 - 350}{480 - 350} &= 0.5 + 0.5 \cdot \frac{125}{130} &\approx 0.98\ \text{seconds}
\end{align*}
$$

---

âœ… So **p95 â‰ˆ 0.98 seconds.**

Thatâ€™s what Prometheus does internally when you call `histogram_quantile(0.95, ...)`.

---

## ðŸ§© The PromQL Formula

```promql
histogram_quantile(Ï†, sum(rate(metric_name_bucket[range])) by (le))
```

### Parameters

| Parameter            | Meaning                                         |
| -------------------- | ----------------------------------------------- |
| `Ï†`                  | Quantile value (e.g., 0.95 for p95)             |
| `metric_name_bucket` | Your histogram bucket metric                    |
| `[range]`            | Time window for rate calculation (e.g., `[5m]`) |

---

### Example (real-world)

Compute 95th percentile request duration per service:

```promql
histogram_quantile(
  0.95,
  sum by (le, job) (rate(http_request_duration_seconds_bucket[5m]))
)
```

ðŸ§© Explanation:

1. `rate(...[5m])` â†’ convert counters to per-second rates
2. `sum by (le, job)` â†’ combine buckets per job
3. `histogram_quantile(0.95, ...)` â†’ find latency where 95% of traffic is faster

Result â†’ one value per job: â€œ95% of requests took less than X seconds.â€

---

## ðŸ§® Typical Percentiles Youâ€™ll See

| Quantile (Ï†) | Meaning           |
| ------------ | ----------------- |
| `0.5`        | Median (p50)      |
| `0.9`        | 90th percentile   |
| `0.95`       | 95th percentile   |
| `0.99`       | 99th percentile   |
| `0.999`      | 99.9th percentile |

---

## ðŸ§° Common Variations

### ðŸ”¸ Per-route latency p95

```promql
histogram_quantile(
  0.95,
  sum by (le, route) (rate(http_request_duration_seconds_bucket[5m]))
)
```

### ðŸ”¸ Global service-wide p99 latency

```promql
histogram_quantile(
  0.99,
  sum by (le) (rate(http_request_duration_seconds_bucket[5m]))
)
```

### ðŸ”¸ Compare p95 latency across jobs

```promql
histogram_quantile(
  0.95,
  sum by (le, job) (rate(http_request_duration_seconds_bucket[10m]))
)
```

---

## âš ï¸ Key Rules to Remember

### âœ… Always use `rate()` or `increase()`

Histogram buckets are **counters**, so use `rate()` or `increase()` to get per-second or per-window values.
Otherwise, resets break your math.

Bad âŒ

```promql
histogram_quantile(0.95, sum by (le) (http_request_duration_seconds_bucket))
```

Good âœ…

```promql
histogram_quantile(0.95, sum by (le) (rate(http_request_duration_seconds_bucket[5m])))
```

---

### âœ… Always `sum` by `le`

Buckets must be aggregated by their upper bound `le` â€” otherwise the interpolation fails.

---

### âš™ï¸ Optional: Add `job`, `service`, or `instance` to `by()`

To get per-service or per-instance latency distributions:

```promql
sum by (le, service) (...)
sum by (le, instance) (...)
```

---

### âš ï¸ Donâ€™t confuse `_sum` and `_count`

- `_sum` = total latency (seconds) across requests
- `_count` = number of requests

> Use those to get **average latency**:

```promql
rate(http_request_duration_seconds_sum[5m])
/
rate(http_request_duration_seconds_count[5m])
```

â€¦but for **p95/p99**, you must use `_bucket` + `histogram_quantile()`.

---

## ðŸ“Š Visual Example (Grafana)

**Query:**

```promql
histogram_quantile(0.95,
  sum by (le) (rate(http_request_duration_seconds_bucket[5m]))
)
```

**Graph:**
Shows a curve over time â€” â€œ95% of requests complete under X seconds.â€

You can easily change `0.95` â†’ `0.99` â†’ `0.5` to visualize different percentiles.

---

## ðŸ§  Mental Model Summary

| Concept                | Think of it as...                                  |
| ---------------------- | -------------------------------------------------- |
| Buckets (`_bucket`)    | â€œCumulative frequency tableâ€                       |
| `le` label             | â€œUpper limit of each bucketâ€                       |
| `rate()`               | â€œRequests per second per bucketâ€                   |
| `sum by (le)`          | â€œMerge all instancesâ€™ buckets togetherâ€            |
| `histogram_quantile()` | â€œCalculate percentile cutoff across those bucketsâ€ |

---

## ðŸ’¬ Human Analogy

> Imagine 500 people waiting at an airport security line.
> Each bucket is a time threshold (â‰¤5 min, â‰¤10 min, â‰¤15 minâ€¦).
>
> You want to know:
> â€œHow long did 95% of people wait or less?â€
>
> You look at how many people cleared each line (bucket) and interpolate the 95th percentile.
> Thatâ€™s exactly what `histogram_quantile()` does.

---

## âœ… TL;DR Summary

| Term             | Meaning                                                          |
| ---------------- | ---------------------------------------------------------------- |
| **Function**     | `histogram_quantile(Ï†, sum by (le)(rate(metric_bucket[range])))` |
| **Purpose**      | Estimate p90/p95/p99 from histogram buckets                      |
| **Used With**    | Histogram metrics ending in `_bucket`                            |
| **Why `rate()`** | Buckets are counters; rate prevents resets                       |
| **Common Uses**  | Latency SLAs, response time SLOs, request durations              |
| **Outputs**      | Single value per label set = â€œX seconds for Ï† percentileâ€        |

---

### ðŸŽ¯ Example SLO Alert

> Alert if 95th percentile latency > 2 seconds for 10 minutes:

```promql
histogram_quantile(
  0.95,
  sum by (le, job) (rate(http_request_duration_seconds_bucket[5m]))
) > 2
```

Set duration in alert rule YAML:

```yaml
for: 10m
```

---

## ðŸ§© Final Visualization

```mermaid
flowchart LR
    A["http_request_duration_seconds_bucket{le=...}"]
      --> B["rate(...[5m])"]
      --> C["sum by (le, job)"]
      --> D["histogram_quantile(0.95, ...)"]
      --> E["p95 latency (seconds)"]
```
