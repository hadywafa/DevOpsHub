# ğŸš€ Deployment modes

Tempo is one binary, but it can start **different internal roles** based on **target**:

- `-target=all` â†’ run **everything** in one process (**Monolithic**)
- `-target=scalable-single-binary` â†’ run everything but **in a way that supports multiple replicas** (**SSB / scalable monolithic**)
- `-target=querier` / `distributor` / `ingester` / â€¦ â†’ run **one component per process** (**Microservices / distributed**)

So â€œdeployment modeâ€ is basically: **how many processes** and **what each process is responsible for**.

---

```mermaid
flowchart TB

    %% STYLE DEFINITIONS
    classDef bin fill:#1f2628,stroke:#4a5a5c,stroke-width:1px,color:#e8e8e8;
    classDef comp fill:#1c2b2e,stroke:#4a5a5c,stroke-width:1px,color:#e8e8e8;
    classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 900,animation: dash 25s linear infinite;

    %% MONOLITHIC MODE
    subgraph MONO["ğŸ›ï¸ Monolithic Mode"]
        X3@{ shape: braces, label: "Single Process" }
        M@{ shape: stadium, label: "ğŸ§± tempo -target=all\nDistributor + Ingester + Querier + Frontend + Compactor" }
    end

    %% SCALABLE SINGLE BINARY MODE
    subgraph SSB["ğŸ“¦ Scalable Single Binary"]
        X1@{ shape: braces, label: "N Replicas" }
        S1@{ shape: stadium, label: "âš™ï¸ tempo -target=scalable-single-binary" }
        S2@{ shape: stadium, label: "âš™ï¸ tempo -target=scalable-single-binary" }
        S3@{ shape: stadium, label: "âš™ï¸ tempo -target=scalable-single-binary" }
    end

    %% MICROSERVICES MODE
    subgraph MS["ğŸ§© Microservices Mode"]
        X2@{ shape: braces, label: "Scale Per Component" }
        D@{ shape: processes, label: "ğŸ“¤ Distributor xN\n(receive spans)" }
        I@{ shape: processes, label: "ğŸ“¦ Ingester xM\n(write to object storage)" }
        C@{ shape: processes, label: "ğŸ—‚ï¸ Compactor / Scheduler+Workers\n(compact blocks)" }
        QF@{ shape: processes, label: "ğŸ” Query Frontend xK\n(split & cache queries)" }
        Q@{ shape: processes, label: "ğŸ§  Querier xL\n(read from object storage)" }

        %% TRUE TEMPO DATA PATHS
        D --> I
        I --> C
        QF --> Q
    end

    class M,S1,S2,S3 bin
    class D,I,C,QF,Q comp
```

## ğŸ“¦ 1. Monolithic mode (Single process does everything)

### What it is

One Tempo instance runs all components **inside one process**:

- ingest
- index/build blocks
- store to object storage
- query
- compact/retention

Command-line:

```bash
tempo -target=all   # default
```

### Mental model

â€œOne warehouse worker does receiving + packing + searching + cleaning.â€

### âœ… Pros

- Lowest operational complexity
- One Deployment, one Service
- Great for dev / PoC / smallâ€“medium throughput
- Easy Helm install (this is what `grafana-community/tempo` commonly gives you)

### âŒ Cons (the big one)

When sustained volume grows, **one process becomes the bottleneck**:

- memory pressure (indexing + buffering + block building)
- CPU pressure (ingest + query + compaction compete)
- worst case: **OOM â†’ restart â†’ missed traces** (because the process doing ingestion dies)

### When it fits

- â€œWeâ€™re getting startedâ€
- â€œTrace volume is modestâ€
- â€œWe can tolerate some risk during spikesâ€
- â€œWe want easiest opsâ€

---

## (ğŸ“¦+ğŸ“¦+ğŸ“¦) 2. Scaling monolithic mode (Scalable Single Binary / SSB)

> This is the â€œI want more horsepower, but I donâ€™t want full microservices complexityâ€ option.

### What it is

You run **multiple replicas** of Tempo, but each replica still runs â€œall componentsâ€ inside one process.

Command-line:

```bash
tempo -target=scalable-single-binary
```

### What makes it scalable compared to plain monolithic?

The system behavior changes to support multiple replicas safely:

- consistent hashing / ring used to coordinate ingestion responsibilities
- queriers connect to query-frontend via **frontend_address** discovery (DNS lookup)

### Mental model

â€œMultiple warehouse workers, each can do everything, but they coordinate.â€

### âœ… Pros

- Horizontal scale without deploying 6â€“8 separate microservices
- Still simpler than full distributed mode
- Better resilience than a single monolith

### âŒ Cons / gotchas

- Still â€œall roles in one processâ€, so **resource contention remains**
- Requires coordination config (ring, frontend address, etc.)
- Not as clean as microservices for tuning (e.g., â€œI only need more ingestersâ€)

### When it fits

- Youâ€™re outgrowing monolithic
- You want HA-ish behavior
- You want scale but minimal component sprawl

---

## ğŸ¤¹â€â™‚ï¸ 3. Microservices mode (Distributed / â€œreal productionâ€)

### What it is

Each Tempo component runs as its **own Deployment** (its own process):

- Distributor (N replicas)
- Ingester (M replicas)
- Query Frontend (K replicas)
- Querier (L replicas)
- Compactor / or Scheduler+Worker
- (Optional) metrics-generator

Command examples:

```bash
tempo -target=distributor
tempo -target=ingester
tempo -target=query-frontend
tempo -target=querier
...
```

### Mental model

â€œA full warehouse: receiving desk, packing team, detective team, cleaning team â€” each scales independently.â€

### âœ… Pros

- **Scale per component** (need more ingest? scale ingesters; need faster search? scale queriers)
- **Better failure domains** (one component crash doesnâ€™t take everything down)
- **Replication factor** is meaningful (e.g., distributor sends spans to multiple ingesters)
- Preferred for production with high volume / high availability requirements

### âŒ Cons

- Highest operational complexity (more Deployments, services, ring config, upgrades)
- Higher infra cost (more pods, more tuning)
- Needs more observability/maintenance maturity

### When it fits

- Sustained high throughput
- You need real HA and replication
- You need predictable performance under load spikes
- You have ops maturity to run distributed systems

### Helm mapping

- This is the default style for **`tempo-distributed`** chart (Grafana / GET style).

---

## âœ… Practical decision guide

### Choose **Monolithic** if:

- Youâ€™re early-stage / dev / limited throughput
- You want simplest install & upgrades
- Occasional drops during extreme spikes are acceptable

### Choose **SSB** if:

- Monolithic is â€œrunning hotâ€ (CPU/memory)
- You want to scale out quickly
- You still want â€œone logical serviceâ€ operationally

### Choose **Microservices** if:

- You need HA + replication for ingest
- You have heavy sustained ingest
- Query performance matters at scale
- You want proper per-component scaling knobs
