# ğŸ“ƒ Traces

> Think of a **trace** as _one end-to-end request story_ across services, and a **span** as _one chapter in that story_.

![1770322455709](image/traces/1770322455709.png)

---

## ğŸ“– What is a Trace?

A **trace** represents a single transaction/request as it flows through your system.

Example:
User clicks â€œCheckoutâ€ â†’ API Gateway â†’ `orders-service` â†’ `payment-service` â†’ `inventory-service` â†’ DB

That whole journey = **1 trace**.

A trace has:

- **Trace ID**: unique identifier for the whole story
- Many **spans** inside it

---

## ğŸ§© What is a Span?

A **span** is a timed operation.

Typical spans:

- â€œHTTP GET /checkoutâ€ (in `orders-service`)
- â€œCall payment-serviceâ€ (client span)
- â€œPOST /chargeâ€ (server span)
- â€œSQL SELECT â€¦â€ (db span)

A span has:

- **Span ID**: unique per span
- **Trace ID**: which trace it belongs to
- **Parent Span ID**: who called it (creates a tree)
- **Start time + duration**
- **Attributes** (tags): `http.method=GET`, `db.system=postgres`, `service.name=orders`, etc.
- **Status**: OK / ERROR
- Optional **events**: â€œretrying requestâ€, â€œcache missâ€, etc.

So a trace is basically a **tree of spans**.

---

## ğŸ‘·â€â™‚ï¸ Where are traces/spans created? Who creates them?

Theyâ€™re created inside your application at runtime by **instrumentation**:

### A. Auto-instrumentation (most common)

You attach OpenTelemetry auto-instrumentation for your runtime:

- Java agent
- .NET auto-instrumentation
- Node auto-instrumentation
- Python auto-instrumentation

It automatically creates spans for:

- incoming HTTP requests
- outgoing HTTP calls
- DB calls
- messaging (Kafka/RabbitMQ) calls
- etc.

### B. Manual instrumentation (for custom business spans)

You write code like:

- â€œspan: validate cartâ€
- â€œspan: calculate discountâ€
- â€œspan: call external fraud APIâ€

This is how you get high-value spans around business logic.

So: **Your app creates spans** via OpenTelemetry SDK/agent. Tempo only **stores** what you send.

---

## ğŸŒ± How does the first Trace ID appear? (Trace â€œbirthâ€)

At the **entry point** of the request.

Example: User â†’ API Gateway / Ingress / first service

If the incoming request already has tracing headers â†’ you continue that trace.
If not â†’ the first instrumented component creates a new **Trace ID** and starts the **root span**.

Root span example:

- `orders-service` receives HTTP request â†’ creates span `HTTP POST /checkout`
- It becomes the **root span** if there was no parent

---

## ğŸ”— How do services know they should use the SAME Trace ID?

By **context propagation**.

When service A calls service B, it sends tracing context in request headers.

### The key idea

Service A includes:

- Trace ID
- Parent Span ID (its current span)
- Sampling decision (optional)

Service B reads those headers and says:

> â€œOkay, Iâ€™m part of the same trace. Iâ€™ll create a new span as a child.â€

Thatâ€™s how the distributed trace stays connected.

---

## ğŸ·ï¸ What headers carry the Trace Context?

Most modern systems use **W3C Trace Context** headers:

- `traceparent`
- `tracestate` (optional)

`traceparent` includes: trace id + parent span id + flags.

(Older systems might use B3 headers, but W3C is the standard now.)

---

## ğŸ¬ What exactly happens during a call? (Very concrete)

### Step-by-step HTTP example

**1. Request enters Service A:**

- OTel instrumentation creates span `A: inbound HTTP`
- Trace ID created if none exists

**2. Service A calls Service B:**

- OTel creates span `A: outbound HTTP to B`
- It injects `traceparent` header containing the same Trace ID + current span as parent

**3. Service B receives the request:**

- OTel reads `traceparent`
- It creates span `B: inbound HTTP` with:
  - same Trace ID
  - parent span id = span from A

Now you can see the connection in Tempo:
`A inbound` â†’ `A outbound` â†’ `B inbound` â†’ `B outbound` â†’ etc.

---

## ğŸ“¨ What about async / queues? (RabbitMQ/Kafka)

Same concept, but propagation happens via message headers instead of HTTP headers.

- Producer span: â€œpublish messageâ€
- Consumer span: â€œprocess messageâ€
- Trace context is injected into message metadata/headers

If propagation is missing/misconfigured, youâ€™ll see **broken traces** (new traces start at consumer).

---

## ğŸ—„ï¸ Where does Tempo fit?

Tempo does **not** create spans.
Tempo is a **trace backend**:

- receives spans (OTLP)
- stores them (local disk / S3 / Azure Blob, etc.)
- lets Grafana query and visualize traces

Pipeline:
**App (OTel)** â†’ **Collector/Alloy** â†’ **Tempo** â†’ **Grafana**

---

## ğŸ§  One mental model that never fails

- **Trace = Request Journey (ID shared across services)**
- **Span = Timed step inside that journey**
- **Propagation = How the same Trace ID travels**
- **Instrumentation = Who creates spans**
- **Tempo = Where spans are stored and queried**
